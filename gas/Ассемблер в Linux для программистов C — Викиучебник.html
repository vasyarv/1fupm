<!DOCTYPE html>
<!-- saved from url=(0197)https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C -->
<html lang="ru" dir="ltr" class="client-js ve-not-available"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title>Ассемблер в Linux для программистов C — Викиучебник</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ = window.RLQ || []).push(function () {
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Ассемблер_в_Linux_для_программистов_C","wgTitle":"Ассемблер в Linux для программистов C","wgCurRevisionId":122296,"wgRevisionId":122296,"wgArticleId":6230,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Ассемблер"],"wgBreakFrames":false,"wgPageContentLanguage":"ru","wgPageContentModel":"wikitext","wgSeparatorTransformTable":[",\t."," \t,"],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","январь","февраль","март","апрель","май","июнь","июль","август","сентябрь","октябрь","ноябрь","декабрь"],"wgMonthNamesShort":["","янв","фев","мар","апр","май","июн","июл","авг","сен","окт","ноя","дек"],"wgRelevantPageName":"Ассемблер_в_Linux_для_программистов_C","wgRelevantArticleId":6230,"wgRequestId":"4ba420ab6e00c48fb940d840","wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"preview":false,"publish":false},"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgVisualEditor":{"pageLanguageCode":"ru","pageLanguageDir":"ltr","usePageImages":false,"usePageDescriptions":true},"wgPreferredVariant":"ru","wgULSAcceptLanguageList":[],"wgULSCurrentAutonym":"русский","wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgNoticeProject":"wikibooks","wgCentralNoticeCategoriesUsingLegacy":["Fundraising","fundraising"],"wgCentralAuthMobileDomain":false,"wgVisualEditorToolbarScrollOffset":0}); /* @nomin */mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"ru"});});mw.loader.implement("user.tokens",function ( $, jQuery ) {
mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"}); /* @nomin */ ;

});mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","ext.centralauth.centralautologin","mmv.head","ext.visualEditor.desktopArticleTarget.init","ext.uls.init","ext.uls.interface","mw.MediaWikiPlayer.loader","mw.PopUpMediaTransform","ext.centralNotice.bannerController","skins.vector.js"]);
} );</script>
<link rel="stylesheet" href="./Ассемблер в Linux для программистов C — Викиучебник_files/load.php">
<style>
@-webkit-keyframes centralAuthPPersonalAnimation{0%{opacity:0;-webkit-transform:translateY(-20px)}100%{opacity:1;-webkit-transform:translateY(0)}}@-moz-keyframes centralAuthPPersonalAnimation{0%{opacity:0;-moz-transform:translateY(-20px)}100%{opacity:1;-moz-transform:translateY(0)}}@-o-keyframes centralAuthPPersonalAnimation{0%{opacity:0;-o-transform:translateY(-20px)}100%{opacity:1;-o-transform:translateY(0)}}@keyframes centralAuthPPersonalAnimation{0%{opacity:0;transform:translateY(-20px)}100%{opacity:1;transform:translateY(0)}}.centralAuthPPersonalAnimation{-webkit-animation-duration:1s;-moz-animation-duration:1s;-o-animation-duration:1s;animation-duration:1s;-webkit-animation-fill-mode:both;-moz-animation-fill-mode:both;-o-animation-fill-mode:both;animation-fill-mode:both;-webkit-animation-name:centralAuthPPersonalAnimation;-moz-animation-name:centralAuthPPersonalAnimation;-o-animation-name:centralAuthPPersonalAnimation;animation-name:centralAuthPPersonalAnimation}
.ve-activated #toc,.ve-activated #siteNotice,.ve-activated .mw-indicators, .ve-active #bodyContent > :not( #siteSub ):not( #contentSub ):not( .ve-ui-mwTocWidget ),.ve-activated #t-print,.ve-activated #t-permalink,.ve-activated #p-coll-print_export,.ve-activated #t-cite,.ve-deactivating .ve-ui-surface{display:none} .ve-activating .ve-ui-surface{height:0;overflow:hidden}.ve-activated #bodyContent,.ve-activated #firstHeading{opacity:0.6;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ve-activated #firstHeading{cursor:default} .ve-activated #content{position:relative}.ve-init-mw-desktopArticleTarget-loading-overlay{position:absolute;left:0;right:0;z-index:1;margin-top:-0.5em}.ve-init-mw-desktopArticleTarget-progress{height:1em;overflow:hidden;margin:0 25%}.ve-init-mw-desktopArticleTarget-progress-bar{height:1em;width:0} .mw-editsection{white-space:nowrap; unicode-bidi:-moz-isolate;unicode-bidi:-webkit-isolate;unicode-bidi:isolate}.mw-editsection-divider{color:#555} .ve-init-mw-desktopArticleTarget-progress{height:0.75em;border:1px solid #347bff;background:#fff;border-radius:2px;box-shadow:0 0.1em 0 0 rgba(0,0,0,0.15) }.ve-init-mw-desktopArticleTarget-progress-bar{height:0.75em;background:#347bff}
.uls-menu a{cursor:pointer}.uls-menu.callout .caret-before{border-top:20px solid transparent;border-right:20px solid #C9C9C9;border-bottom:20px solid transparent;display:inline-block;left:-21px;top:30px;position:absolute}.uls-menu.callout .caret-after{border-top:20px solid transparent;border-right:20px solid #FCFCFC;border-bottom:20px solid transparent;display:inline-block;left:-20px;top:30px;position:absolute}.uls-ui-languages button{width:23%;text-overflow:ellipsis;margin-right:4%}button.uls-more-languages{width:auto}.settings-title{font-size:11pt}.settings-text{color:#555555;font-size:9pt}div.display-settings-block:hover .settings-text{color:#252525}
#container{position:relative;min-height:100%}#container,video{width:100%;height:100%}#playerContainer{overflow:hidden;position:relative;height:100%;background:#000}#videoHolder{position:relative;overflow:hidden}.fullscreen #playerContainer{position:absolute !important;width:100% !important;height:100%! important;z-index:9999;min-height:100%;top:0;left:0;margin:0}.mwEmbedPlayer{width:100%;height:100%;overflow:hidden;position:absolute;top:0;left:0}.modal_editor{ left:10px;top:10px;right:10px;bottom:10px;position:fixed;z-index:100}.displayHTML a:visited{color:white}.loadingSpinner{width:32px;height:32px;display:block;padding:0px;background-image:url(/w/extensions/MwEmbedSupport/MwEmbedModules/MwEmbedSupport/skins/common/images/loading_ani.gif?a51c5)}.mw-imported-resource{border:thin solid black}.kaltura-icon{background-image:url(/w/extensions/MwEmbedSupport/MwEmbedModules/MwEmbedSupport/skins/common/images/kaltura_logo_sm_transparent.png?fa5c4) !important;background-repeat:no-repeat;display:block;height:12px;width:12px;margin-top:2px !important;margin-left:3px !important}.mw-fullscreen-overlay{background:rgb(0,0,0) none repeat scroll 0% 0%;position:fixed;top:0pt;left:0pt;width:100%;height:100%;-moz-background-clip:border;-moz-background-origin:padding;-moz-background-inline-policy:continuous} .play-btn-large{width:70px;height:53px;background :url(/w/extensions/MwEmbedSupport/MwEmbedModules/MwEmbedSupport/skins/common/images/player_big_play_button.png?69699);position :absolute;cursor :pointer;border :none !important; }.play-btn-large:hover{background :url(/w/extensions/MwEmbedSupport/MwEmbedModules/MwEmbedSupport/skins/common/images/player_big_play_button_hover.png?97c2a)}.carouselContainer{position :absolute;width :100%;z-index :2}.carouselVideoTitle{position :absolute;top :0px;left :0px;width :100%;background :rgba(0,0,0,0.8);color :white;font-size :small;font-weight :bold;z-index :2}.carouselVideoTitleText{display :block;padding :10px 10px 10px 20px}.carouselTitleDuration{position :absolute;top :0px;right :0px;padding :2px;background-color :#5A5A5A;color :#D9D9D9;font-size :smaller;z-index :2}.carouselImgTitle{position :absolute;width :100%;text-align :center;color :white;font-size :small;background :rgba(0,0,0,0.4)}.carouselImgDuration{position :absolute;top :2px;left :2px;background :rgba( 0,0,0,0.7 );color :white;padding :1px 6px;font-size :small}.carouselPrevButton,.carouselNextButton{display :block;position :absolute;bottom:23px}.carouselPrevButton{left :5px}.carouselNextButton{right:6px}.alert-container{border-radius:3px;background-image:-webkit-gradient(linear,left bottom,left top,color-stop(0.04,rgb(215,215,215)),color-stop(0.55,rgb(230,230,230)),color-stop(1,rgb(255,255,255)));background-image:-o-linear-gradient(bottom,rgb(215,215,215) 4%,rgb(230,230,230) 55%,rgb(255,255,255) 100%);background-image:-ms-linear-gradient(bottom,rgb(215,215,215) 4%,rgb(230,230,230) 55%,rgb(255,255,255) 100%);background-image:-moz-linear-gradient(bottom,rgb(215,215,215) 4%,rgb(230,230,230) 55%,rgb(255,255,255) 100%);background-image:-webkit-linear-gradient(bottom,rgb(215,215,215) 4%,rgb(230,230,230) 55%,rgb(255,255,255) 100%);background-image:linear-gradient(bottom,rgb(215,215,215) 4%,rgb(230,230,230) 55%,rgb(255,255,255) 100%);margin:auto;position:absolute;top:0;left:0;right:0;bottom:0;max-width:80%;max-height:30%}.alert-title{background-color :#E6E6E6;padding :5px;border-bottom :1px solid #D1D1D1;font-weight :normal !important;font-size:14px !important;border-top-left-radius:3px;border-top-right-radius:3px }.alert-message{padding :5px;font-weight :normal !important;text-align:center;font-size:14px !important}.alert-buttons-container{text-align:center;padding-bottom:5px}.alert-button{background-color:#474747;color:white;border-radius:.5em;padding:2px 10px;background-image:-webkit-gradient( linear,left bottom,left top,color-stop(0.04,rgb(25,25,25)),color-stop(0.55,rgb(47,47,47)),color-stop(0.68,rgb(71,71,71)) );background-image:-o-linear-gradient(bottom,rgb(25,25,25) 4%,rgb(47,47,47) 55%,rgb(71,71,71) 68%);background-image:-moz-linear-gradient(bottom,rgb(25,25,25) 4%,rgb(47,47,47) 55%,rgb(71,71,71) 68%);background-image:-ms-linear-gradient(bottom,rgb(25,25,25) 4%,rgb(47,47,47) 55%,rgb(71,71,71) 68%);background-image:-webkit-linear-gradient(bottom,rgb(25,25,25) 4%,rgb(47,47,47) 55%,rgb(71,71,71) 68%);background-image:linear-gradient(bottom,rgb(25,25,25) 4%,rgb(47,47,47) 55%,rgb(71,71,71) 68%)}.alert-text{color :black !important}
.PopUpMediaTransform a .play-btn-large{top:50%;left :50%;width:70px;height:53px;margin-left:-35px;margin-top:-25px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAAA1CAYAAAD8mJ3rAAADNklEQVR4AWJAAhxA7AHEeUDcP8JwHtTvHAxoQAuI5wDxZkD75qBkSRKG0bZt21h7t23btm2bO7ZthNq2rq3mo0zWeKaty6yI8wB1Et+fEnDuIC4+SdEGvIBSPvP6oxOhYihjG8WImHtQxDaAk52GEeQFT4uBYqAYKAaKUVNTG9bX1x+FYj4iLi4+UFVVRXjz5s0Wwo0bN1geHh7zAi8mKSkJ9fLly63vOX/+POO3336bElgx////P/3Fixdbu9HS0kKxsLAYFzgxZ8+eZTx9+nRzP8rKygh6enqjAiOmt7eX/ujRo82DcP/+/fWsrCyskpLSEN+L6e7upoMf3jgMt27dWouKilqRkZEZ5FsxHR0dtDt37qwfhUuXLrG8vb0XxMTEBvhODJhcaSCi149DZ2cn3cHBYZavxDQ2NlKvXLmydhLU19dTfvjhhym+EFNXV0e5ePHi6klSVFREMDIyGuNpMdXV1WQQ2azTIDU1FaOpqTnCk2IqKirIPT09zNOiq6uLARIMpaCgMMhTYkpLS0kgmZinDZjk6SDBFiUlJQd4QkxhYSGxra2Nzi7AgpVibm4+zvVi8vLyiE1NTXR2gshBeg5Xi8nOziaAZKKxG7AwneBqMZmZmQSQTFR2o6OjM8LVYkCk4svLyynsJCYmBs31c0xycjKupKSEwg5A4Ud2c3NbkJCQGOB6MfHx8diCggLyaePr67ukqKg4xDN1DOjWWJBMpNMiODgYtb365QExoCrFgs0n4kkTHh6OBqcOYzy7VoqIiMCkp6cTT4ro6GgsKOAmeH51HRYWhgbJRDgusbGxODs7uylhYeF+vth2CAkJQYNkIhwVRMgvv/wyg5xP8dVGVVBQECoxMRF/WECa4f7666+57aU9n4gJCAhAIT95GBwcHObl5OQG+fqUwN/fH4UMh4Pg7u6+pKqqOsx+AVwqxsfHZ0VLS2tUoE4ikV6wm5DAwECUsbHxuECeXevq6o59LwREOMbKympyW/QKkhgEZJi4uLgsIr0H1CLT+0QvvFEFxUAxUAwUA8Xs+pYAviUohSK2UfrpvdJrKOMzbz86ef/9AIfU5yH0AyJklzeR8E3kO5B6nR5s2Y8qAAAAAElFTkSuQmCC);background-image:url(/w/extensions/TimedMediaHandler/resources/player_big_play_button.png?f49a4)!ie}.PopUpMediaTransform a .play-btn-large :hover{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAAA1CAYAAAD8mJ3rAAADSklEQVR4AeybA4wlWRRA1/u1tjG2g3YHY0/U4djTtm3btm3bTtu27du2WVXvJif8PIV3Ue+jBUECrgPsgAbBYAeuTzlYEicBU8CH4JhOuZiJ3wBHJGUOlyknEJxIxlLACYQ5ErEMcLLSZYRwRGKQGCQGicG0mP/++y/4/Pnz4UjMDCQSyQ+ianR0dGyS6urqbnZ29nTCi9HR0SkYHBwcW0peXl7Ho0ePEggrJisrq62/v390NWJjYxsZGRmjCCcmJyeno7u7e2Q9PDw8qs6ePRtOGDEZGRntEMMbobm5edDCwqLsjz/+CMK9mNTU1Db4w0Oboaampk9BQSH/22+/DcCtmMTExNb6+vrBrVBYWNjNzc2d+eWXX/rhTkx0dHRLZWXlwHZISkpqe/LkSSquxISHhzeXlJT07QShoaFNN2/ejMeFmODg4KaCgoLencTZ2bn68uXLEZgW4+/v3wBLdvduYGBgUHL06NFQTIrx9vauT09P79otUlJSOhQVFQt++eWXQEyJcXNzq4OVqXO3iYqKaoMVLJtGo/ljQoyjo2MtpP3tewUUrE0MDAzRB16MjY1NDaxMbXuJr69vE5VK9T/QYiDFrw4KCmrda6AwjTnQYkxMTKrg9G7ea06ePBl2oMXAklrp6enZtJcoKSkVY6FRVeHi4tK4F8CNvuHNmzdZFArF/8CLUVdXL7O3t6/fbXh4eHJ//fXXIMzkMcrKyqXW1tZ1u4WoqGjBkSNHQjGX+crLy5eamZnV7jTS0tLF586di8RsrSQjI1NiZGRUs1NA+l9KT08fg/nqWlJSslhfX796u6ioqJRfu3Yt/pNPPvHFRdtBTEysSFtbu2qrgJCKe/fuJZPJZH9cNapEREQKNTU1KzeLmppaBRsbW9qyohAvYgQFBQsm/+RmgDZmxo8//hiI6ykBPz9/weTlsBHevn2b+88//4TMvZ/oYri5ufOPHz8eTqhJ5Lt373JWEyIsLFx45cqVaELOrk+fPh0J2W/5QiGwhJewsrLGzS29RBQzyeRl8vLly+zJswdykUQSieSPHhxaHSQGiUFikBgkBu0lWH0vATcSsQzu2f1KLkjGHG4TA4cJFOjBs9RoFtIDBQiOPZGjeyIBuiuBC06Nbn0AAAAASUVORK5CYII=);background-image:url(/w/extensions/TimedMediaHandler/resources/player_big_play_button_hover.png?8a926)!ie} .mw-tmh-playtext{display:block;height:0;overflow:hidden}
@media print{#centralNotice{display:none}}.cn-closeButton{display:inline-block;zoom:1;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAMAAABFjsb+AAABelBMVEX///////80NDT///////////////////////////8yMjIzMzM5OTkMDAxlZWWCgoIvLy////8AAAD9/f3////8/PxjY2Pa2tpqamo7Ozvp6elFRUWEhITCwsLNzc1WVlbY2Ng3Nzf+/v57e3vb29ufn58LCwthYWExMTFSUlJDQ0Py8vJXV1cvLy9WVlbExMQBAQH+/v59fX14eHg2NjYuLi5VVVXc3Nz6+vrIyMjj4+Pn5+dGRkZ5eXmBgYHp6elsbGwwMDB8fHz8/PzOzs5XV1c1NTXQ0NDn5+dkZGRnZ2ft7e3l5eUtLS3d3d07OztDQ0PHx8eRkZGysrJbW1v8/Pzu7u40NDRUVFRsbGzb29uIiIiXl5fi4uLy8vJmZmbh4eHp6elpaWmioqKCgoJ5eXk5OTmcnJxsbGzy8vJiYmKwsLDk5ORAQEA8PDw6OjrAwMCqqqqCgoLx8fHz8/Pr6+vx8fHj4+NlZWXn5+dtbW2jo6OdnZ16enp8kgr/AAAAfnRSTlMAqOd5JlJZc5YX5+flANTK6SMAmaap1L/c5Lngyre12rHlqc2xzADd6NrhsNno37cAqMzZ5unasJq1vbjf2Ne40ujLmrTf5sK23tOyteq95eC2xsneq7Hm4Ny/yNG5ttuws9zJ1dfky9q31cu65OPkxsbWtrezsLrbudrJy9cUNT7KAAAA+ElEQVQYV2NgAAEWVmYOEQ5mVhYGCOBV42QT1pfhE+PjlxVm4zQQAokJsqsYSYdzc3MzaSkrsAuCxDjZ5eS5FDNUk9NT0zQ0Ldk5gWJsCTq6rlGihoyMolJJpmbmbEDjnfm5IqzsExkZGbVzrOMdnSxYGFhdbEzcPZg8Mxm9bX39pPwDAlkZmIPcQkLDJAQio1IE9OIY7ZiimRk4HJhilBh9jHkkedRjGRmDubw4GESymLKBZonn5uUXAOlCLjERrOoQ5hUJ6BVDzIPZW4JkL9R9pUCzysqtK8Dug/hDHOyPSgmIP6D+rVKtrqmVhPkXW7hgCz/McAYAItEzkWDsbM4AAAAASUVORK5CYII=);background:url(/w/extensions/CentralNotice/resources/subscribing/CloseWindow19x19.png?d968e)!ie;width:19px;height:19px;text-indent:19px;white-space:nowrap;overflow:hidden}
.cite-accessibility-label{position:absolute !important; top:-99999px;clip:rect(1px 1px 1px 1px); clip:rect(1px,1px,1px,1px);padding:0 !important;border:0 !important;height:1px !important;width:1px !important;overflow:hidden}
@media screen {
	.tochidden,.toctoggle{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.toctoggle{font-size:94%}}
@media print {
	#toc.tochidden,.toctoggle{display:none}}
.postedit-container{margin:0 auto;position:fixed;top:0;height:0;left:50%;z-index:1000;font-size:13px}.postedit-container:hover{cursor:pointer}.postedit{position:relative;top:0.6em;left:-50%;padding:.6em 3.6em .6em 1.1em;line-height:1.5625em;color:#626465;background-color:#f4f4f4;border:1px solid #dcd9d9;text-shadow:0 0.0625em 0 rgba(255,255,255,0.5);border-radius:5px;box-shadow:0 2px 5px 0 #ccc;-webkit-transition:all 0.25s ease-in-out;-moz-transition:all 0.25s ease-in-out;-ms-transition:all 0.25s ease-in-out;-o-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out}.skin-monobook .postedit{top:6em !important}.postedit-faded{opacity:0}.postedit-icon{padding-left:41px;  line-height:25px;background-repeat:no-repeat;background-position:8px 50%}.postedit-icon-checkmark{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB9ElEQVR4AZWRA3AYURQArxrVHtW2bdu2bdu2zdi2bdu2bWxs7zeehZaw4f70kbs+zI3e/nWK+RWx3aOFlrL56Sy5SxrruG69hlv6OyK+mz+8KDSXdXembj0ispT7tjs4ZTIbpYBvxGSGKzZTeFrb7W/meN002swFs0U8ttpHTkF2BvCqWQrW35929bTsKm5Zb+SEwWwcY8wAngB9m7Z+d+rIPZ/npdy12M5p47n8dXsCYAf0qPy06eGMdktuDu9Qf+JmKl3SWM91qzVcN9tAbEYkwMaq0tyb1m/To5kP170el/BK8/qa6sJr70ydf+T/Uu5ab+Oo/lS0AkUBpIFWlZ9WPhxpse/PHO7YbOOczjL0vZV2lNxPPtG73dYXM+xvm2znrOl83tidoqCwMBgYXsPFB0on5S6pr+eK5TKuW67lgvaKvF8mL1dtfTL32FHxRdyx3cQpg7m4x9sCXKkTIzA4LDH44zWdzaUf71hv5rTG4uyzcusybxSX7aThbMQ8XgCYAp3rzTTQOiIh9PNlzY3FSuZxrzjme1Y7uGS6kjsWO4jPjM4FVjRZsvD4kO9XtTZzQn82NyzWc0B7AmZh6gA/hOYSGhfw9YbOVnarj+S7800AL2BIsxUAbWNToj7bhBuQmZcOsFdoKUC74rGheCwXmqAIQTc9jQcrADIAAAAASUVORK5CYII=);background-image:url(/w/resources/src/mediawiki.action/images/green-checkmark.png?d94f1)!ie;background-position:left}.postedit-close{position:absolute;padding:0 .8em;right:0;top:0;font-size:1.25em;font-weight:bold;line-height:2.3em;color:black;text-shadow:0 0.0625em 0 white;text-decoration:none;opacity:0.2;filter:alpha(opacity=20)}.postedit-close:hover{color:black;text-decoration:none;opacity:0.4;filter:alpha(opacity=40)}
.allpagesredirect,span.redirect-in-category a{font-style:italic}#mw-subcategories,#mw-pages{clear:both}.gallerybox .thumb img,.filehistory a img,#file img{background:url(//upload.wikimedia.org/wikipedia/commons/5/5d/Checker-16x16.png) repeat}#wpSave{font-weight:bold}.mw-tag-markers{font:italic 90% sans-serif}.warningbox{background:#ff9;border:1px solid #ee0;background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/6/62/Nuvola_apps_important.png/30px-Nuvola_apps_important.png)}.informationbox{background:#f4fbff;border:1px solid #d5d9e6;background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/2/28/Information.svg/30px-Information.svg.png)}.warningbox,.informationbox{padding:10px 10px 10px 50px;background-position:10px center;background-repeat:no-repeat;vertical-align:middle;font-size:smaller}pre{overflow-x:auto;overflow-y:hidden}pre,textarea{tab-size:4} div.thumb{border:none}div.tright{border:none;margin:0.5em 0 0.8em 1.4em}div.tleft{border:none;margin:0.5em 1.4em 0.8em 0}div.thumb img.thumbimage{background-color:#fff} .hlist dl,.hlist ol,.hlist ul{margin:0;padding:0} .hlist dd,.hlist dt,.hlist li{margin:0;display:inline} .hlist.inline,.hlist.inline dl,.hlist.inline ol,.hlist.inline ul,.hlist dl dl,.hlist dl ol,.hlist dl ul,.hlist ol dl,.hlist ol ol,.hlist ol ul,.hlist ul dl,.hlist ul ol,.hlist ul ul{display:inline} .hlist .mw-empty-li{display:none} .hlist dt:after{content:":"}.hlist dd:after,.hlist li:after{content:" •";font-weight:bold}.hlist dd:last-child:after,.hlist dt:last-child:after,.hlist li:last-child:after{content:none} .hlist dd dd:first-child:before,.hlist dd dt:first-child:before,.hlist dd li:first-child:before,.hlist dt dd:first-child:before,.hlist dt dt:first-child:before,.hlist dt li:first-child:before,.hlist li dd:first-child:before,.hlist li dt:first-child:before,.hlist li li:first-child:before{content:" (";font-weight:normal}.hlist dd dd:last-child:after,.hlist dd dt:last-child:after,.hlist dd li:last-child:after,.hlist dt dd:last-child:after,.hlist dt dt:last-child:after,.hlist dt li:last-child:after,.hlist li dd:last-child:after,.hlist li dt:last-child:after,.hlist li li:last-child:after{content:") ";font-weight:normal} .hlist ol{counter-reset:listitem}.hlist ol > li{counter-increment:listitem}.hlist ol > li:before{content:" " counter(listitem) " ";white-space:nowrap}.hlist dd ol > li:first-child:before,.hlist dt ol > li:first-child:before,.hlist li ol > li:first-child:before{content:" (" counter(listitem) " "} .plainlist ol,.plainlist ul{line-height:inherit;list-style:none none;margin:0}.plainlist ol li,.plainlist ul li{margin-bottom:0} table.standard,table.wide,table.prettytable{border:1px solid #aaa;border-collapse:collapse}table.standard th,table.wide th,table.prettytable th{border:1px solid #aaa;padding-left:0.2em;padding-right:0.2em;background:#eef}table.standard td,table.wide td,table.prettytable td{border:1px solid #aaa;padding-left:0.2em;padding-right:0.2em}table.standard caption,table.wide caption,table.tiles caption{font-weight:bold;padding-top:0.2em;padding-bottom:0.2em}table.wide{width:100%}table.simple{border-color:#aaa;border-collapse:collapse}table.simple th,table.simple td{border-color:#aaa;padding-left:0.2em;padding-right:0.2em}table.tiles{border-collapse:separate;border-spacing:2px}table.tiles th{padding-left:0.2em;padding-right:0.2em;background:#eef}table.tiles td{padding-left:0.2em;padding-right:0.2em;background:#f0f0f0}table.graytable{background:#f0f0f0;padding:1em;width:100%}table.graytable caption{padding-top:0.5em;background:#f0f0f0;font-weight:bold}table.graytable caption span.subcaption{font-size:80%;font-weight:normal}table.graytable th,table.graytable td{font-size:80%}tr.highlight th,table tr th.highlight{background:#eef}tr.highlight td,table tr td.highlight{background:#ffe;font-weight:normal}tr.bright th,table tr th.bright{background:#ccf}tr.bright td,table tr td.bright{background:#fec}tr.shadow th,tr.shadow td,table tr th.shadow,table tr td.shadow{background:#f0f0f0}tr.dark th,tr.dark td,table tr th.dark,table tr td.dark{background:#ccc}.transparent{background:transparent !important}table.toccolours th{background:#ccf} th.mbox-text,td.mbox-text{ border:none; padding:0.25em 0.9em; width:100%; }td.mbox-image{ border:none; padding:2px 0 2px 0.9em; text-align:center}td.mbox-imageright{ border:none; padding:2px 0.9em 2px 0; text-align:center}td.mbox-empty-cell{ border:none;padding:0px;width:1px} table.imbox{margin:4px 10%;border-collapse:collapse;border:3px solid #1e90ff; background:#fbfbfb}.imbox .mbox-text .imbox{ margin:0 -0.5em; display:block; }.mbox-inside .imbox{ margin:4px}table.imbox-notice{border:3px solid #1e90ff; }table.imbox-speedy{border:3px solid #b22222; background:#fee; }table.imbox-delete{border:3px solid #b22222; }table.imbox-content{border:3px solid #f28500; }table.imbox-style{border:3px solid #f4c430; }table.imbox-move{border:3px solid #9932cc; }table.imbox-protection{border:3px solid #bba; }table.imbox-license{border:3px solid #88a; background:#f7f8ff; }table.imbox-featured{border:3px solid #cba135; } table.cmbox{margin:3px 10%;border-collapse:collapse;border:1px solid #aaa;background:#dfe8ff; }table.cmbox-notice{background:#d8e8ff; }table.cmbox-speedy{margin-top:4px;margin-bottom:4px;border:4px solid #b22222; background:#ffdbdb; }table.cmbox-delete{background:#ffdbdb; }table.cmbox-content{background:#ffe7ce; }table.cmbox-style{background:#fff9db; }table.cmbox-move{background:#e4d8ff; }table.cmbox-protection{background:#efefe1; } table.ombox{margin:4px 10%;border-collapse:collapse;border:1px solid #aaa; background:#f9f9f9}table.ombox-notice{border:1px solid #aaa; }table.ombox-speedy{border:2px solid #b22222; background:#fee; }table.ombox-delete{border:2px solid #b22222; }table.ombox-content{border:1px solid #f28500; }table.ombox-style{border:1px solid #f4c430; }table.ombox-move{border:1px solid #9932cc; }table.ombox-protection{border:2px solid #bba; } table.tmbox{margin:4px 10%;border-collapse:collapse;border:1px solid #c0c090; background:#f8eaba}.mediawiki .mbox-inside .tmbox{ margin:2px 0; width:100%; }.mbox-inside .tmbox.mbox-small{ line-height:1.5em; font-size:100%; }table.tmbox-speedy{border:2px solid #b22222; background:#fee; }table.tmbox-delete{border:2px solid #b22222; }table.tmbox-content{border:2px solid #f28500; }table.tmbox-style{border:2px solid #f4c430; }table.tmbox-move{border:2px solid #9932cc; }table.tmbox-protection,table.tmbox-notice{border:1px solid #c0c090; } table.ambox{width:auto;margin:0 10%;border-collapse:collapse;background:#fbfbfb;border:1px solid #aaa;border-left:10px solid #1e90ff}table.ambox th,table.ambox td{padding:0.25em 0.5em}table.ambox td.ambox-widthhack{padding:0}table.ambox td.ambox-text{width:100%}table.ambox td.ambox-text .ambox-text-small{font-size:smaller}table.ambox td.ambox-image{width:52px;padding:2px 0 2px 0.5em;text-align:center}table.ambox td.ambox-imageright{width:52px;padding:2px 4px 2px 0;text-align:center}table.ambox td.ambox-image div,table.ambox td.ambox-imageright div{ width:52px}table.ambox-delete,table.ambox-serious{border-left:10px solid #b22222}table.ambox-content{border-left:10px solid #f28500}table.ambox-style{border-left:10px solid #f4c430}table.ambox-good{border-left:10px solid #66cc44}table.ambox-discussion{border-left:10px solid #339966}table.ambox-notice{border-left:10px solid #1e90ff}table.ambox-merge{border-left:10px solid #9932cc}table.ambox.ambox-mini{float:right;clear:right;margin:0 0 0.5em 1em;width:20%} table.fmbox{clear:both;margin:0.2em 0;width:100%;border:1px solid #aaa; background:#f9f9f9}table.fmbox-system{background:#f9f9f9}table.fmbox-warning{border:1px solid #bb7070; background:#ffdbdb; }table.fmbox-editnotice{background:transparent} div.mw-warning-with-logexcerpt,div.mw-lag-warn-high,div.mw-cascadeprotectedwarning,div#mw-protect-cascadeon{clear:both;margin:0.2em 0;border:1px solid #bb7070;background:#ffdbdb;padding:0.25em 0.9em} div.mw-lag-warn-normal,div.fmbox-system{clear:both;margin:0.2em 0;border:1px solid #aaa;background:#f9f9f9;padding:0.25em 0.9em} body.mediawiki table.mbox-small{  clear:right; float:right; margin:4px 0 4px 1em;width:238px;font-size:88%;line-height:1.25em}body.mediawiki table.mbox-small-left{  margin:4px 1em 4px 0;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.infobox{border:1px solid #aaa;background:#f9f9f9;margin-bottom:0.5em;margin-left:1em;padding:.4em;float:right;clear:right;font-size:88%;width:23em;vertical-align:middle;text-align:left;line-height:1.5em;border-collapse:separate;border-spacing:2px}.infobox > caption{font-size:125%;font-weight:bold}.infobox td,.infobox th{vertical-align:top} table.infobox td p{margin:0 !important} .infobox th>ul,.infobox td>ul{list-style-type:none;list-style-image:none;margin:0}.infobox th>ol,.infobox td>ol{line-height:1.1em;margin:0 0 0 2em}.infobox li{margin-bottom:0}.notice{text-align:justify;margin:1em 0.5em;padding:0.5em}.messagebox{border:thin solid #aaa;background:#f9f9f9;width:88%;margin:0 auto 1em auto;padding:.4em;vertical-align:middle;font-size:90% }blockquote{margin:0.7em 0 0.7em 5%;padding:0.7em 2% 0.7em 4%;background:#f5f5f5}ol.references{font-size:100%}.references-small{font-size:90%} sup.reference:target,ol.references li:target,.highlight-target:target,cite:target,span.citation:target{background:#DEF}sup.reference:target{font-weight:bold} .references-scroll{overflow:auto;padding:3px} sub,sup{line-height:1em}.plainlinksneverexpand,.plainlinksneverexpand a{background:none !important;padding:0 !important}.plainlinksneverexpand a.external.text:after,.plainlinksneverexpand a.external.autonumber:after,.plainlinksneverexpand .urlexpansion{display:none !important}.clickable-image a:hover{text-decoration:none}.printonly{display:none}.dablink,.rellink{font-style:italic;padding-left:1.6em}#disambig{border-top:3px double #ccc;border-bottom:3px double #ccc} .toclimit-2 .toclevel-2,.toclimit-3 .toclevel-3,.toclimit-4 .toclevel-4,.toclimit-5 .toclevel-5,.toclimit-6 .toclevel-6,.toclimit-7 .toclevel-7,.nonumtoc .tocnumber{display:none} a[href$=".pdf"].external,a[href*=".pdf?"].external,a[href*=".pdf#"].external,a[href$=".PDF"].external,a[href*=".PDF?"].external,a[href*=".PDF#"].external,span.PDFlink a{background:url(//upload.wikimedia.org/wikipedia/commons/2/23/Icons-mini-file_acrobat.gif) center right no-repeat !important;padding-right:18px !important} .audiolink a{background:url(//upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Loudspeaker.svg/11px-Loudspeaker.svg.png) center left no-repeat !important;padding-left:16px !important;padding-right:0 !important} div.listenlist{background:url(//upload.wikimedia.org/wikipedia/commons/3/3f/Gnome_speakernotes_30px.png);padding-left:40px}div.videolist,div.multivideolist{background:url(//upload.wikimedia.org/wikipedia/en/thumb/2/20/Tango-video-x-generic.png/40px-Tango-video-x-generic.png);padding-left:50px}div.medialist{min-height:50px;margin:1em;background-position:top left;background-repeat:no-repeat}div.medialist ul{list-style-type:none;list-style-image:none;margin:0}div.medialist ul li{padding-bottom:0.5em}div.medialist ul li li{font-size:91%;padding-bottom:0} table.navigation-box th,table.navigation-box td{vertical-align:middle;height:30px} div.Boxmerge,div.NavFrame{margin:0;padding:2px;border:1px solid #aaa;text-align:center;border-collapse:collapse;font-size:95%}div.Boxmerge div.NavFrame{border-style:none;border-style:hidden}div.NavFrame + div.NavFrame{border-top-style:none;border-top-style:hidden}div.NavPic{background:#fff;margin:0;padding:2px;float:left}div.NavFrame div.NavHead{height:1.6em;font-weight:bold;font-size:100%;background:#efefef;position:relative}div.NavFrame p,div.NavFrame div.NavContent,div.NavFrame div.NavContent p{font-size:100% }div.NavEnd{margin:0;padding:0;line-height:1px;clear:both}a.NavToggle{float:right;top:0;right:11px;font-weight:normal;font-size:smaller}.messagebox.standard-talk{border:1px solid #c0c090;background:#f8eaba}.messagebox .floatleft{vertical-align:middle;clear:both;margin:2px;padding:0}.messagebox .image{margin:0;padding:0} #coordinates{position:absolute;z-index:1;right:9em;top:3.7em;float:right;line-height:1.5em;text-align:right;font-size:85%;white-space:nowrap}#coordinates,.coordinates{text-transform:none;margin:0;padding:0}.geo-google,.geo-osm,.geo-yandex{font-family:serif;font-weight:bold;line-height:1em}.geo-geo-dec .geo-dec,.geo-geo-dms .geo-dms{display:inline}.geo-geo-dec .geo-dms,.geo-geo-dms .geo-dec,.geo-multi-punct{display:none}.geo-lat,.geo-lon{white-space:nowrap} .wp-templatelink{color:#9098a0} .mw-fr-reviewlink,.fr-hist-basic-user,.fr-hist-basic-auto{font-weight:normal;font-size:smaller}.flaggedrevs-pending{background:#ffc}.sitedir-ltr div.flaggedrevs_short{float:none;padding:1px}.sitedir-ltr div.flaggedrevs_short_details{width:95%;display:none}.sitedir-ltr .mw-dismissable-notice-body{margin-right:5em !important; } table.navbox th{background:#ccf;padding-left:1em;padding-right:1em;text-align:right} .navbox{ background:#f9f9f9;border:1px solid #aaa;clear:both;font-size:90%;margin:1em 0em 0em;padding:2px;width:100%;margin:auto}.navbox-inner,.navbox-subgroup{width:100%}.navbox-group,.navbox-title,.navbox-abovebelow{padding:0.25em 1em; line-height:1.5em;text-align:center}th.navbox-group{ white-space:nowrap; text-align:right}.navbox,.navbox-subgroup{background:#fdfdfd; }.navbox-list{line-height:1.8em;border-color:#fdfdfd; }.navbox th,.navbox-title{background:#ccccff; }.navbox-abovebelow,th.navbox-group,.navbox-subgroup .navbox-title{background:#ddddff; }.navbox-subgroup .navbox-group,.navbox-subgroup .navbox-abovebelow{background:#e6e6ff; }.navbox-even{background:#f7f7f7; }.navbox-odd{background:transparent; }table.navbox + table.navbox{ margin-top:-1px; }.navbox .hlist td dl,.navbox .hlist td ol,.navbox .hlist td ul,.navbox td.hlist dl,.navbox td.hlist ol,.navbox td.hlist ul{padding:0.125em 0; }ol + table.navbox,ul + table.navbox{margin-top:0.5em; } .navbar{display:inline;font-size:88%;font-weight:normal}.navbar ul{display:inline;white-space:nowrap}.navbar li{word-spacing:-0.125em}.navbar.mini li span{font-variant:small-caps} .infobox .navbar{font-size:100%}.navbox .navbar{display:block;font-size:100%}.navbox-title .navbar{ float:left; text-align:left; margin-right:0.5em;width:6em} .watchlist-msg{float:right;background:#ffffe0;border:1px solid #fd4;font-size:8pt;padding:0.5em 0.7em;margin-left:1em;line-height:1.4em}#mw-watchlist-form{clear:both} .math-template{white-space:nowrap;font-family:times,serif,palatino linotype,new athena unicode,athena,gentium,code2000;font-size:120%} .mw-ve-editNotice .mbox-image{display:none}
#siteSub{display:inline;font-size:92%;font-weight:normal }body.page-Заглавная_страница #siteSub,body.page-Заглавная_страница #contentSub,body.page-Заглавная_страница h1.firstHeading{display:none !important} .topicon{position:absolute;top:-2em;right:0}#coordinates{position:absolute;top:0;right:9em;font-size:11px;white-space:nowrap} .floating_object{position:absolute;right:0px !important;top:-31px !important;z-index:100;overflow:hidden}body.ns-0 .floating_object{top:-20px !important } div.vectorMenu div{z-index:2 }
.mw-collapsible-toggle{float:right;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}  .mw-content-ltr .mw-collapsible-toggle,.mw-content-rtl .mw-content-ltr .mw-collapsible-toggle{float:right} .mw-content-rtl .mw-collapsible-toggle,.mw-content-ltr .mw-content-rtl .mw-collapsible-toggle{float:left}.mw-customtoggle,.mw-collapsible-toggle{cursor:pointer} caption .mw-collapsible-toggle,.mw-content-ltr caption .mw-collapsible-toggle,.mw-content-rtl caption .mw-collapsible-toggle,.mw-content-rtl .mw-content-ltr caption .mw-collapsible-toggle,.mw-content-ltr .mw-content-rtl caption .mw-collapsible-toggle{float:none} li .mw-collapsible-toggle,.mw-content-ltr li .mw-collapsible-toggle,.mw-content-rtl li .mw-collapsible-toggle,.mw-content-rtl .mw-content-ltr li .mw-collapsible-toggle,.mw-content-ltr .mw-content-rtl li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}
.suggestions{overflow:hidden;position:absolute;top:0;left:0;width:0;border:none;z-index:1099;padding:0;margin:-1px 0 0 0}.suggestions-special{position:relative;background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0;margin-top:-2px;display:none;padding:0.25em 0.25em;line-height:1.25em}.suggestions-results{background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0}.suggestions-result{color:black;margin:0;line-height:1.5em;padding:0.01em 0.25em;text-align:left; overflow:hidden;-o-text-overflow:ellipsis; text-overflow:ellipsis;white-space:nowrap}.suggestions-result-current{background-color:#4C59A6;color:white}.suggestions-special .special-label{color:gray;text-align:left}.suggestions-special .special-query{color:black;font-style:italic;text-align:left}.suggestions-special .special-hover{background-color:silver}.suggestions-result-current .special-label,.suggestions-result-current .special-query{color:white}.highlight{font-weight:bold}
.mw-ui-button{font-family:inherit;font-size:1em;display:inline-block;min-width:4em;max-width:28.75em;padding:.5em 1em;margin:0;border-radius:2px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;*display:inline;zoom:1;vertical-align:middle;background:#ffffff;color:#555555;border:1px solid #cccccc;text-align:center;font-weight:bold;cursor:pointer}.mw-ui-button:hover{background-color:#cccccc}.mw-ui-button:focus{border-color:#ffffff;box-shadow:0 0 0 1px #cccccc;outline:none}.mw-ui-button:focus::-moz-focus-inner{border-color:transparent}.mw-ui-button:active,.mw-ui-button.is-on,.mw-ui-button.mw-ui-checked{background:#777777;box-shadow:none}.mw-ui-button:hover,.mw-ui-button:active,.mw-ui-button:visited{color:#555555}.mw-ui-button:focus{background-color:#cccccc}.mw-ui-button:disabled{color:#cccccc}.mw-ui-button:disabled:hover,.mw-ui-button:disabled:active{background:#ffffff;box-shadow:none}.mw-ui-button:disabled{text-shadow:none;cursor:default}.mw-ui-button.mw-ui-big{font-size:1.3em}.mw-ui-button.mw-ui-block{display:block;width:100%;margin-left:auto;margin-right:auto}.mw-ui-button.mw-ui-progressive,.mw-ui-button.mw-ui-primary{background:#347bff;color:#fff;border:1px solid #347bff;text-shadow:0 1px rgba(0,0,0,0.1)}.mw-ui-button.mw-ui-progressive:hover,.mw-ui-button.mw-ui-primary:hover{background-color:#2962cc}.mw-ui-button.mw-ui-progressive:focus,.mw-ui-button.mw-ui-primary:focus{border-color:#ffffff;box-shadow:0 0 0 1px #2962cc;outline:none}.mw-ui-button.mw-ui-progressive:focus::-moz-focus-inner,.mw-ui-button.mw-ui-primary:focus::-moz-focus-inner{border-color:transparent}.mw-ui-button.mw-ui-progressive:active,.mw-ui-button.mw-ui-primary:active,.mw-ui-button.mw-ui-progressive.is-on,.mw-ui-button.mw-ui-primary.is-on,.mw-ui-button.mw-ui-progressive.mw-ui-checked,.mw-ui-button.mw-ui-primary.mw-ui-checked{background:#2962cc;box-shadow:none}.mw-ui-button.mw-ui-progressive:disabled,.mw-ui-button.mw-ui-primary:disabled{background:#dddddd;border-color:#dddddd}.mw-ui-button.mw-ui-progressive:disabled:hover,.mw-ui-button.mw-ui-primary:disabled:hover,.mw-ui-button.mw-ui-progressive:disabled:active,.mw-ui-button.mw-ui-primary:disabled:active,.mw-ui-button.mw-ui-progressive:disabled.mw-ui-checked,.mw-ui-button.mw-ui-primary:disabled.mw-ui-checked{box-shadow:none}.mw-ui-button.mw-ui-progressive.mw-ui-quiet,.mw-ui-button.mw-ui-primary.mw-ui-quiet{color:#555555}.mw-ui-button.mw-ui-progressive.mw-ui-quiet:hover,.mw-ui-button.mw-ui-primary.mw-ui-quiet:hover,.mw-ui-button.mw-ui-progressive.mw-ui-quiet:focus,.mw-ui-button.mw-ui-primary.mw-ui-quiet:focus{background:transparent;color:#347bff}.mw-ui-button.mw-ui-progressive.mw-ui-quiet:active,.mw-ui-button.mw-ui-primary.mw-ui-quiet:active,.mw-ui-button.mw-ui-progressive.mw-ui-quiet.mw-ui-checked,.mw-ui-button.mw-ui-primary.mw-ui-quiet.mw-ui-checked{color:#2962cc}.mw-ui-button.mw-ui-progressive.mw-ui-quiet:disabled,.mw-ui-button.mw-ui-primary.mw-ui-quiet:disabled{color:#cccccc}.mw-ui-button.mw-ui-constructive{background:#347bff;color:#fff;border:1px solid #347bff;text-shadow:0 1px rgba(0,0,0,0.1)}.mw-ui-button.mw-ui-constructive:hover{background-color:#2962cc}.mw-ui-button.mw-ui-constructive:focus{border-color:#ffffff;box-shadow:0 0 0 1px #2962cc;outline:none}.mw-ui-button.mw-ui-constructive:focus::-moz-focus-inner{border-color:transparent}.mw-ui-button.mw-ui-constructive:active,.mw-ui-button.mw-ui-constructive.is-on,.mw-ui-button.mw-ui-constructive.mw-ui-checked{background:#2962cc;box-shadow:none}.mw-ui-button.mw-ui-constructive:disabled{background:#dddddd;border-color:#dddddd}.mw-ui-button.mw-ui-constructive:disabled:hover,.mw-ui-button.mw-ui-constructive:disabled:active,.mw-ui-button.mw-ui-constructive:disabled.mw-ui-checked{box-shadow:none}.mw-ui-button.mw-ui-constructive.mw-ui-quiet{color:#555555}.mw-ui-button.mw-ui-constructive.mw-ui-quiet:hover,.mw-ui-button.mw-ui-constructive.mw-ui-quiet:focus{background:transparent;color:#347bff}.mw-ui-button.mw-ui-constructive.mw-ui-quiet:active,.mw-ui-button.mw-ui-constructive.mw-ui-quiet.mw-ui-checked{color:#2962cc}.mw-ui-button.mw-ui-constructive.mw-ui-quiet:disabled{color:#cccccc}.mw-ui-button.mw-ui-destructive{background:#d11d13;color:#fff;border:1px solid #d11d13;text-shadow:0 1px rgba(0,0,0,0.1)}.mw-ui-button.mw-ui-destructive:hover{background-color:#a7170f}.mw-ui-button.mw-ui-destructive:focus{border-color:#ffffff;box-shadow:0 0 0 1px #a7170f;outline:none}.mw-ui-button.mw-ui-destructive:focus::-moz-focus-inner{border-color:transparent}.mw-ui-button.mw-ui-destructive:active,.mw-ui-button.mw-ui-destructive.is-on,.mw-ui-button.mw-ui-destructive.mw-ui-checked{background:#a7170f;box-shadow:none}.mw-ui-button.mw-ui-destructive:disabled{background:#dddddd;border-color:#dddddd}.mw-ui-button.mw-ui-destructive:disabled:hover,.mw-ui-button.mw-ui-destructive:disabled:active,.mw-ui-button.mw-ui-destructive:disabled.mw-ui-checked{box-shadow:none}.mw-ui-button.mw-ui-destructive.mw-ui-quiet{color:#555555}.mw-ui-button.mw-ui-destructive.mw-ui-quiet:hover,.mw-ui-button.mw-ui-destructive.mw-ui-quiet:focus{background:transparent;color:#d11d13}.mw-ui-button.mw-ui-destructive.mw-ui-quiet:active,.mw-ui-button.mw-ui-destructive.mw-ui-quiet.mw-ui-checked{color:#a7170f}.mw-ui-button.mw-ui-destructive.mw-ui-quiet:disabled{color:#cccccc}.mw-ui-button.mw-ui-quiet{background:transparent;border:0;text-shadow:none;color:#555555}.mw-ui-button.mw-ui-quiet:hover,.mw-ui-button.mw-ui-quiet:focus{background:transparent;color:#555555}.mw-ui-button.mw-ui-quiet:active,.mw-ui-button.mw-ui-quiet.mw-ui-checked{color:#777777}.mw-ui-button.mw-ui-quiet:disabled{color:#cccccc}.mw-ui-button.mw-ui-quiet:hover,.mw-ui-button.mw-ui-quiet:focus{box-shadow:none}.mw-ui-button.mw-ui-quiet:active,.mw-ui-button.mw-ui-quiet:disabled{background:transparent}a.mw-ui-button{text-decoration:none;line-height:normal}a.mw-ui-button:hover,a.mw-ui-button:focus{text-decoration:none}.mw-ui-button-group > *{min-width:48px;border-radius:0;float:left}.mw-ui-button-group > *:first-child{border-top-left-radius:2px;border-bottom-left-radius:2px}.mw-ui-button-group > *:not( :first-child ){border-left:0}.mw-ui-button-group > *:last-child{border-top-right-radius:2px;border-bottom-right-radius:2px}.mw-ui-button-group .is-on .button{cursor:default}
.mw-ui-icon{position:relative;min-height:1.5em;min-width:1.5em}.mw-ui-icon.mw-ui-icon-element{text-indent:-999px;overflow:hidden;width:3.5em;min-width:3.5em;max-width:3.5em}.mw-ui-icon.mw-ui-icon-element:before{left:0;right:0;position:absolute;margin:0 1em}.mw-ui-icon.mw-ui-icon-before:before,.mw-ui-icon.mw-ui-icon-element:before{background-position:50% 50%;background-repeat:no-repeat;background-size:100% auto;float:left;display:block;min-height:1.5em;content:''}.mw-ui-icon.mw-ui-icon-before:before{position:relative;width:1.5em;margin-right:1em}
#p-lang .uls-settings-trigger{background:transparent no-repeat right top;background-image:url(/w/extensions/UniversalLanguageSelector/resources/images/cog-sprite.png?fae8e);background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20width%3D%2214%22%20height%3D%2232%22%3E%3Cdefs%3E%3Cpath%20d%3D%22M14%209.3V6.73l-1.575-.264c-.117-.44-.292-.848-.496-1.2l.93-1.285-1.81-1.84-1.31.908c-.38-.205-.79-.38-1.196-.497L8.284%201H5.716l-.263%201.578c-.437.117-.816.293-1.196.497L2.975%202.17%201.137%203.98l.934%201.287c-.2.38-.376.79-.493%201.228L0%206.73V9.3l1.575.264c.117.438.292.818.496%201.198l-.93%201.315L2.95%2013.89l1.312-.938c.38.205.787.38%201.224.497L5.746%2015h2.566l.263-1.578c.408-.117.817-.293%201.196-.497l1.315.935%201.81-1.812-.935-1.315c.203-.38.38-.76.495-1.2L14%209.303zm-7%201.404c-1.488%200-2.683-1.2-2.683-2.69S5.542%205.327%207%205.327c1.458%200%202.683%201.198%202.683%202.69%200%201.49-1.195%202.688-2.683%202.688z%22%20id%3D%22a%22%2F%3E%3C%2Fdefs%3E%3Cuse%20xlink%3Ahref%3D%22%23a%22%20fill%3D%22%23808080%22%2F%3E%3Cuse%20transform%3D%22translate%280%2016%29%22%20xlink%3Ahref%3D%22%23a%22%20fill%3D%22%23555%22%2F%3E%3C%2Fsvg%3E%0A);background-image:linear-gradient(transparent,transparent),url(/w/extensions/UniversalLanguageSelector/resources/images/cog-sprite.svg?624e4)!ie;background-image:-o-linear-gradient(transparent,transparent),url(/w/extensions/UniversalLanguageSelector/resources/images/cog-sprite.png?fae8e);height:16px;width:14px;float:right;cursor:pointer}.skin-vector #p-lang .uls-settings-trigger{ margin-top:3px}#p-lang .uls-settings-trigger:hover{background-position:right -16px}</style><style>
.suggestions a.mw-searchSuggest-link,.suggestions a.mw-searchSuggest-link:hover,.suggestions a.mw-searchSuggest-link:active,.suggestions a.mw-searchSuggest-link:focus{color:black;text-decoration:none}.suggestions-result-current a.mw-searchSuggest-link,.suggestions-result-current a.mw-searchSuggest-link:hover,.suggestions-result-current a.mw-searchSuggest-link:active,.suggestions-result-current a.mw-searchSuggest-link:focus{color:white}.suggestions a.mw-searchSuggest-link .special-query{ overflow:hidden;-o-text-overflow:ellipsis; text-overflow:ellipsis;white-space:nowrap}
.mw-mmv-overlay{position:fixed;top:0px;left:0px;right:0px;bottom:0px;z-index:1000;background-color:#000000}body.mw-mmv-lightbox-open{overflow-y:auto}body.mw-mmv-lightbox-open #mw-page-base,body.mw-mmv-lightbox-open #mw-head-base,body.mw-mmv-lightbox-open #mw-navigation,body.mw-mmv-lightbox-open #content,body.mw-mmv-lightbox-open #footer,body.mw-mmv-lightbox-open #globalWrapper{ display:none}body.mw-mmv-lightbox-open > *{ display:none}body.mw-mmv-lightbox-open > .mw-mmv-overlay,body.mw-mmv-lightbox-open > .mw-mmv-wrapper{display:block}.mw-mmv-filepage-buttons{margin-top:5px}.mw-mmv-filepage-buttons .mw-mmv-view-expanded,.mw-mmv-filepage-buttons .mw-mmv-view-config{display:block;line-height:inherit}.mw-mmv-filepage-buttons .mw-mmv-view-expanded.mw-ui-icon:before{background-image:url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%0A%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%201024%20768%22%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23777%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M851.2%2071.6L690.7%20232.1l-40.1-40.3-9.6%20164.8%20164.8-9.3-40.3-40.4L926%20146.4l58.5%2058.5L997.6%200%20792.7%2013.1%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M769.6%2089.3H611.9l70.9%2070.8%207.9%207.5m-47.1%20234.6l-51.2%203%203-51.2%209.4-164.4%205.8-100.3H26.4V768h883.1V387l-100.9%205.8-165%209.4zM813.9%20678H113.6l207.2-270.2%2031.5-12.9L548%20599.8l105.9-63.2%20159.8%20140.8.2.6zm95.6-291.9V228l-79.1%2078.9%207.8%207.9%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E%0A);background-image:url(/w/extensions/MultimediaViewer/resources/mmv/img/expand.svg?b714e)!ie}.mw-mmv-filepage-buttons .mw-mmv-view-config.mw-ui-icon:before{background-image:url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%0A%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%201024%20768%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M897%20454.6V313.4L810.4%20299c-6.4-23.3-16-45.7-27.3-65.8l50.5-71.4-99.4-100.2-71.4%2050.5c-20.9-11.2-42.5-20.9-65.8-27.3L582.6-1H441.4L427%2085.6c-23.3%206.4-45.7%2016-65.8%2027.3l-71.4-50.5-100.3%2099.5%2050.5%2071.4c-11.2%2020.9-20.9%2042.5-27.3%2066.6L127%20313.4v141.2l85.8%2014.4c6.4%2023.3%2016%2045.7%2027.3%2066.6L189.6%20607l99.5%2099.5%2071.4-50.5c20.9%2011.2%2042.5%2020.9%2066.6%2027.3l14.4%2085.8h141.2l14.4-86.6c23.3-6.4%2045.7-16%2065.8-27.3l71.4%2050.5%2099.5-99.5-50.5-71.4c11.2-20.9%2020.9-42.5%2027.3-66.6l86.4-13.6zm-385%2077c-81.8%200-147.6-66.6-147.6-147.6%200-81.8%2066.6-147.6%20147.6-147.6S659.6%20302.2%20659.6%20384%20593.8%20531.6%20512%20531.6z%22%20fill%3D%22%23777%22%2F%3E%0A%3C%2Fsvg%3E%0A);background-image:url(/w/extensions/MultimediaViewer/resources/mmv/img/gear_gray.svg?330ae)!ie;opacity:0.75}.mw-mmv-filepage-buttons .mw-mmv-view-config.mw-ui-icon:before:hover{opacity:1}</style><meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="./Ассемблер в Linux для программистов C — Викиучебник_files/load(1).php">
<script async="" src="./Ассемблер в Linux для программистов C — Викиучебник_files/load(2).php"></script>
<meta name="generator" content="MediaWiki 1.27.0-wmf.18">
<meta name="referrer" content="origin-when-cross-origin">
<link rel="alternate" type="application/x-wiki" title="Править" href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit">
<link rel="edit" title="Править" href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit">
<link rel="shortcut icon" href="https://ru.wikibooks.org/static/favicon/wikibooks.ico">
<link rel="search" type="application/opensearchdescription+xml" href="https://ru.wikibooks.org/w/opensearch_desc.php" title="Викиучебник (ru)">
<link rel="EditURI" type="application/rsd+xml" href="https://ru.wikibooks.org/w/api.php?action=rsd">
<link rel="copyright" href="https://creativecommons.org/licenses/by-sa/3.0/">
<link rel="alternate" type="application/atom+xml" title="Викиучебник — Atom-лента" href="https://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8&amp;feed=atom">
<link rel="canonical" href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C">
<link rel="dns-prefetch" href="https://meta.wikimedia.org/">
<script src="./Ассемблер в Linux для программистов C — Викиучебник_files/load(3).php"></script><style>#mw-fr-revisiontag { display:none }</style><script src="./Ассемблер в Linux для программистов C — Викиучебник_files/index.php"></script><style>body *:not(.infobox) .navbox a.mw-redirect, body *:not(.infobox) .NavFrame a.mw-redirect { color:#338800}</style><style>body *:not(.infobox) .navbox a.mw-redirect:visited, body *:not(.infobox) .NavFrame a.mw-redirect:visited { color:#338899}</style></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Ассемблер_в_Linux_для_программистов_C skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

							<div id="siteNotice"><div id="centralNotice"></div><!-- CentralNotice --></div>
						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="ru">Ассемблер в Linux для программистов C</h1>
									<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">Материал из Викиучебника&nbsp;— открытых книг для открытого мира</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Перейти к:					<a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#mw-head">навигация</a>, 					<a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#p-search">поиск</a>
				</div>
				<div id="mw-content-text" lang="ru" dir="ltr" class="mw-content-ltr"><p></p>
<div id="toc" class="toc">
<div id="toctitle">
<h2>Содержание</h2>
<span class="toctoggle">&nbsp;[<a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#" id="togglelink">убрать</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.92.D0.B2.D0.B5.D0.B4.D0.B5.D0.BD.D0.B8.D0.B5"><span class="tocnumber">1</span> <span class="toctext">Введение</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.90_.D1.81.D1.82.D0.BE.D0.B8.D1.82_.D0.BB.D0.B8.3F"><span class="tocnumber">1.1</span> <span class="toctext">А стоит ли?</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.B0.D0.BA_.D0.BF.D1.80.D0.B0.D0.B2.D0.B8.D1.82.D1.8C_.D1.8D.D1.82.D0.BE.D1.82_.D0.B2.D0.B8.D0.BA.D0.B8.D1.83.D1.87.D0.B5.D0.B1.D0.BD.D0.B8.D0.BA"><span class="tocnumber">1.2</span> <span class="toctext">Как править этот викиучебник</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.90.D1.80.D1.85.D0.B8.D1.82.D0.B5.D0.BA.D1.82.D1.83.D1.80.D0.B0"><span class="tocnumber">2</span> <span class="toctext">Архитектура</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#x86_.D0.B8.D0.BB.D0.B8_IA-32.3F"><span class="tocnumber">2.1</span> <span class="toctext">x86 или IA-32?</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.A0.D0.B5.D0.B3.D0.B8.D1.81.D1.82.D1.80.D1.8B"><span class="tocnumber">2.2</span> <span class="toctext">Регистры</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.A1.D1.82.D0.B5.D0.BA"><span class="tocnumber">2.3</span> <span class="toctext">Стек</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D0.B0.D0.BC.D1.8F.D1.82.D1.8C"><span class="tocnumber">2.4</span> <span class="toctext">Память</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D0.BE.D1.80.D1.8F.D0.B4.D0.BE.D0.BA_.D0.B1.D0.B0.D0.B9.D1.82.D0.BE.D0.B2._Little-endian_.D0.B8_big-endian"><span class="tocnumber">2.5</span> <span class="toctext">Порядок байтов. Little-endian и big-endian</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.A1.D0.BC._.D1.82.D0.B0.D0.BA.D0.B6.D0.B5"><span class="tocnumber">2.5.1</span> <span class="toctext">См. также</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#Hello.2C_world.21"><span class="tocnumber">3</span> <span class="toctext">Hello, world!</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.A1.D0.B8.D0.BD.D1.82.D0.B0.D0.BA.D1.81.D0.B8.D1.81_.D0.B0.D1.81.D1.81.D0.B5.D0.BC.D0.B1.D0.BB.D0.B5.D1.80.D0.B0"><span class="tocnumber">4</span> <span class="toctext">Синтаксис ассемблера</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D1.8B"><span class="tocnumber">4.1</span> <span class="toctext">Команды</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.94.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5"><span class="tocnumber">4.2</span> <span class="toctext">Данные</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9C.D0.B5.D1.82.D0.BA.D0.B8_.D0.B8_.D0.BF.D1.80.D0.BE.D1.87.D0.B8.D0.B5_.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D1.8B"><span class="tocnumber">4.3</span> <span class="toctext">Метки и прочие символы</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9D.D0.B5.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5"><span class="tocnumber">4.4</span> <span class="toctext">Неинициализированные данные</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-17"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9C.D0.B5.D1.82.D0.BE.D0.B4.D1.8B_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D0.B8"><span class="tocnumber">5</span> <span class="toctext">Методы адресации</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D1.80.D1.8F.D0.BC.D0.B0.D1.8F_.D0.B8.D0.BB.D0.B8_.D0.B0.D0.B1.D1.81.D0.BE.D0.BB.D1.8E.D1.82.D0.BD.D0.B0.D1.8F_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">5.1</span> <span class="toctext">Прямая или абсолютная адресация</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9D.D0.B5.D0.BF.D0.BE.D1.81.D1.80.D0.B5.D0.B4.D1.81.D1.82.D0.B2.D0.B5.D0.BD.D0.BD.D0.B0.D1.8F_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">5.2</span> <span class="toctext">Непосредственная адресация</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.BE.D1.81.D0.B2.D0.B5.D0.BD.D0.BD.D0.B0.D1.8F_.28.D0.B1.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D1.8F.29_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">5.3</span> <span class="toctext">Косвенная (базовая) адресация</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.90.D0.B2.D1.82.D0.BE.D0.B8.D0.BD.D0.BA.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.BD.D0.B0.D1.8F_.D0.B8_.D0.B0.D0.B2.D1.82.D0.BE.D0.B4.D0.B5.D0.BA.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.BD.D0.B0.D1.8F_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">5.4</span> <span class="toctext">Автоинкрементная и автодекрементная адресация</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.A0.D0.B5.D0.B3.D0.B8.D1.81.D1.82.D1.80.D0.BE.D0.B2.D0.B0.D1.8F_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">5.5</span> <span class="toctext">Регистровая адресация</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9E.D1.82.D0.BD.D0.BE.D1.81.D0.B8.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">5.6</span> <span class="toctext">Относительная адресация</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D1.8B_.D0.B0.D1.81.D1.81.D0.B5.D0.BC.D0.B1.D0.BB.D0.B5.D1.80.D0.B0"><span class="tocnumber">6</span> <span class="toctext">Команды ассемблера</span></a>
<ul>
<li class="toclevel-2 tocsection-25"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.B0_mov"><span class="tocnumber">6.1</span> <span class="toctext">Команда mov</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.B0_lea"><span class="tocnumber">6.2</span> <span class="toctext">Команда lea</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D1.8B_.D0.B4.D0.BB.D1.8F_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D1.8B_.D1.81.D0.BE_.D1.81.D1.82.D0.B5.D0.BA.D0.BE.D0.BC"><span class="tocnumber">6.3</span> <span class="toctext">Команды для работы со стеком</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.90.D1.80.D0.B8.D1.84.D0.BC.D0.B5.D1.82.D0.B8.D0.BA.D0.B0"><span class="tocnumber">6.4</span> <span class="toctext">Арифметика</span></a>
<ul>
<li class="toclevel-3 tocsection-29"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.B0_lea_.D0.B4.D0.BB.D1.8F_.D0.B0.D1.80.D0.B8.D1.84.D0.BC.D0.B5.D1.82.D0.B8.D0.BA.D0.B8"><span class="tocnumber">6.4.1</span> <span class="toctext">Команда lea для арифметики</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-30"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.B0_loop"><span class="tocnumber">6.5</span> <span class="toctext">Команда loop</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D1.8B_.D1.81.D1.80.D0.B0.D0.B2.D0.BD.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B8_.D1.83.D1.81.D0.BB.D0.BE.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BF.D0.B5.D1.80.D0.B5.D1.85.D0.BE.D0.B4.D1.8B._.D0.91.D0.B5.D0.B7.D1.83.D1.81.D0.BB.D0.BE.D0.B2.D0.BD.D1.8B.D0.B9_.D0.BF.D0.B5.D1.80.D0.B5.D1.85.D0.BE.D0.B4"><span class="tocnumber">6.6</span> <span class="toctext">Команды сравнения и условные переходы. Безусловный переход</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D1.80.D0.BE.D0.B8.D0.B7.D0.B2.D0.BE.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D1.86.D0.B8.D0.BA.D0.BB.D1.8B"><span class="tocnumber">6.7</span> <span class="toctext">Произвольные циклы</span></a>
<ul>
<li class="toclevel-3 tocsection-33"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0:_.D0.BF.D0.BE.D0.B8.D1.81.D0.BA_.D0.BD.D0.B0.D0.B8.D0.B1.D0.BE.D0.BB.D1.8C.D1.88.D0.B5.D0.B3.D0.BE_.D1.8D.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.B0_.D0.B2_.D0.BC.D0.B0.D1.81.D1.81.D0.B8.D0.B2.D0.B5"><span class="tocnumber">6.7.1</span> <span class="toctext">Программа: поиск наибольшего элемента в массиве</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-34"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9B.D0.BE.D0.B3.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B0.D1.8F_.D0.B0.D1.80.D0.B8.D1.84.D0.BC.D0.B5.D1.82.D0.B8.D0.BA.D0.B0"><span class="tocnumber">6.8</span> <span class="toctext">Логическая арифметика</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D0.BE.D0.B4.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D1.8B"><span class="tocnumber">6.9</span> <span class="toctext">Подпрограммы</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0:_.D0.BF.D0.B5.D1.87.D0.B0.D1.82.D1.8C_.D1.82.D0.B0.D0.B1.D0.BB.D0.B8.D1.86.D1.8B_.D1.83.D0.BC.D0.BD.D0.BE.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F"><span class="tocnumber">6.10</span> <span class="toctext">Программа: печать таблицы умножения</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0:_.D0.B2.D1.8B.D1.87.D0.B8.D1.81.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.84.D0.B0.D0.BA.D1.82.D0.BE.D1.80.D0.B8.D0.B0.D0.BB.D0.B0"><span class="tocnumber">6.11</span> <span class="toctext">Программа: вычисление факториала</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.A1.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.BD.D1.8B.D0.B5_.D0.B2.D1.8B.D0.B7.D0.BE.D0.B2.D1.8B"><span class="tocnumber">6.12</span> <span class="toctext">Системные вызовы</span></a></li>
<li class="toclevel-2 tocsection-39"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.A1.D1.82.D1.80.D1.83.D0.BA.D1.82.D1.83.D1.80.D1.8B"><span class="tocnumber">6.13</span> <span class="toctext">Структуры</span></a>
<ul>
<li class="toclevel-3 tocsection-40"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0:_.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4_.D1.80.D0.B0.D0.B7.D0.BC.D0.B5.D1.80.D0.B0_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0"><span class="tocnumber">6.13.1</span> <span class="toctext">Программа: вывод размера файла</span></a></li>
<li class="toclevel-3 tocsection-41"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0:_.D0.BF.D0.B5.D1.87.D0.B0.D1.82.D1.8C_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0_.D0.BD.D0.B0.D0.BE.D0.B1.D0.BE.D1.80.D0.BE.D1.82"><span class="tocnumber">6.13.2</span> <span class="toctext">Программа: печать файла наоборот</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-42"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9E.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.D1.81_.D1.86.D0.B5.D0.BF.D0.BE.D1.87.D0.BA.D0.B0.D0.BC.D0.B8_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85"><span class="tocnumber">6.14</span> <span class="toctext">Операции с цепочками данных</span></a>
<ul>
<li class="toclevel-3 tocsection-43"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_memcpy"><span class="tocnumber">6.14.1</span> <span class="toctext">Пример: memcpy</span></a></li>
<li class="toclevel-3 tocsection-44"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_strlen"><span class="tocnumber">6.14.2</span> <span class="toctext">Пример: strlen</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-45"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9A.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.86.D0.B8.D1.8F_switch"><span class="tocnumber">6.15</span> <span class="toctext">Конструкция switch</span></a>
<ul>
<li class="toclevel-3 tocsection-46"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D0.BF.D1.80.D0.B5.D1.82.D0.B0.D1.82.D0.BE.D1.80_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0_Brainfuck"><span class="tocnumber">6.15.1</span> <span class="toctext">Пример: интерпретатор языка Brainfuck</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-47"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.91.D1.83.D0.BB.D0.B5.D0.B2.D1.8B_.D0.B2.D1.8B.D1.80.D0.B0.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F"><span class="tocnumber">6.16</span> <span class="toctext">Булевы выражения</span></a>
<ul>
<li class="toclevel-3 tocsection-48"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.A1.D0.BC._.D1.82.D0.B0.D0.BA.D0.B6.D0.B5_2"><span class="tocnumber">6.16.1</span> <span class="toctext">См. также</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-49"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.9E.D1.82.D0.BB.D0.B0.D0.B4.D1.87.D0.B8.D0.BA_GDB"><span class="tocnumber">7</span> <span class="toctext">Отладчик GDB</span></a></li>
<li class="toclevel-1 tocsection-50"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#.D0.A1.D1.81.D1.8B.D0.BB.D0.BA.D0.B8"><span class="tocnumber">8</span> <span class="toctext">Ссылки</span></a></li>
</ul>
</div>
<p></p>
<h2><span class="mw-headline" id=".D0.92.D0.B2.D0.B5.D0.B4.D0.B5.D0.BD.D0.B8.D0.B5">Введение</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=1" title="Редактировать раздел «Введение»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="epigraf">
<blockquote>
<p>Premature optimization is the root of all evil.</p>
</blockquote>
<p class="podpis" style="text-align:right;font-style:normal">Donald Knuth</p>
</div>
<p>Эта книга ориентирована на программистов, которые уже знают <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" class="extiw" title="w:Си (язык программирования)">Си</a> на достаточном уровне. Почему так? Вряд ли, зная только несколько интерпретируемых языков вроде <a href="https://ru.wikipedia.org/wiki/Perl" class="extiw" title="w:Perl">Perl</a> или <a href="https://ru.wikipedia.org/wiki/Python" class="extiw" title="w:Python">Python</a>, кто-то захочет сразу изучать <a href="https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80%D0%B0" class="extiw" title="w:Язык ассемблера">ассемблер</a>. Используя Си и ассемблер вместе, применяя каждый язык для определённых целей, можно добиться очень хороших результатов. К тому же программисты Си уже имеют некоторые знания об архитектуре <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80" class="extiw" title="w:Процессор">процессора</a>, особенностях машинных вычислений, способе организации памяти и других вещах, которые новичку в программировании понять не так просто. Поэтому изучать ассемблер после Си несомненно легче, чем после других языков высокого уровня. В Си есть понятие «указатель», программист должен сам управлять выделением памяти в <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_(%D0%BD%D0%B5%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C)" class="extiw" title="w:Куча (нераспределённая память)">куче</a>, и так далее — все эти знания пригодятся при изучении ассемблера, они помогут получить более целостную картину об архитектуре, а также иметь более полное представление о том, как выполняются их программы на Си. Но эти знания требуют углубления и структурирования.</p>
<p>Хочу подчеркнуть, что для чтения этой книги никаких знаний о <a href="https://ru.wikipedia.org/wiki/Linux" class="extiw" title="w:Linux">Linux</a> не требуется (кроме, разумеется, знаний о том, «как создать текстовый файл» и «как запустить программу в консоли»). Да и вообще, единственное, в чём выражается ориентированность на Linux, — это используемые синтаксис ассемблера и <a href="https://ru.wikipedia.org/wiki/ABI" class="extiw" title="w:ABI">ABI</a>. Программисты на ассемблере в <a href="https://ru.wikipedia.org/wiki/DOS" class="extiw" title="w:DOS">DOS</a> и <a href="https://ru.wikipedia.org/wiki/Microsoft_Windows" class="extiw" title="w:Microsoft Windows">Windows</a> используют синтаксис Intel, но в системах <a href="https://ru.wikipedia.org/wiki/Unix-%D0%BF%D0%BE%D0%B4%D0%BE%D0%B1%D0%BD%D0%B0%D1%8F_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0" class="extiw" title="w:Unix-подобная операционная система">*nix</a> принято использовать синтаксис AT&amp;T. Именно синтаксисом AT&amp;T написаны ассемблерные части ядра Linux, в синтаксисе AT&amp;T компилятор <a href="https://ru.wikipedia.org/wiki/GNU_Compiler_Collection" class="extiw" title="w:GNU Compiler Collection">GCC</a> выводит ассемблерные листинги и так далее.</p>
<p>Большую часть информации из этой книги можно использовать для программирования не только в *nix, но и в Windows, нужно только уточнить некоторые системно-зависимые особенности (например, ABI).</p>
<h3><span class="mw-headline" id=".D0.90_.D1.81.D1.82.D0.BE.D0.B8.D1.82_.D0.BB.D0.B8.3F">А стоит ли?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=2" title="Редактировать раздел «А стоит ли?»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>При написании кода на ассемблере всегда следует отдавать себе отчёт в том, действительно ли данный кусок кода должен быть написан на ассемблере. Нужно взвесить все «за» и «против», современные компиляторы умеют оптимизировать код, и могут добиться сравнимой производительности (в том числе большей, если ассемблерная версия написанная программистом изначально неоптимальна).</p>
<p>Самый главный недостаток языка ассемблера&nbsp;— будущая непереносимость полученной программы на другие платформы.</p>
<h3><span class="mw-headline" id=".D0.9A.D0.B0.D0.BA_.D0.BF.D1.80.D0.B0.D0.B2.D0.B8.D1.82.D1.8C_.D1.8D.D1.82.D0.BE.D1.82_.D0.B2.D0.B8.D0.BA.D0.B8.D1.83.D1.87.D0.B5.D0.B1.D0.BD.D0.B8.D0.BA">Как править этот викиучебник</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=3" title="Редактировать раздел «Как править этот викиучебник»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Так как изначально этот учебник писался не в вики-формате, автор допускал повествование от первого лица. В вики такое не приветствуется, поэтому такие обороты нужно вычистить.</p>
<p>При внесении первых правок насчёт архитектуры x86_64 (сейчас эта тема не освещена вообще) нужно разграничить и чётко отметить все архитектурно-зависимые абзацы: что относится к IA-32, а что к x86_64, так как ABI (application binary interface) i386 и x86_64 отличаются.</p>
<h2><span class="mw-headline" id=".D0.90.D1.80.D1.85.D0.B8.D1.82.D0.B5.D0.BA.D1.82.D1.83.D1.80.D0.B0">Архитектура</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=4" title="Редактировать раздел «Архитектура»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="x86_.D0.B8.D0.BB.D0.B8_IA-32.3F">x86 или IA-32?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=5" title="Редактировать раздел «x86 или IA-32?»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Вы, вероятно, уже слышали такое понятие, как «архитектура <a href="https://ru.wikipedia.org/wiki/x86" class="extiw" title="w:x86">x86</a>». Вообще оно довольно размыто, и вот почему. Само название x86 или 80x86 происходит от принципа, по которому <a href="https://ru.wikipedia.org/wiki/Intel" class="extiw" title="w:Intel">Intel</a> давала названия своим процессорам:</p>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/Intel_8086" class="extiw" title="w:Intel 8086">Intel 8086</a> — 16 бит;</li>
<li><a href="https://ru.wikipedia.org/wiki/Intel_80186" class="extiw" title="w:Intel 80186">Intel 80186</a> — 16 бит;</li>
<li><a href="https://ru.wikipedia.org/wiki/Intel_80286" class="extiw" title="w:Intel 80286">Intel 80286</a> — 16 бит;</li>
<li><a href="https://ru.wikipedia.org/wiki/Intel_80386" class="extiw" title="w:Intel 80386">Intel 80386</a> — 32 бита;</li>
<li><a href="https://ru.wikipedia.org/wiki/Intel486" class="extiw" title="w:Intel486">Intel 80486</a> — 32 бита.</li>
</ul>
<p>Этот список можно продолжить. Принцип наименования, где каждому поколению процессоров давалось имя, заканчивающееся на 86, создал термин «x86». Но, если посмотреть внимательнее, можно увидеть, что «процессором x86» можно назвать и древний 16-битный 8086, и новый <a href="https://ru.wikipedia.org/wiki/Core_i7" class="extiw" title="w:Core i7">Core i7</a>. Поэтому 32-битные расширения были названы архитектурой IA-32 (сокращение от Intel Architecture, 32-bit). Конечно же, возможность запуска 16-битных программ осталась, и она успешно (и не очень) используется в 32-битных версиях Windows. Мы будем рассматривать только 32-битный режим.</p>
<h3><span class="mw-headline" id=".D0.A0.D0.B5.D0.B3.D0.B8.D1.81.D1.82.D1.80.D1.8B">Регистры</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=6" title="Редактировать раздел «Регистры»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0" class="extiw" title="w:Регистр процессора">Регистр</a> — это небольшой объем очень быстрой памяти, размещённой на процессоре. Он предназначен для хранения результатов промежуточных вычислений, а также некоторой информации для управления работой процессора. Так как регистры размещены непосредственно на процессоре, доступ к данным, хранящимся в них, намного быстрее доступа к данным в <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C" class="extiw" title="w:Оперативная память">оперативной памяти</a>.</p>
<p>Все регистры можно разделить на две группы: пользовательские и системные. Пользовательские регистры используются при написании «обычных» программ. В их число входят <i>основные программные регистры</i> (англ. basic program execution registers; все они перечислены ниже), а также регистры <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%BE%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80" class="extiw" title="w:Математический сопроцессор">математического сопроцессора</a>, регистры <a href="https://ru.wikipedia.org/wiki/MMX" class="extiw" title="w:MMX">MMX</a>, XMM (<a href="https://ru.wikipedia.org/wiki/SSE" class="extiw" title="w:SSE">SSE</a>, <a href="https://ru.wikipedia.org/wiki/SSE2" class="extiw" title="w:SSE2">SSE2</a>, <a href="https://ru.wikipedia.org/wiki/SSE3" class="extiw" title="w:SSE3">SSE3</a>). Системные регистры (регистры управления, регистры управления памятью, регистры отладки, машинно-специфичные регистры MSR и другие) здесь не рассматриваются. Более подробно см. <sup id="cite_ref-1" class="reference"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#cite_note-1">[1]</a></sup>.</p>
<p><b>Регистры общего назначения</b> (РОН, англ. General Purpose Registers, сокращённо GPR). Размер — 32 бита.</p>
<ul>
<li><code>%eax</code>: Accumulator register — аккумулятор, применяется для хранения результатов промежуточных вычислений.</li>
<li><code>%ebx</code>: Base register — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.</li>
<li><code>%ecx</code>: Counter register — счетчик, его неявно используют некоторые команды для организации циклов (см. loop).</li>
<li><code>%edx</code>: Data register — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.</li>
<li><code>%esp</code>: Stack pointer register — указатель стека. Содержит адрес вершины стека.</li>
<li><code>%ebp</code>: Base pointer register — указатель базы кадра стека (англ. stack frame). Предназначен для организации произвольного доступа к данным внутри стека.</li>
<li><code>%esi</code>: Source index register — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.</li>
<li><code>%edi</code>: Destination index register — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.</li>
</ul>
<p>Эти регистры можно использовать «по частям». Например, к младшим 16 битам регистра <code><code>%eax</code></code> можно обратиться как <code>%ax</code>. А <code>%ax</code>, в свою очередь, содержит две однобайтовых половинки, которые могут использоваться как самостоятельные регистры: старший <code>%ah</code> и младший <code>%al</code>. Аналогично можно обращаться к <code>%ebx</code>/<code>%bx</code>/<code>%bh</code>/<code>%bl</code>, <code>%ecx</code>/<code>%cx</code>/<code>%ch</code>/<code>%cl</code>, <code>%edx</code>/<code>%dx</code>/<code>%dh</code>/<code>%dl</code>, <code>%esi</code>/<code>%si</code>, <code>%edi</code>/<code>%di</code>.</p>
<div class="center">
<div class="floatnone"><a href="https://ru.wikibooks.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_%D0%A1%D0%B8._%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D1%8B_%D0%BE%D0%B1%D1%89%D0%B5%D0%B3%D0%BE_%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F.svg" class="image"><img alt="Ассемблер в Linux для программистов Си. Регистры общего назначения.svg" src="./Ассемблер в Linux для программистов C — Викиучебник_files/461px-Ассемблер_в_Linux_для_программистов_Си._Регистры_общего_назначения.svg.png" width="461" height="142" srcset="//upload.wikimedia.org/wikibooks/ru/thumb/7/7d/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_%D0%A1%D0%B8._%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D1%8B_%D0%BE%D0%B1%D1%89%D0%B5%D0%B3%D0%BE_%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F.svg/692px-%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_%D0%A1%D0%B8._%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D1%8B_%D0%BE%D0%B1%D1%89%D0%B5%D0%B3%D0%BE_%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F.svg.png 1.5x, //upload.wikimedia.org/wikibooks/ru/thumb/7/7d/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_%D0%A1%D0%B8._%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D1%8B_%D0%BE%D0%B1%D1%89%D0%B5%D0%B3%D0%BE_%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F.svg/922px-%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_%D0%A1%D0%B8._%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D1%8B_%D0%BE%D0%B1%D1%89%D0%B5%D0%B3%D0%BE_%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F.svg.png 2x" data-file-width="461" data-file-height="142"></a></div>
</div>
<p>Не следует бояться такого жёсткого закрепления назначения использования регистров. Большая их часть может использоваться для хранения совершенно произвольных данных. Единственный случай, когда нужно учитывать, в какой регистр помещать данные — использование неявно обращающихся к регистрам команд. Такое поведение всегда чётко документировано.</p>
<p><b>Сегментные регистры:</b></p>
<ul>
<li><code>%cs</code>: Code segment — описывает текущий сегмент кода.</li>
<li><code>%ds</code>: Data segment — описывает текущий сегмент данных.</li>
<li><code>%ss</code>: Stack segment — описывает текущий сегмент стека.</li>
<li><code>%es</code>: Extra segment — дополнительный сегмент, используется неявно в строковых командах как сегмент-получатель.</li>
<li><code>%fs</code>: F segment — дополнительный сегментный регистр без специального назначения.</li>
<li><code>%gs</code>: G segment — дополнительный сегментный регистр без специального назначения.</li>
</ul>
<p>В ОС Linux используется <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BB%D0%BE%D1%81%D0%BA%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8" class="extiw" title="w:Плоская модель памяти">плоская модель памяти</a> (flat memory model), в которой все сегменты описаны как использующие всё адресное пространство процессора и, как правило, явно не используются, а все адреса представлены в виде 32-битных смещений. В большинстве случаев программисту можно даже и не задумываться об их существовании, однако операционная система предоставляет специальные средства (системный вызов <code>modify_ldt()</code>), позволяющие описывать нестандартные сегменты и работать с ними. Однако такая потребность возникает редко, поэтому тут подробно не рассматривается.</p>
<p><b>Регистр флагов <code>eflags</code> и его младшие 16 бит, регистр <code>flags</code>.</b> Содержит информацию о состоянии выполнения программы, о самом микропроцессоре, а также информацию, управляющую работой некоторых команд. Регистр флагов нужно рассматривать как массив битов, за каждым из которых закреплено определённое значение. Регистр флагов напрямую не доступен пользовательским программам; изменение некоторых битов <code>eflags</code> требует привилегий. Ниже перечислены наиболее важные флаги.</p>
<ul>
<li><code>cf</code>: carry flag, флаг переноса:
<ul>
<li>1 — во время арифметической операции был произведён перенос из старшего бита результата;</li>
<li>0 — переноса не было;</li>
</ul>
</li>
<li><code>zf</code>: zero flag, флаг нуля:
<ul>
<li>1 — результат последней операции нулевой;</li>
<li>0 — результат последней операции ненулевой;</li>
</ul>
</li>
<li><code>of</code>: overflow flag, флаг переполнения:
<ul>
<li>1 — во время арифметической операции произошёл перенос в/из старшего (знакового) бита результата;</li>
<li>0 — переноса не было;</li>
</ul>
</li>
<li><code>df</code>: direction flag, флаг направления. Указывает направление просмотра в строковых операциях:
<ul>
<li>1 — направление «назад», от старших адресов к младшим;</li>
<li>0 — направление «вперёд», от младших адресов к старшим.</li>
</ul>
</li>
</ul>
<p>Есть команды, которые устанавливают флаги согласно результатам своей работы: в основном это команды, которые что-то вычисляют или сравнивают. Есть команды, которые читают флаги и на основании флагов принимают решения. Есть команды, логика выполнения которых зависит от состояния флагов. В общем, через флаги между командами неявно передаётся дополнительная информация, которая не записывается непосредственно в результат вычислений.</p>
<p><b>Указатель команды <code>eip</code> (instruction pointer).</b> Размер — 32 бита. Содержит указатель на следующую команду. Регистр напрямую недоступен, изменяется неявно командами условных и безусловных переходов, вызова и возврата из подпрограмм.</p>
<h3><span class="mw-headline" id=".D0.A1.D1.82.D0.B5.D0.BA">Стек</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=7" title="Редактировать раздел «Стек»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Мы полагаем, что читатель имеет опыт программирования на Си и знаком со структурами данных типа <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA" class="extiw" title="w:Стек">стек</a>. В микропроцессоре стек работает похожим образом: это область памяти, у которой определена вершина (на неё указывает <code>%esp</code>). Поместить новый элемент можно только на вершину стека, при этом новый элемент становится вершиной. Достать из стека можно только верхний элемент, при этом вершиной становится следующий элемент. У вас наверняка была в детстве игрушка-пирамидка, где нужно было разноцветные кольца надевать на общий стержень. Так вот, эта пирамидка — отличный пример стека. Также можно провести аналогию с составленными стопкой тарелками. На разных архитектурах стек может "расти" как в сторону младших адресов (принцип описан ниже, подходит для x86), так и старших.</p>
<pre>Содержимое стека  Адреса в памяти

.                .
.                .
.                .
+----------------+ 0x0000F040
|                |
+----------------+ 0x0000F044 &lt;-- вершина стека (на неё указывает %esp)
|     данные     |
+----------------+ 0x0000F048
|     данные     |
+----------------+ 0x0000F04C
.                .
.                .
.                .
+----------------+ 0x0000FFF8
|     данные     |
+----------------+ 0x0000FFFC
|     данные     |
+----------------+ 0x00010000 &lt;-- дно стека
</pre>
<p>Стек растёт в сторону младших адресов. Это значит, что последний записанный в стек элемент будет расположен по адресу младше остальных элементов стека.</p>
<p>При помещении нового элемента в стек происходит следующее (принцип работы команды <code>push</code>):</p>
<ul>
<li>значение <code>%esp</code> уменьшается на размер элемента в байтах (4 или 2);</li>
<li>новый элемент записывается по адресу, на который указывает <code>%esp</code>.</li>
</ul>
<pre>.                .
.                .
.                .
+----------------+ 0x0000F040 &lt;-- новая вершина стека (%esp)
|  новый элемент |
+----------------+ 0x0000F044 &lt;-- старая вершина стека
|     данные     |
+----------------+ 0x0000F048
.                .
.                .
.                .
+----------------+ 0x0000FFFC
|     данные     |
+----------------+ 0x00010000 &lt;-- дно стека
</pre>
<p>При выталкивании элемента из стека эти действия совершаются в обратном порядке(принцип работы команды <code>pop</code>):</p>
<ul>
<li>содержимое памяти по адресу, который записан в <code>%esp</code>, записывается в регистр;</li>
<li>а значение адреса в <code>%esp</code> увеличивается на размер элемента в байтах (4 или 2).</li>
</ul>
<pre>.                 .
.                 .
.                 .
+-----------------+ 0x0000F040 &lt;-- старая вершина стека
| верхний элемент | -------------&gt; записывается в регистр
+-----------------+ 0x0000F044 &lt;-- новая вершина стека (%esp)
|      данные     |
+-----------------+ 0x0000F048
.                 .
.                 .
.                 .
+-----------------+ 0x0000FFFC
|      данные     |
+-----------------+ 0x00010000 &lt;-- дно стека
</pre>
<h3><span class="mw-headline" id=".D0.9F.D0.B0.D0.BC.D1.8F.D1.82.D1.8C">Память</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=8" title="Редактировать раздел «Память»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>В Си после вызова <code>malloc(3)</code> программе выделяется блок памяти, и к нему можно получить доступ при помощи указателя, содержащего адрес этого блока. В ассемблере то же самое: после того, как программе выделили блок памяти, появляется возможность использовать указывающий на неё адрес для всевозможных манипуляций. Наименьший по размеру элемент памяти, на который может указать адрес, — байт. Говорят, что память адресуется побайтово, или гранулярность адресации памяти — один байт. Отдельный бит можно указать как адрес байта, содержащего этот бит, и номер этого бита в байте.</p>
<p>Правда, нужно отметить ещё одну деталь. Программный код расположен в памяти, поэтому получить его адрес также возможно. Стек — это тоже блок памяти, и разработчик может получить указатель на любой элемент стека, находящийся под вершиной. Таким образом организовывают доступ к произвольным элементам стека.</p>
<h3><span class="mw-headline" id=".D0.9F.D0.BE.D1.80.D1.8F.D0.B4.D0.BE.D0.BA_.D0.B1.D0.B0.D0.B9.D1.82.D0.BE.D0.B2._Little-endian_.D0.B8_big-endian">Порядок байтов. Little-endian и big-endian</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=9" title="Редактировать раздел «Порядок байтов. Little-endian и big-endian»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Оперативная память — это массив битовых значений, 0 и 1. Не будем говорить о порядке битов в байте, так как указать адрес отдельного бита невозможно; можно указать только адрес байта, содержащего этот бит. А как в памяти располагаются байты в слове? Предположим, что у нас есть число <code>0x01020304</code>. Его можно записать в виде байтовой последовательности:</p>
<table>
<tbody><tr>
<td>начиная со старшего байта:</td>
<td><code>0x01 0x02 0x03 0x04</code></td>
<td>— big-endian</td>
</tr>
<tr>
<td>начиная с младшего байта:</td>
<td><code>0x04 0x03 0x02 0x01</code></td>
<td>— little-endian</td>
</tr>
</tbody></table>
<p>Вот эта байтовая последовательность располагается в оперативной памяти, адрес всего слова в памяти — адрес первого байта последовательности.</p>
<p>Если первым располагается младший байт (запись начинается с «меньшего конца») — такой порядок байт называется little-endian, или «интеловским». Именно он используется в процессорах x86.</p>
<p>Если первым располагается старший байт (запись начинается с «большего конца») — такой порядок байт называется big-endian.</p>
<p>У порядка little-endian есть одно важное достоинство. Посмотрите на запись числа <code>0x00000033</code>:</p>
<pre>0x33 0x00 0x00 0x00
</pre>
<p>Если прочесть его как двухбайтовое значение, получим <code>0x0033</code>. Если прочесть как однобайтовое, получим <code>0x33</code>. При записи этот трюк тоже работает. Конечно же, мы не можем прочитать число <code>0x11223344</code> как байт, потому что получим <code>0x44</code>, что неверно. Поэтому считываемое число должно помещаться в целевой диапазон значений.</p>
<h4><span class="mw-headline" id=".D0.A1.D0.BC._.D1.82.D0.B0.D0.BA.D0.B6.D0.B5">См. также</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=10" title="Редактировать раздел «См. также»">править</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/en:Endianness" class="extiw" title="w:en:Endianness">Статья «Endianness» в en.wikipedia.org</a></li>
<li><a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2" class="extiw" title="w:Порядок байтов">Статья «Порядок байтов» в ru.wikipedia.org</a></li>
</ul>
<h2><span class="mw-headline" id="Hello.2C_world.21">Hello, world!</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=11" title="Редактировать раздел «Hello, world!»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>При изучении нового языка принято писать самой первой программу, выводящую на экран строку <code>Hello, world!</code>. Сейчас мы не ставим перед собой задачу понять всё написанное. Главное — посмотреть, как оформляются программы на ассемблере, и научиться их компилировать.</p>
<p>Вспомним, как вы писали <code>Hello, world!</code> на Си. Скорее всего, приблизительно так:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Hello, world!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Вот только <code>printf(3)</code> — функция стандартной библиотеки Си, а не операционной системы. «Чем это плохо?» — спросите вы. Да, в общем, всё нормально, но, читая этот учебник, вы, вероятно, хотите узнать, что происходит «за кулисами» функций стандартной библиотеки на уровне взаимодействия с операционной системой. Это, конечно же, не значит, что из ассемблера нельзя вызывать функции библиотеки Си. Просто мы пойдём более низкоуровневым путём.</p>
<p>Как вы уже, наверное, знаете, стандартный вывод (<code>stdout</code>), в который выводит данные <code>printf(3)</code>, является обычным файловым дескриптором, заранее открываемый операционной системой. Номер этого дескриптора — 1. Теперь нам на помощь придёт системный вызов <code>write(2)</code>.</p>
<pre>WRITE(2)        Руководство программиста Linux        WRITE(2)

ИМЯ
        write - писать в файловый дескриптор

ОБЗОР
        #include &lt;unistd.h&gt;

        ssize_t write(int fd, const void *buf, size_t count);

ОПИСАНИЕ
        write пишет count байт в файл, на который ссылается файловый
        дескриптор fd, из буфера, на который указывает buf.
</pre>
<p>А вот и сама программа:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hello, world!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Почему <code>sizeof(str) - 1</code>? Потому, что строка в Си заканчивается нулевым байтом, а его нам печатать не нужно.</p>
<p>Теперь скопируйте следующий текст в файл <code>hello.s</code>. Файлы исходного кода на ассемблере имеют расширение <code>.s</code>.</p>
<pre>.data                         /* поместить следующее в сегмент данных
                                                                    */
 
hello_str:                    /* наша строка                        */
        .string "Hello, world!\n"
 
                              /* длина строки                       */
        .set hello_str_length, . - hello_str - 1
 
.text                         /* поместить следующее в сегмент кода */
 
.globl  main                  /* main - глобальный символ, видимый
                                 за пределами текущего файла        */
.type   main, @function       /* main - функция (а не данные)       */
 
 
main:
        movl    $4, %eax      /* поместить номер системного вызова
                                 write = 4 в регистр %eax           */
 
        movl    $1, %ebx      /* первый параметр - в регистр %ebx;
                                 номер файлового дескриптора 
                                 stdout - 1                         */
 
        movl    $hello_str, %ecx  /* второй параметр - в регистр %ecx;
                                     указатель на строку            */
 
        movl    $hello_str_length, %edx /* третий параметр - в регистр
                                           %edx; длина строки       */
 
        int     $0x80         /* вызвать прерывание 0x80            */
 
        movl    $1, %eax      /* номер системного вызова exit - 1   */
        movl    $0, %ebx      /* передать 0 как значение параметра  */
        int     $0x80         /* вызвать exit(0)                    */
 
        .size   main, . - main    /* размер функции main            */
</pre>
<p>Напомним, сейчас наша задача — скомпилировать первую программу. Подробное объяснение этого кода будет потом.</p>
<pre>[user@host:~]$ gcc hello.s -o hello
[user@host:~]$
</pre>
<p>Если компиляция проходит успешно, GCC ничего не выводит на экран. Кроме компиляции, GCC автоматически выполняет и компоновку, как и при компиляции программ на C. Теперь запускаем нашу программу и убеждаемся, что она корректно завершилась с кодом возврата 0.</p>
<pre>[user@host:~]$ ./hello
Hello, world!
[user@host:~]$ echo $?
0
</pre>
<p>Теперь было бы хорошо прочитать главу про отладчик <a href="https://ru.wikipedia.org/wiki/GNU_Debugger" class="extiw" title="w:GNU Debugger">GDB</a>. Он вам понадобится для исследования работы ваших программ. Возможно, сейчас вы не всё поймёте, но эта глава специально расположена в конце, так как задумана больше как справочная, нежели обучающая. Для того, чтобы научиться работать с отладчиком, с ним нужно просто работать.</p>
<h2><span class="mw-headline" id=".D0.A1.D0.B8.D0.BD.D1.82.D0.B0.D0.BA.D1.81.D0.B8.D1.81_.D0.B0.D1.81.D1.81.D0.B5.D0.BC.D0.B1.D0.BB.D0.B5.D1.80.D0.B0">Синтаксис ассемблера</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=12" title="Редактировать раздел «Синтаксис ассемблера»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D1.8B">Команды</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=13" title="Редактировать раздел «Команды»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Команды ассемблера — это те инструкции, которые будет исполнять процессор. По сути, это самый низкий уровень программирования процессора. Каждая команда состоит из операции (что делать?) и операндов (аргументов). Операции мы будем рассматривать отдельно. А операнды у всех операций задаются в одном и том же формате. Операндов может быть от 0 (то есть нет вообще) до 3. В роли операнда могут выступать:</p>
<ul>
<li>Конкретное значение, известное на этапе компиляции, — например, числовая константа или символ. Записываются при помощи знака <code>$</code>, например: <code>$0xf1</code>, <code>$10</code>, <code>$hello_str</code>. Эти операнды называются непосредственными.</li>
<li>Регистр. Перед именем регистра ставится знак <code>%</code>, например: <code>%eax</code>, <code>%bx</code>, <code>%cl</code>.</li>
<li>Указатель на ячейку в памяти (как он формируется и какой имеет синтаксис записи — далее в этом разделе).</li>
<li>Неявный операнд. Эти операнды не записываются непосредственно в исходном коде, а подразумеваются. Нет, конечно, компьютер не читает ваши мысли. Просто некоторые команды всегда обращаются к определённым регистрам без явного указания, так как это входит в логику их работы. Такое поведение всегда описывается в документации.</li>
</ul>
<p><br></p>
<table class="metadata plainlinks ambox ambox-style">
<tbody><tr>
<td class="ambox-image">
<div><a href="https://ru.wikibooks.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:Nuvola_apps_important_yellow.svg" class="image" title="⚠"><img alt="⚠" src="./Ассемблер в Linux для программистов C — Викиучебник_files/50px-Nuvola_apps_important_yellow.svg.png" width="50" height="42" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Nuvola_apps_important_yellow.svg/75px-Nuvola_apps_important_yellow.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Nuvola_apps_important_yellow.svg/100px-Nuvola_apps_important_yellow.svg.png 2x" data-file-width="600" data-file-height="500"></a></div>
</td>
<td class="ambox-text"><b>Внимание!</b> Если вы забудете знак <code>$</code>, когда записываете непосредственное числовое значение, компилятор будет интерпретировать число как абсолютный адрес. Это не вызовет ошибок компиляции, но, скорее всего, приведёт к <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B0_%D1%81%D0%B5%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D0%B8" class="extiw" title="w:Ошибка сегментации">ошибке сегментации</a> (segmentation fault) при выполнении.</td>
<td class="widthhack"></td>
</tr>
</tbody></table>
<p>Почти у каждой команды можно определить операнд-источник (из него команда читает данные) и операнд-назначение (в него команда записывает результат). Общий синтаксис команды ассемблера такой:</p>
<pre> <i>Операция</i>    <i>Источник</i>, <i>Назначение</i>
</pre>
<p>Для того, чтобы привести пример команды, я, немного забегая наперед, расскажу об одной операции. Команда <code>mov <i>источник</i>, <i>назначение</i></code> производит копирование <i>источника</i> в <i>назначение</i>. Возьмем строку из <code>hello.s</code>:</p>
<pre>movl    $4, %eax              /* поместить номер системного вызова
                                 write = 4 в регистр %eax           */
</pre>
<p>Как видим, источник — это непосредственное значение 4, а назначение — регистр <code>%eax</code>. Суффикс <code>l</code> в имени команды указывает на то, что ей следует работать с операндами длиной в 4 байта. Все суффиксы:</p>
<ul>
<li><code>b</code> (от англ. byte) — 1 байт,</li>
<li><code>w</code> (от англ. word) — 2 байта,</li>
<li><code>l</code> (от англ. long) — 4 байта,</li>
<li><code>q</code> (от англ. quad) — 8 байт.</li>
</ul>
<p>Таким образом, чтобы записать <code>$42</code> в регистр <code>%al</code> (а он имеет размер 1 байт):</p>
<pre>movb    $42, %al
</pre>
<p>Важной особенностью всех команд является то, что они не могут работать с двумя операндами, находящимися в памяти. Хотя бы один из них следует сначала загрузить в регистр, а затем выполнять необходимую операцию.</p>
<p>Как формируется указатель на ячейку памяти? Синтаксис:</p>
<pre> <i>смещение</i>(<i>база</i>, <i>индекс</i>, <i>множитель</i>)
</pre>
<p>Вычисленный адрес будет равен <i>база</i> + <i>индекс</i> × <i>множитель</i> + <i>смещение</i>. <i>Множитель</i> может принимать значения 1, 2, 4 или 8. Например:</p>
<ul>
<li><code>(%ecx)</code> адрес операнда находится в регистре <code>%ecx</code>. Этим способом удобно адресовать отдельные элементы в памяти, например, указатель на строку или указатель на <code>int</code>;</li>
<li><code>4(%ecx)</code> адрес операнда равен <code>%ecx</code> + 4. Удобно адресовать отдельные поля структур. Например, в <code>%ecx</code> адрес некоторой структуры, второй элемент которой находится «на расстоянии» 4 байта от её начала (говорят «по смещению 4 байта»);</li>
<li><code>-4(%ecx)</code> адрес операнда равен <code>%ecx</code> − 4;</li>
<li><code>foo(,%ecx,4)</code> адрес операнда равен <code>foo</code> + <code>%ecx</code> × 4, где <code>foo</code> — некоторый адрес. Удобно обращаться к элементам массива. Если <code>foo</code> — указатель на массив, элементы которого имеют размер 4 байта, то мы можем заносить в <code>%ecx</code> номер элемента и таким образом обращаться к самому элементу.</li>
</ul>
<p>Ещё один важный нюанс: команды нужно помещать в секцию кода. Для этого перед командами нужно указать директиву <code>.text</code>. Вот так:</p>
<pre>.text
        movl    $42, %eax
        ...
</pre>
<h3><span class="mw-headline" id=".D0.94.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5">Данные</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=14" title="Редактировать раздел «Данные»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Существуют директивы ассемблера, которые размещают в памяти данные, определенные программистом. Аргументы этих директив — список выражений, разделенных запятыми.</p>
<ul>
<li><code>.byte</code> — размещает каждое выражение как 1 байт;</li>
<li><code>.short</code> — 2 байта;</li>
<li><code>.long</code> — 4 байта;</li>
<li><code>.quad</code> — 8 байт.</li>
</ul>
<p>Например:</p>
<pre>.byte   0x10, 0xf5, 0x42, 0x55
.long   0xaabbaabb
.short  -123, 456
</pre>
<p>Также существуют директивы для размещения в памяти строковых литералов:</p>
<ul>
<li><code>.ascii "STR"</code> размещает строку <code>STR</code>. Нулевых байтов не добавляет.</li>
<li><code>.string "STR"</code> размещает строку <code>STR</code>, после которой следует нулевой байт (как в языке Си).</li>
<li>У директивы <code>.string</code> есть синоним <code>.asciz</code> (z от англ. zero — ноль, указывает на добавление нулевого байта).</li>
</ul>
<p>Строка-аргумент этих директив может содержать стандартные escape-последовательности, которые вы использовали в Си, например, <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\\</code>, <code>\"</code> и так далее.</p>
<p>Данные нужно помещать в секцию данных. Для этого перед данными нужно поместить директиву <code>.data</code>. Вот так:</p>
<pre>.data
        .string "Hello, world\n"
        ...
</pre>
<p>Если некоторые данные не предполагается изменять в ходе выполнения программы, их можно поместить в специальную секцию данных только для чтения при помощи директивы <code>.section .rodata</code>:</p>
<pre>.section .rodata
        .string "program version 0.314"
</pre>
<p>Приведём небольшую таблицу, в которой сопоставляются типы данных в Си на IA-32 и в ассемблере. Нужно заметить, что размер этих типов в языке Си на других архитектурах (или даже компиляторах) может отличаться.</p>
<table class="standard">
<tbody><tr>
<th>Тип данных в Си</th>
<th>Размер (sizeof), байт</th>
<th>Выравнивание, байт</th>
<th>Название</th>
</tr>
<tr>
<td>char<br>
signed char</td>
<td>1</td>
<td>1</td>
<td>signed byte (байт со знаком)</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1</td>
<td>1</td>
<td>unsigned byte (байт без знака)</td>
</tr>
<tr>
<td>short<br>
signed short</td>
<td>2</td>
<td>2</td>
<td>signed halfword (полуслово со знаком)</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2</td>
<td>2</td>
<td>unsigned halfword (полуслово без знака)</td>
</tr>
<tr>
<td>int<br>
signed int<br>
long<br>
signed long<br>
enum</td>
<td>4</td>
<td>4</td>
<td>signed word (слово со знаком)</td>
</tr>
<tr>
<td>unsigned int<br>
unsigned long</td>
<td>4</td>
<td>4</td>
<td>unsigned word (слово без знака)</td>
</tr>
</tbody></table>
<p><br>
Отдельных объяснений требует колонка «Выравнивание». Выравнивание задано у каждого фундаментального типа данных (типа данных, которым процессор может оперировать непосредственно). Например, выравнивание word — 4 байта. Это значит, что данные типа word должны располагаться по адресу, кратному 4 (например, 0x00000100, 0x03284478). Архитектура рекомендует, но не требует выравнивания: доступ к невыровненным данным может быть медленнее, но принципиальной разницы нет и ошибки это не вызовет.</p>
<p>Для соблюдения выравнивания в распоряжении программиста есть директива <code>.p2align</code>.</p>
<pre> .p2align <i>степень_двойки</i>, <i>заполнитель</i>, <i>максимум</i>
</pre>
<p>Директива <code>.p2align</code> выравнивает текущий адрес до заданной границы. Граница выравнивания задаётся как степень числа 2: например, если вы указали <code>.p2align 3</code> — следующее значение будет выровнено по 8-байтной границе. Для выравнивания размещается необходимое количество байт-заполнителей со значением <i>заполнитель</i>. Если для выравнивания требуется разместить более чем <i>максимум</i> байт-заполнителей, то выравнивание не выполняется.</p>
<p>Второй и третий аргумент являются необязательными.</p>
<p>Примеры:</p>
<pre>.data
        .string "Hello, world\n"    /* мы вряд ли захотим считать,
                                       сколько символов занимает эта 
                                       строка, и является ли следующий
                                       адрес выровненным            */
        .p2align 2                  /* выравниваем по границе 4 байта 
                                       для следующего .long         */
        .long 123456
</pre>
<h3><span class="mw-headline" id=".D0.9C.D0.B5.D1.82.D0.BA.D0.B8_.D0.B8_.D0.BF.D1.80.D0.BE.D1.87.D0.B8.D0.B5_.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D1.8B">Метки и прочие символы</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=15" title="Редактировать раздел «Метки и прочие символы»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Вы, наверно, заметили, что мы не присвоили имён нашим данным. Как же к ним обращаться? Очень просто: нужно поставить метку. Метка — это просто константа, значение которой — адрес.</p>
<pre>hello_str:
        .string "Hello, world!\n"
</pre>
<p>Сама метка, в отличие от данных, места в памяти программы не занимает. Когда компилятор встречает в исходном коде метку, он запоминает текущий адрес и читает код дальше. В результате компилятор помнит все метки и адреса, на которые они указывают. Программист может ссылаться на метки в своём коде. Существует специальная псевдометка, указывающая на текущий адрес. Это метка <code>.</code> (точка).</p>
<p>Значение метки как константы — это всегда адрес. А если вам нужна константа с каким-то другим значением? Тогда мы приходим к более общему понятию «символ». Символ — это просто некоторая константа. Причём он может быть определён в одном файле, а использован в других.</p>
<p>Возьмём <code>hello.s</code> и скомпилируем его так:</p>
<pre>[user@host:~]$ gcc -c hello.s
[user@host:~]$ 
</pre>
<p>Обратите внимание на параметр <code>-c</code>. Мы компилируем исходный код не в исполняемый файл, а лишь только в отдельный объектный файл <code>hello.o</code>. Теперь воспользуемся программой <code>nm(1)</code>:</p>
<pre>[user@host:~]$ nm hello.o
00000000 d hello_str
0000000e a hello_str_length
00000000 T main
</pre>
<p><code>nm(1)</code> выводит список символов в объектном файле. В первой колонке выводится значение символа, во второй — его тип, в третьей — имя. Посмотрим на символ <code>hello_str_length</code>. Это длина строки <code>Hello, world!\n</code>. Значение символа чётко определено и равно <code>0xe</code>, об этом говорит тип <code>a</code> — absolute value. А вот символ <code>hello_str</code> имеет тип <code>d</code> — значит, он находится в секции данных (data). Символ <code>main</code> находится в секции кода (text section, тип <code>T</code>). А почему <code>a</code> представлено строчной буквой, а <code>T</code> — прописной? Если тип символа обозначен строчной буквой, значит это локальный символ, который видно только в пределах данного файла. Заглавная буква говорит о том, что символ глобальный и доступен другим модулям. Символ <code>main</code> мы сделали глобальным при помощи директивы <code>.global main</code>.</p>
<p>Для создания нового символа используется директива <code>.set</code>. Синтаксис:</p>
<pre> .set    <i>символ</i>, <i>выражение</i>
</pre>
<p>Например, определим символ <code>foo</code> = 42:</p>
<pre>.set    foo, 42
</pre>
<p>Ещё пример из <code>hello.s</code>:</p>
<pre>hello_str:                              
        .string "Hello, world!\n"                    /* наша строка  */
        .set    hello_str_length, . - hello_str - 1  /* длина строки */
</pre>
<p>Сначала определяется символ <code>hello_str</code>, который содержит адрес строки. После этого мы определяем символ <code>hello_str_length</code>, который, судя по названию, содержит длину строки. Директива <code>.set</code> позволяет в качестве значения символа использовать арифметические выражения. Мы из значения текущего адреса (метка «точка») вычитаем адрес начала строки — получаем длину строки в байтах. Потом мы вычитаем ещё единицу, потому что директива <code>.string</code> добавляет в конце строки нулевой байт (а на экран мы его выводить не хотим).</p>
<h3><span class="mw-headline" id=".D0.9D.D0.B5.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5">Неинициализированные данные</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=16" title="Редактировать раздел «Неинициализированные данные»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Часто требуется просто зарезервировать место в памяти для данных, без инициализации какими-то значениями. Например, у вас есть переменная, значение которой определяется параметрами командной строки. Действительно, вы вряд ли сможете дать ей какое-то осмысленное начальное значение, разве что 0. Такие данные называются неинциализированными, и для них выделена специальная секция под названием <code>.bss</code>. В скомпилированной программе эта секция места не занимает. При загрузке программы в память секция неинициализированых данных будет заполнена нулевыми байтами.</p>
<p>Хорошо, но известные нам директивы размещения данных требуют указания инициализирующего значения. Поэтому для неинициализированных данных используются специальные директивы:</p>
<pre> .space  <i>количество_байт</i>
 .space  <i>количество_байт</i>, <i>заполнитель</i>
</pre>
<p>Директива <code>.space</code> резервирует <i>количество_байт</i> байт.</p>
<p>Также эту директиву можно использовать для размещения инициализированных данных, для этого существует параметр <i>заполнитель</i> — этим значением будет инициализирована память.</p>
<p>Например:</p>
<pre>.bss
long_var_1:                   /* по размеру как .long                */
        .space 4
 
buffer:                       /* какой-то буфер в 1024 байта         */
        .space 1024
 
struct:                       /* какая-то структура размером 20 байт */
        .space 20
</pre>
<h2><span class="mw-headline" id=".D0.9C.D0.B5.D1.82.D0.BE.D0.B4.D1.8B_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D0.B8">Методы адресации</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=17" title="Редактировать раздел «Методы адресации»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Пространство памяти предназначено для хранения кодов команд и данных, для доступа к которым имеется богатый выбор методов адресации (около 24). Операнды могут находиться во внутренних регистрах процессора (наиболее удобный и быстрый вариант). Они могут располагаться в системной памяти (самый распространенный вариант). Наконец, они могут находиться в устройствах ввода/вывода (наиболее редкий случай). Определение местоположения операндов производится кодом команды. Причем существуют разные методы, с помощью которых код команды может определить, откуда брать входной операнд и куда помещать выходной операнд. Эти методы называются методами адресации. Эффективность выбранных методов адресации во многом определяет эффективность работы всего процессора в целом.</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D1.8F.D0.BC.D0.B0.D1.8F_.D0.B8.D0.BB.D0.B8_.D0.B0.D0.B1.D1.81.D0.BE.D0.BB.D1.8E.D1.82.D0.BD.D0.B0.D1.8F_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F">Прямая или абсолютная адресация</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=18" title="Редактировать раздел «Прямая или абсолютная адресация»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Физический адрес операнда содержится в адресной части команды. Формальное обозначение:</p>
<p><code>Операнд<sub>i</sub> = (А<sub>i</sub>)</code></p>
<p>где А<sub>i</sub> – код, содержащийся в i-м адресном поле команды.</p>
<pre>.data
num:
        .long    0x12345678

.text
main:
        movl    (num), %eax   /* Записать в регистр %eax операнд, 
                                 который содержится в оперативной 
                                 памяти по адресу метки num          */
        
        addl    (num), %eax   /* Сложить с регистром %eax операнд, 
                                 который содержится в оперативной 
                                 памяти по адресу метки num и записать 
                                 результат в регистр %eax            */
        
        ret
</pre>
<h3><span class="mw-headline" id=".D0.9D.D0.B5.D0.BF.D0.BE.D1.81.D1.80.D0.B5.D0.B4.D1.81.D1.82.D0.B2.D0.B5.D0.BD.D0.BD.D0.B0.D1.8F_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F">Непосредственная адресация</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=19" title="Редактировать раздел «Непосредственная адресация»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>В команде содержится не адрес операнда, а непосредственно сам операнд.</p>
<p><code>Операнд<sub>i</sub>= А<sub>i</sub>.</code></p>
<p>Непосредственная адресация позволяет повысить скорость выполнения операции, так как в этом случае вся команда, включая операнд, считывается из памяти одновременно и на время выполнения команды хранится в процессоре в специальном регистре команд (РК). Однако при использовании непосредственной адресации появляется зависимость кодов команд от данных, что требует изменения программы при каждом изменении непосредственного операнда.</p>
<p>Пример:</p>
<pre>.text
main:
        movl    $0x12345, %eax       /* загрузить константу 0x12345 в 
                                        регистр %eax.                */
</pre>
<h3><span class="mw-headline" id=".D0.9A.D0.BE.D1.81.D0.B2.D0.B5.D0.BD.D0.BD.D0.B0.D1.8F_.28.D0.B1.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D1.8F.29_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F">Косвенная (базовая) адресация</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=20" title="Редактировать раздел «Косвенная (базовая) адресация»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Адресная часть команды указывает адрес ячейки памяти или регистр, в котором содержится адрес операнда:</p>
<p><code>Операнд<sub>i</sub> = ((А<sub>i</sub>))</code></p>
<p>Применение косвенной адресации операнда из оперативной памяти при хранении его адреса в регистровой памяти существенно сокращает длину поля адреса, одновременно сохраняя возможность использовать для указания физического адреса полную разрядность регистра. Недостаток этого способа – необходимо дополнительное время для чтения адреса операнда. Вместе с тем он существенно повышает гибкость программирования. Изменяя содержимое ячейки памяти или регистра, через которые осуществляется адресация, можно, не меняя команды в программе, обрабатывать операнды, хранящиеся по разным адресам. Косвенная адресация не применяется по отношению к операндам, находящимся в регистровой памяти.</p>
<p>Пример:</p>
<pre>.data
num:
        .long   0x1234

.text
main:
        movl    $num, %ebx      /* записать адрес метки в регистр 
                                   адреса %ebx                       */

        movl    (%ebx), %eax    /* записать в регистр %eax операнд из 
                                   оперативной памяти, адрес которого 
                                   находится в регистре адреса %ebx  */
</pre>
<p>Предоставляемые косвенной адресацией возможности могут быть расширены, если в системе команд ЭВМ предусмотреть определенные арифметические и логические операции над ячейкой памяти или регистром, через которые выполняется адресация, например увеличение или уменьшение их значения.</p>
<h3><span class="mw-headline" id=".D0.90.D0.B2.D1.82.D0.BE.D0.B8.D0.BD.D0.BA.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.BD.D0.B0.D1.8F_.D0.B8_.D0.B0.D0.B2.D1.82.D0.BE.D0.B4.D0.B5.D0.BA.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.BD.D0.B0.D1.8F_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F">Автоинкрементная и автодекрементная адресация</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=21" title="Редактировать раздел «Автоинкрементная и автодекрементная адресация»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Иногда, адресация, при которой после каждого обращения по заданному адресу с использованием механизма косвенной адресации, значение адресной ячейки автоматически увеличивается на длину считываемого операнда, называется автоинкрементной. Адресация с автоматическим уменьшением значения адресной ячейки называется автодекрементной.</p>
<h3><span class="mw-headline" id=".D0.A0.D0.B5.D0.B3.D0.B8.D1.81.D1.82.D1.80.D0.BE.D0.B2.D0.B0.D1.8F_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F">Регистровая адресация</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=22" title="Редактировать раздел «Регистровая адресация»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Предполагается, что операнд находится во внутреннем регистре процессора.</p>
<p>Пример:</p>
<pre>.text
main:
        movl    $0x12345, %eax  /* записать в регистр константу 0x12345
                                                                     */
        movl    %eax, %ecx      /* записать в регистр %ecx операнд, 
                                   который находится в регистре %eax */
</pre>
<h3><span class="mw-headline" id=".D0.9E.D1.82.D0.BD.D0.BE.D1.81.D0.B8.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.B0.D0.B4.D1.80.D0.B5.D1.81.D0.B0.D1.86.D0.B8.D1.8F">Относительная адресация</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=23" title="Редактировать раздел «Относительная адресация»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Этот способ используется тогда, когда память логически разбивается на блоки, называемые сегментами. В этом случае адрес ячейки памяти содержит две составляющих: адрес начала сегмента (базовый адрес) и смещение адреса операнда в сегменте. Адрес операнда определяется как сумма базового адреса и смещения относительно этой базы:</p>
<p><code>Операнд<sub>i</sub> = (база<sub>i</sub> + смещение<sub>i</sub>)</code></p>
<p>Для задания базового адреса и смещения могут применяться ранее рассмотренные способы адресации. Как правило, базовый адрес находится в одном из регистров регистровой памяти, а смещение может быть задано в самой команде или регистре.</p>
<p>Рассмотрим два примера:</p>
<ol>
<li>Адресное поле команды состоит из двух частей, в одной указывается номер регистра, хранящего базовое значение адреса (начальный адрес сегмента), а в другом адресном поле задается смещение, определяющее положение ячейки относительно начала сегмента. Именно такой способ представления адреса обычно и называют относительной адресацией.</li>
<li>Первая часть адресного поля команды также определяет номер базового регистра, а вторая содержит номер регистра, в котором находится смещение. Такой способ адресации чаще всего называют базово-индексным.</li>
</ol>
<p>Главный недостаток относительной адресации – большое время вычисления физического адреса операнда. Но существенное преимущество этого способа адресации заключается в возможности создания "перемещаемых" программ – программ, которые можно размещать в различных частях памяти без изменения команд программы. То же относится к программам, обрабатывающим по единому алгоритму информацию, расположенную в различных областях ЗУ. В этих случаях достаточно изменить содержимое базового адреса начала команд программы или массива данных, а не модифицировать сами команды. По этой причине относительная адресация облегчает распределение памяти при составлении сложных программ и широко используется при автоматическом распределении памяти в мультипрограммных вычислительных системах.</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D1.8B_.D0.B0.D1.81.D1.81.D0.B5.D0.BC.D0.B1.D0.BB.D0.B5.D1.80.D0.B0">Команды ассемблера</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=24" title="Редактировать раздел «Команды ассемблера»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.B0_mov">Команда <code>mov</code></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=25" title="Редактировать раздел «Команда mov»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Синтаксис:</p>
<pre> mov   <i>источник</i>, <i>назначение</i>
</pre>
<p>Команда <code>mov</code> производит копирование <i>источника</i> в <i>назначение</i>. Рассмотрим примеры:</p>
<pre>/*
 * Это просто примеры использования команды mov,
 * ничего толкового этот код не делает
 */

.data
some_var:
        .long 0x00000072
 
other_var:
        .long 0x00000001, 0x00000002, 0x00000003

.text
.globl main
main:
        movl  $0x48, %eax       /* поместить число 0x00000048 в %eax */
 
        movl  $some_var, %eax   /* поместить в %eax значение метки 
                                   some_var, то есть адрес числа в 
                                   памяти; например, у автора 
                                   содержимое %eax равно 0x08049589  */
 
        movl  some_var, %eax    /* обратиться к содержимому переменной;
                                   в %eax теперь 0x00000072          */
 
        movl  other_var + 4, %eax  /* other_var указывает на 0x00000001
                                   размер одного значения типа long — 4
                                   байта; значит, other_var + 4 
                                   указывает на 0x00000002;
                                   в %eax теперь 0x00000002          */
 
        movl  $1, %ecx          /* поместить число 1 в %ecx          */

        movl  other_var(,%ecx,4), %eax  /* поместить в %eax первый 
                                   (нумерация с нуля) элемент массива 
                                   other_var, пользуясь %ecx как 
                                   индексным регистром               */
 
        movl  $other_var, %ebx  /* поместить в %ebx адрес массива 
                                   other_var                         */

        movl  4(%ebx), %eax     /* обратиться по адресу %ebx + 4;
                                   в %eax снова 0x00000002           */
 
        movl  $other_var + 4, %eax  /* поместить в %eax адрес, по 
                                   которому расположен 0x00000002
                                   (адрес массива плюс 4 байта -- 
                                   пропустить нулевой элемент)       */

        movl  $0x15, (%eax)     /* записать по адресу "то, что записано
                                   в %eax" число 0x00000015          */
</pre>
<p>Внимательно следите, когда вы загружаете адрес переменной, а когда обращаетесь к значению переменной по её адресу. Например:</p>
<pre>movl  other_var + 4, %eax       /* забыли знак $, в результате в %eax 
                                   находится число 0x00000002        */

movl  $0x15, (%eax)             /* пытаемся записать по адресу 
                                   0x00000002 -&gt; получаем segmentation 
                                   fault                             */
 
movl  0x48, %eax                /* забыли $, и пытаемся обратиться по 
                                   адресу 0x00000048 -&gt; segmentation
                                   fault                             */
</pre>
<h3><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.B0_lea">Команда lea</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=26" title="Редактировать раздел «Команда lea»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><code>lea</code> — мнемоническое от англ. Load Effective Address. Синтаксис:</p>
<pre> lea   <i>источник</i>, <i>назначение</i>
</pre>
<p>Команда <code>lea</code> помещает адрес <i>источника</i> в <i>назначение</i>. <i>Источник</i> должен находиться в памяти (не может быть непосредственным значением&nbsp;— константой или регистром). Например:</p>
<pre>.data
some_var:
        .long 0x00000072
 
.text
        leal  0x32, %eax        /* аналогично movl $0x32, %eax       */
        leal  some_var, %eax    /* аналогично movl $some_var, %eax   */
 
        leal  $0x32, %eax       /* вызовет ошибку при компиляции, 
                                   так как $0x32 - непосредственное 
                                   значение                          */
        leal  $some_var, %eax   /* аналогично, ошибка компиляции: 
                                   $some_var - это непосредственное 
                                   значение, адрес                   */
 
        leal  4(%esp), %eax     /* поместить в %eax адрес предыдущего 
                                   элемента в стеке;
                                   фактически, %eax = %esp + 4       */
</pre>
<h3><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D1.8B_.D0.B4.D0.BB.D1.8F_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D1.8B_.D1.81.D0.BE_.D1.81.D1.82.D0.B5.D0.BA.D0.BE.D0.BC">Команды для работы со стеком</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=27" title="Редактировать раздел «Команды для работы со стеком»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Предусмотрено две специальные команды для работы со стеком: <code>push</code> (поместить в стек) и <code>pop</code> (извлечь из стека). Синтаксис:</p>
<pre> push  <i>источник</i>
 pop   <i>назначение</i>
</pre>
<p>При описании работы стека мы уже обсуждали принцип работы команд <code>push</code> и <code>pop</code>. Важный нюанс: <code>push</code> и <code>pop</code> работают только с операндами размером 4 или 2 байта. Если вы попробуете скомпилировать что-то вроде</p>
<pre>pushb 0x10
</pre>
<p>GCC вернёт следующее:</p>
<pre>[user@host:~]$ gcc test.s
test.s: Assembler messages:
test.s:14: Error: suffix or operands invalid for `push'
[user@host:~]$ 
</pre>
<p>Согласно ABI, в Linux стек выровнен по <code>long</code>. Сама архитектура этого не требует, это только соглашение между программами, но не рассчитывайте, что другие библиотеки подпрограмм или операционная система захотят работать с невыровненным стеком. Что всё это значит? Если вы резервируете место в стеке, количество байт должно быть кратно размеру <code>long</code>, то есть 4. Например, вам нужно всего 2 байта в стеке для <code>short</code>, но вам всё равно придётся резервировать 4 байта, чтобы соблюдать выравнивание.</p>
<p>А теперь примеры:</p>
<pre>.text
        pushl $0x10             /* поместить в стек число 0x10       */
        pushl $0x20             /* поместить в стек число 0x20       */
        popl  %eax              /* извлечь 0x20 из стека и записать в 
                                   %eax                              */
        popl  %ebx              /* извлечь 0x10 из стека и записать в 
                                   %ebx                              */
 
        pushl %eax              /* странный способ сделать           */
        popl  %ebx              /* movl %eax, %ebx                   */
 
        movl  $0x00000010, %eax
        pushl %eax              /* поместить в стек содержимое %eax  */
        popw  %ax               /* извлечь 2 байта из стека и 
                                   записать в %ax                    */
        popw  %bx               /* и ещё 2 байта и записать в %bx    */
                                /* в %ax находится 0x0010, в %bx 
                                   находится 0x0000; такой код сложен 
                                   для понимания, его следует избегать 
                                                                     */
 
        pushl %eax              /* поместить %eax в стек; %esp 
                                   уменьшится на 4                   */
        addl  $4, %esp          /* увеличить %esp на 4; таким образом, 
                                   стек будет приведён в исходное 
                                   состояние                         */
</pre>
<p>Интересный вопрос: какое значение помещает в стек вот эта команда</p>
<pre>pushl %esp
</pre>
<p>Если ещё раз взглянуть на алгоритм работы команды <code>push</code>, кажется очевидным, что в данном случае она должна поместить уже уменьшенное значение <code>%esp</code>. Однако в документации Intel <sup id="cite_ref-2" class="reference"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#cite_note-2">[2]</a></sup> сказано, что в стек помещается такое значение <code>%esp</code>, каким оно было до выполнения команды — и она действительно работает именно так.</p>
<h3><span class="mw-headline" id=".D0.90.D1.80.D0.B8.D1.84.D0.BC.D0.B5.D1.82.D0.B8.D0.BA.D0.B0">Арифметика</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=28" title="Редактировать раздел «Арифметика»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Арифметических команд в нашем распоряжении довольно много. Синтаксис:</p>
<pre> inc   <i>операнд</i>
 dec   <i>операнд</i>

 add   <i>источник</i>, приёмник
 sub   <i>источник</i>, приёмник

 mul   <i>множитель_1</i>
</pre>
<p>Принцип работы:</p>
<ul>
<li><code>inc</code>: увеличивает <i>операнд</i> на 1.</li>
<li><code>dec</code>: уменьшает <i>операнд</i> на 1.</li>
</ul>
<ul>
<li><code>add</code>: <i>приёмник</i> = <i>приёмник</i> + <i>источник</i> (то есть, увеличивает <i>приёмник</i> на <i>источник</i>).</li>
<li><code>sub</code>: <i>приёмник</i> = <i>приёмник</i> - <i>источник</i> (то есть, уменьшает <i>приёмник</i> на <i>источник</i>).</li>
</ul>
<p>Команда <code>mul</code> имеет только один операнд. Второй сомножитель задаётся неявно. Он находится в регистре <code>%eax</code>, и его размер выбирается в зависимости от суффикса команды (<code>b</code>, <code>w</code> или <code>l</code>). Место размещения результата также зависит от суффикса команды. Нужно отметить, что результат умножения двух <img class="mwe-math-fallback-image-inline tex" alt="n" src="./Ассемблер в Linux для программистов C — Викиучебник_files/7b8b965ad4bca0e41ab51de7b31363a1.png">-разрядных чисел может уместиться только в <img class="mwe-math-fallback-image-inline tex" alt="2n" src="./Ассемблер в Linux для программистов C — Викиучебник_files/21e2c0c0472b331622877accbe29b91b.png">-разрядном регистре результата. В следующей таблице описано, в какие регистры попадает результат при той или иной разрядности операндов.</p>
<table class="standard">
<tbody><tr>
<th>Команда</th>
<th>Второй сомножитель</th>
<th>Результат</th>
</tr>
<tr>
<td><code>mulb</code></td>
<td><code>%al</code></td>
<td>16 бит: <code>%ax</code></td>
</tr>
<tr>
<td><code>mulw</code></td>
<td><code>%ax</code></td>
<td>32 бита: младшая часть в <code>%ax</code>, старшая в <code>%dx</code></td>
</tr>
<tr>
<td><code>mull</code></td>
<td><code>%eax</code></td>
<td>64 бита: младшая часть в <code>%eax</code>, старшая в <code>%edx</code></td>
</tr>
</tbody></table>
<p>Примеры:</p>
<pre>.text
        movl  $72, %eax
        incl  %eax              /* в %eax число 73                   */
        decl  %eax              /* в %eax число 72                   */
 
        movl  $48, %eax
        addl  $16, %eax         /* в %eax число 64                   */
 
        movb  $5, %al
        movb  $5, %bl
        mulb  %bl               /* в регистре %ax произведение 
                                   %al × %bl = 25                    */
</pre>
<p>Давайте подумаем, каким будет результат выполнения следующего кода на Си:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="kt">char</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
<p>Большинство сразу скажет, что результат (250 + 14 = 264) больше, чем может поместиться в одном байте. И что же напечатает программа? 8. Давайте рассмотрим, что происходит при сложении в двоичной системе.</p>
<pre>  11111010       250
+ 00001110      + 14
----------       ---
1 00001000       264
 |        |
 |&lt;------&gt;|
    8 бит
</pre>
<p>Получается, что результат занимает 9 бит, а в переменную может поместиться только 8 бит. Это называется переполнением — перенос из старшего бита результата. В Си переполнение не может быть перехвачено, но в микропроцессоре эта ситуация регистрируется, и её можно обработать. Когда происходит переполнение, устанавливается флаг <code>cf</code>. Команды условного перехода <code>jc</code> и <code>jnc</code> анализируют состояние этого флага. Команды условного перехода будут рассмотрены далее, здесь эта информация приводится для полноты описания команд.</p>
<pre>        movb  $0,   %ah         /* %ah = 0                           */
        movb  $250, %al         /* %al = 250                         */
        addb  $14,  %al         /* %al = %al + 14 
                                   происходит переполнение, 
                                   устанавливается флаг cf;
                                   в %al число 8                     */
        jnc   no_carry          /* если переполнения не было, перейти 
                                   на метку                          */
        movb  $1,   %ah         /* %ah = 1                           */
no_carry:
        /* %ax = 264 = 0x0108 */
</pre>
<p>Этот код выдаёт правильную сумму в регистре <code>%ax</code> с учётом переполнения, если оно произошло. Попробуйте поменять числа в строках 2 и 3.</p>
<h4><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.B0_lea_.D0.B4.D0.BB.D1.8F_.D0.B0.D1.80.D0.B8.D1.84.D0.BC.D0.B5.D1.82.D0.B8.D0.BA.D0.B8">Команда <code>lea</code> для арифметики</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=29" title="Редактировать раздел «Команда lea для арифметики»">править</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Для выполнения некоторых арифметических операций можно использовать команду <code>lea</code><sup id="cite_ref-3" class="reference"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#cite_note-3">[3]</a></sup>. Она вычисляет адрес своего операнда-источника и помещает этот адрес в операнд-назначение. Ведь она не производит чтение памяти по этому адресу, верно? А значит, всё равно, что она будет вычислять: адрес или какие-то другие числа.</p>
<p>Вспомним, как формируется адрес операнда:</p>
<pre> <i>смещение</i>(<i>база</i>, <i>индекс</i>, <i>множитель</i>)
</pre>
<p>Вычисленный адрес будет равен <i>база</i> + <i>индекс</i> × <i>множитель</i> + <i>смещение</i>.</p>
<p>Чем это нам удобно? Так мы можем получить команду с двумя операндами-источниками и одним результатом:</p>
<pre>movl  $10, %eax
movl  $7, %ebx
 
leal  5(%eax)       ,%ecx  /* %ecx = %eax + 5 = 15                   */
leal  -3(%eax)      ,%ecx  /* %ecx = %eax - 3 = 7                    */
leal  (%eax,%ebx)   ,%ecx  /* %ecx = %eax + %ebx × 1 = 17            */
leal  (%eax,%ebx,2) ,%ecx  /* %ecx = %eax + %ebx × 2 = 24            */
leal  1(%eax,%ebx,2),%ecx  /* %ecx = %eax + %ebx × 2 + 1 = 25        */
leal  (,%eax,8)     ,%ecx  /* %ecx = %eax × 8 = 80                   */
leal  (%eax,%eax,2) ,%ecx  /* %ecx = %eax + %eax × 2 = %eax × 3 = 30 */
leal  (%eax,%eax,4) ,%ecx  /* %ecx = %eax + %eax × 4 = %eax × 5 = 50 */
leal  (%eax,%eax,8) ,%ecx  /* %ecx = %eax + %eax × 8 = %eax × 9 = 90 */
</pre>
<p>Вспомните, что при сложении командой <code>add</code> результат записывается на место одного из слагаемых. Теперь, наверно, стало ясно главное преимущество <code>lea</code> в тех случаях, где её можно применить: она не перезаписывает операнды-источники. Как вы это сможете использовать, зависит только от вашей фантазии: прибавить константу к регистру и записать в другой регистр, сложить два регистра и записать в третий… Также <code>lea</code> можно применять для умножения регистра на 3, 5 и 9, как показано выше.</p>
<h3><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D0.B0_loop">Команда <code>loop</code></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=30" title="Редактировать раздел «Команда loop»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Синтаксис:</p>
<pre> loop  <i>метка</i>
</pre>
<p>Принцип работы:</p>
<ul>
<li>уменьшить значение регистра <code>%ecx</code> на 1;</li>
<li>если <code>%ecx</code> = 0, передать управление следующей за <code>loop</code> команде;</li>
<li>если <code>%ecx</code> ≠ 0, передать управление на <i>метку</i>.</li>
</ul>
<p>Напишем программу для вычисления суммы чисел от 1 до 10 (конечно же, воспользовавшись формулой суммы арифметической прогрессии, можно переписать этот код и без цикла — но ведь это только пример).</p>
<pre>.data
printf_format:
        .string "%d\n"
 
.text
.globl main
main:
        movl  $0, %eax          /* в %eax будет результат, поэтому в 
                                   начале его нужно обнулить         */
        movl  $10, %ecx         /* 10 шагов цикла                    */
 
sum:
        addl  %ecx, %eax        /* %eax = %eax + %ecx                */
        loop  sum
 
        /* %eax = 55, %ecx = 0 */
 
/*
 * следующий код выводит число в %eax на экран и завершает программу
 */
        pushl %eax
        pushl $printf_format
        call  printf
        addl  $8, %esp
 
        movl  $0, %eax
        ret
</pre>
<p>На Си это выглядело бы так:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ecx</span><span class="p">;</span>
  <span class="n">eax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">ecx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">do</span>
  <span class="p">{</span>
    <span class="n">eax</span> <span class="o">+=</span> <span class="n">ecx</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="n">ecx</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">eax</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h3><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.B0.D0.BD.D0.B4.D1.8B_.D1.81.D1.80.D0.B0.D0.B2.D0.BD.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B8_.D1.83.D1.81.D0.BB.D0.BE.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BF.D0.B5.D1.80.D0.B5.D1.85.D0.BE.D0.B4.D1.8B._.D0.91.D0.B5.D0.B7.D1.83.D1.81.D0.BB.D0.BE.D0.B2.D0.BD.D1.8B.D0.B9_.D0.BF.D0.B5.D1.80.D0.B5.D1.85.D0.BE.D0.B4">Команды сравнения и условные переходы. Безусловный переход</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=31" title="Редактировать раздел «Команды сравнения и условные переходы. Безусловный переход»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Команда <code>loop</code> неявно сравнивает регистр <code>%ecx</code> с нулём. Это довольно удобно для организации циклов, но часто циклы бывают намного сложнее, чем те, что можно записать при помощи <code>loop</code>. К тому же нужен эквивалент конструкции <code>if(){}</code>. Вот команды, позволяющие выполнять произвольные сравнения операндов:</p>
<pre> cmp   <i>операнд_2</i>, <i>операнд_1</i>
</pre>
<p>Команда <code>cmp</code> выполняет вычитание <code><i>операнд_1</i> – <i>операнд_2</i></code> и устанавливает флаги. Результат вычитания нигде не запоминается.</p>
<p><br></p>
<table class="metadata plainlinks ambox ambox-style">
<tbody><tr>
<td class="ambox-image">
<div><a href="https://ru.wikibooks.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:Nuvola_apps_important_yellow.svg" class="image" title="⚠"><img alt="⚠" src="./Ассемблер в Linux для программистов C — Викиучебник_files/50px-Nuvola_apps_important_yellow.svg.png" width="50" height="42" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Nuvola_apps_important_yellow.svg/75px-Nuvola_apps_important_yellow.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Nuvola_apps_important_yellow.svg/100px-Nuvola_apps_important_yellow.svg.png 2x" data-file-width="600" data-file-height="500"></a></div>
</td>
<td class="ambox-text"><b>Внимание!</b> Обратите внимание на порядок операндов в записи команды: сначала второй, потом первый.</td>
<td class="widthhack"></td>
</tr>
</tbody></table>
<p>Сравнили, установили флаги, — и что дальше? А у нас есть целое семейство <code>jump</code>-команд, которые передают управление другим командам. Эти команды называются командами условного перехода. Каждой из них поставлено в соответствие условие, которое она проверяет. Синтаксис:</p>
<pre> jcc   <i>метка</i>
</pre>
<p>Команды <code>jcc</code> не существует, вместо <code>cc</code> нужно подставить мнемоническое обозначение условия.</p>
<table class="standard">
<tbody><tr>
<th>Мнемоника</th>
<th>Английское слово</th>
<th>Смысл</th>
<th>Тип операндов</th>
</tr>
<tr>
<td><code>e</code></td>
<td>equal</td>
<td>равенство</td>
<td>любые</td>
</tr>
<tr>
<td><code>n</code></td>
<td>not</td>
<td>инверсия условия</td>
<td>любые</td>
</tr>
<tr>
<td><code>g</code></td>
<td>greater</td>
<td>больше</td>
<td>со знаком</td>
</tr>
<tr>
<td><code>l</code></td>
<td>less</td>
<td>меньше</td>
<td>со знаком</td>
</tr>
<tr>
<td><code>a</code></td>
<td>above</td>
<td>больше</td>
<td>без знака</td>
</tr>
<tr>
<td><code>b</code></td>
<td>below</td>
<td>меньше</td>
<td>без знака</td>
</tr>
</tbody></table>
<p>Таким образом, <code>je</code> проверяет равенство операндов команды сравнения, <code>jl</code> проверяет условие <code><i>операнд_1</i> &lt; <i>операнд_2</i></code> и так далее. У каждой команды есть противоположная: просто добавляем букву <code>n</code>:</p>
<ul>
<li><code>je</code> — <code>jne</code>: равно — не равно;</li>
<li><code>jg</code> — <code>jng</code>: больше — не больше.</li>
</ul>
<p>Теперь пример использования этих команд:</p>
<pre>.text
        /* Тут пропущен код, который получает некоторое значение в %eax.
           Пусть нас интересует случай, когда %eax = 15 */

        cmpl  $15, %eax         /* сравнение                         */
        jne   not_equal        /* если операнды не равны, перейти на 
                                   метку not_equal                   */
 
        /* сюда управление перейдёт только в случае, когда переход не 
           сработал, а значит, %eax = 15 */
 
not_equal:
        /* а сюда управление перейдёт в любом случае */
</pre>
<p>Сравните с кодом на Си:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="k">if</span><span class="p">(</span><span class="n">eax</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* сюда управление перейдёт только в случае, когда переход не сработал,</span>
<span class="cm">     а значит, %eax = 15 */</span>
<span class="p">}</span>
<span class="cm">/* а сюда управление перейдёт в любом случае */</span>
</pre></div>
<p>Кроме команд условного перехода, область применения которых ясна сразу, также существует команда безусловного перехода. Эта команда чем-то похожа на оператор <code>goto</code> языка Си. Синтаксис:</p>
<pre> jmp   <i>адрес</i>
</pre>
<p>Эта команда передаёт управление на <i>адрес</i>, не проверяя никаких условий. Заметьте, что <i>адрес</i> может быть задан в виде непосредственного значения (метки), регистра или обращения к памяти.</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B8.D0.B7.D0.B2.D0.BE.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D1.86.D0.B8.D0.BA.D0.BB.D1.8B">Произвольные циклы</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=32" title="Редактировать раздел «Произвольные циклы»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Все инструкции для написания произвольных циклов мы уже рассмотрели, осталось лишь собрать всё воедино. Лучше сначала посмотрите код программы, а потом объяснение к ней. Прочитайте её код и комментарии и попытайтесь разобраться, что она делает. Если сразу что-то непонятно — не страшно, сразу после исходного кода находится более подробное объяснение.</p>
<h4><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0:_.D0.BF.D0.BE.D0.B8.D1.81.D0.BA_.D0.BD.D0.B0.D0.B8.D0.B1.D0.BE.D0.BB.D1.8C.D1.88.D0.B5.D0.B3.D0.BE_.D1.8D.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.B0_.D0.B2_.D0.BC.D0.B0.D1.81.D1.81.D0.B8.D0.B2.D0.B5">Программа: поиск наибольшего элемента в массиве</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=33" title="Редактировать раздел «Программа: поиск наибольшего элемента в массиве»">править</a><span class="mw-editsection-bracket">]</span></span></h4>
<pre>.data
printf_format:
        .string "%d\n"
 
array:
        .long -10, -15, -148, 12, -151, -3, -72
array_end:
 
.text
.globl main
main:
        movl  array, %eax         /* в %eax будет храниться результат;
                                   в начале наибольшее значение — array[0]*/
        movl  $array+4, %ebx      /* в %ebx находится адрес текущего 
                                   элемента массива                  */
        jmp   ch_bound          /* проверить границы массива */
loop_start:                     /* начало цикла                      */
        cmpl  %eax, (%ebx)      /* сравнить текущий элемент массива с 
                                   текущим наибольшим значением из %eax
                                                                     */
        jle   less              /* если текущий элемент массива меньше 
                                   или равен наибольшему, пропустить 
                                   следующий код                     */
        movl  (%ebx), %eax      /* а вот если элемент массива 
                                   превосходит наибольший, значит, его 
                                   значение и есть новый максимум    */
less:
        addl  $4, %ebx          /* увеличить %ebx на размер одного 
                                   элемента массива, 4 байта         */
ch_bound:
        cmpl  $array_end, %ebx  /* сравнить адрес текущего элемента и 
                                   адрес конца массива               */
        jne    loop_start        /* если они не равны, повторить цикл снова* 
/*
 * следующий код выводит число из %eax на экран и завершает программу
 */
        pushl %eax
        pushl $printf_format
        call  printf
        addl  $8, %esp
 
        movl  $0, %eax
        ret
</pre>
<p>Сначала мы заносим в регистр <code>%eax</code> число array[0]. После этого мы сравниваем каждый элемент массива, начиная со следующего (нам незачем сранивать нулевой элемент с самим собой), с текущим наибольшим значением из <code>%eax</code>, и, если этот элемент больше, он становится текущим наибольшим. После просмотра всего массива в <code>%eax</code> находится наибольший элемент. Отметим, что если массив состоит из 1 элемента, то следующий после нулевого элемента будет находиться за границей массива, поэтому перед циклом стоит безусловный переход на проверку границы.</p>
<p>Этот код соответствует приблизительно следующему на Си:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="o">-</span><span class="mi">148</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">151</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">72</span> <span class="p">};</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="o">*</span><span class="n">array_end</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)];</span>
  <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">array</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
 
  <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">array_end</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">max</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">p</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Возможно, такой способ обхода массива не очень привычен для вас. В Си принято использовать переменную с номером текущего элемента, а не указатель на него. Никто не запрещает пойти этим же путём и на ассемблере:</p>
<pre>.data
printf_format:
        .string "%d\n"
 
array:
        .long 10, 15, 148, -3, 151, 3, 72
array_size:
        .long (. - array)/4  /* количество элементов массива */
 
.text
.globl main
main:
        movl  array, %eax          /* в %eax будет храниться результат;
                                   в начале наибольшее значение — array[0]  */
        movl  $1, %ecx            /* начать просмотр с первого элемента 
                                                                     */
        jmp   ch_bound
loop_start:                     /* начало цикла                      */
        cmpl  %eax, array(,%ecx,4)  /* сравнить текущий элемент 
                                   массива с текущим наибольшим 
                                   значением из %eax                 */
        jle   less              /* если текущий элемент массива меньше 
                                   или равен наибольшему, пропустить 
                                   следующий код                     */
        movl  array(,%ecx,4), %eax  /* а вот если элемент массива 
                                   превосходит наибольший, значит, его 
                                   значение и есть новый максимум    */
less:
        incl  %ecx              /* увеличить на 1 номер текущего 
                                   элемента                          */
ch_bound:
        cmpl  array_size, %ecx  /* сравнить номер текущего элемента с 
                                   общим числом элементов            */
        jne    loop_start       /* если они не равны, повторить цикл снова */

/*
 * следующий код выводит число в %eax на экран и завершает программу
 */
        pushl %eax
        pushl $printf_format
        call  printf
        addl  $8, %esp
 
        movl $0, %eax
        ret
</pre>
<p>Рассматривая код этой программы, вы, наверно, уже поняли, как создавать произвольные циклы с постусловием на ассемблере, наподобие <code>do{} while();</code> в Си. Ещё раз повторю эту конструкцию, выкинув весь код, не относящийся к циклу:</p>
<pre>
loop_start:                    /* начало цикла                      */
 
        /* вот тут находится тело цикла */
 
        cmpl  ...              /* что-то с чем-то сравнить для 
                                  принятия решения о выходе из цикла */
        jne    loop_start      /* подобрать соответствующую команду 
                                  условного перехода для повторения цикла     */           
</pre>
<p>В Си есть ещё один вид цикла, с проверкой условия перед входом в тело цикла (цикл с предусловием): <code>while(){}</code>. Немного изменив предыдущий код, получаем следующее:</p>
<pre>
        jmp    check
loop_start:                    /* начало цикла                      */
 
        /* вот тут находится тело цикла */
 
check:
        cmpl  ...              /* что-то с чем-то сравнить для 
                                  принятия решения о выходе из цикла */
        jne    loop_start      /* подобрать соответствующую команду 
                                  условного перехода для повторения цикла     */           
</pre>
<p>Кто-то скажет: а ещё есть цикл <code>for()</code>! Но цикл</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="k">for</span><span class="p">(</span><span class="n">init</span><span class="p">;</span> <span class="n">cond</span><span class="p">;</span> <span class="n">incr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">body</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>эквивалентен такой конструкции:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="n">init</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">body</span><span class="p">;</span>
  <span class="n">incr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Таким образом, нам достаточно и уже рассмотренных двух видов циклов.</p>
<h3><span class="mw-headline" id=".D0.9B.D0.BE.D0.B3.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B0.D1.8F_.D0.B0.D1.80.D0.B8.D1.84.D0.BC.D0.B5.D1.82.D0.B8.D0.BA.D0.B0">Логическая арифметика</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=34" title="Редактировать раздел «Логическая арифметика»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Кроме выполнения обычных арифметических вычислений, можно проводить и логические, то есть битовые.</p>
<pre> and   <i>источник</i>, <i>приёмник</i>
 or    <i>источник</i>, <i>приёмник</i>
 xor   <i>источник</i>, <i>приёмник</i>
 not   <i>операнд</i>
 test  <i>операнд_1</i>, <i>операнд_2</i>
</pre>
<p>Команды <code>and</code>, <code>or</code> и <code>xor</code> ведут себя так же, как и операторы языка Си <code>&amp;</code>, <code>|</code>, <code>^</code>. Эти команды устанавливают флаги согласно результату.</p>
<p>Команда <code>not</code> инвертирует каждый бит операнда (изменяет на противоположный), так же как и оператор языка Си <code>~</code>.</p>
<p>Команда <code>test</code> выполняет побитовое И над операндами, как и команда <code>and</code>, но, в отличие от неё, операнды не изменяет, а только устанавливает флаги. Её также называют командой логического сравнения, потому что с её помощью удобно проверять, установлены ли определённые биты. Например, так:</p>
<pre>        testb $0b00001000, %al  /* установлен ли 3-й (с нуля) бит?   */
        je    not_set
        /* нужные биты установлены */
not_set:
        /* биты не установлены */
</pre>
<p>Обратите внимание на запись константы в двоичной системе счисления: используется префикс <code>0b</code>.</p>
<p>Команду <code>test</code> можно применять для сравнения значения регистра с нулём:</p>
<pre>        testl %eax, %eax
        je    is_zero
        /* %eax != 0 */
is_zero:
        /* %eax == 0 */
</pre>
<p>Intel Optimization Manual рекомендует использовать <code>test</code> вместо <code>cmp</code> для сравнения регистра с нулём<sup id="cite_ref-4" class="reference"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#cite_note-4">[4]</a></sup>.</p>
<p>Ещё следует упомянуть об одном трюке с <code>xor</code>. Как вы знаете, a XOR a = 0. Пользуясь этой особенностью, <code>xor</code> часто применяют для обнуления регистров:</p>
<pre>xorl  %eax, %eax
/* теперь %eax == 0 */
</pre>
<p>Почему применяют <code>xor</code> вместо <code>mov</code>? Команда <code>xor</code> короче, а значит, занимает меньше места в процессорном кэше, меньше времени тратится на декодирование, и программа выполняется быстрее. Но эта команда устанавливает флаги. Поэтому, если вам нужно сохранить состояние флагов, применяйте <code>mov</code><sup id="cite_ref-5" class="reference"><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#cite_note-5">[5]</a></sup>.</p>
<p>Иногда для обнуления регистра применяют команду <code>sub</code>. Помните, она тоже устанавливает флаги.</p>
<pre>subl  %eax, %eax
/* теперь %eax == 0 */
</pre>
<p>К логическим командам также можно отнести команды сдвигов:</p>
<pre> /* Shift Arithmetic Left/SHift logical Left */
 sal/shl <i>количество_сдвигов</i>, <i>назначение</i>

 /* SHift logical Right */
 shr     <i>количество_сдвигов</i>, <i>назначение</i> 

 /* Shift Arithmetic Right */
 sar     <i>количество_сдвигов</i>, <i>назначение</i>
</pre>
<p><i>количество_сдвигов</i> может быть задано непосредственным значением или находиться в регистре <code>%cl</code>. Учитываются только младшие 5 бит регистра <code>%cl</code>, так что количество сдвигов может варьироваться в пределах от 0 до 31.</p>
<p>Принцип работы команды <code>shl</code>:</p>
<pre>                              До сдвига:
          +---+     +----------------------------------+
          | ? |     | 10001000100010001000100010001011 |
          +---+     +----------------------------------+
         Флаг CF    Операнд
 
                       Сдвиг влево на 1 бит:
          +---+     +----------------------------------+
          | 1 | &lt;-- | 00010001000100010001000100010110 | &lt;-- 0
          +---+     +----------------------------------+
         Флаг CF    Операнд
 
                      Сдвиг влево на 3 бита:
 +----+   +---+     +----------------------------------+
 | 10 |   | 0 | &lt;-- | 01000100010001000100010001011000 | &lt;-- 000
 +----+   +---+     +----------------------------------+
Улетели  Флаг CF    Операнд
в никуда
</pre>
<p>Принцип работы команды <code>shr</code>:</p>
<pre>                  До сдвига:
        +----------------------------------+     +---+
        | 10001000100010001000100010001011 |     | ? |
        +----------------------------------+     +---+
        Операнд                                  Флаг CF

          Логический сдвиг вправо на 1 бит:
        +----------------------------------+     +---+
  0 --&gt; | 01000100010001000100010001000101 | --&gt; | 1 |
        +----------------------------------+     +---+
        Операнд                                 Флаг CF

          Логический сдвиг вправо на 3 бита:
        +----------------------------------+     +---+  +----+
000 --&gt; | 00010001000100010001000100010001 | --&gt; | 0 |  | 11 |
        +----------------------------------+     +---+  +----+
        Операнд                                 Флаг CF Улетели
                                                        в никуда
</pre>
<p>Эти две команды называются командами логического сдвига, потому что они работают с операндом как с массивом бит. Каждый «выдвигаемый» бит попадает в флаг <code>cf</code>, причём с другой стороны операнда «вдвигается» бит 0. Таким образом, в флаге <code>cf</code> оказывается самый последний «выдвинутый» бит. Такое поведение вполне допустимо для работы с беззнаковыми числами, но числа со знаком будут обработаны неверно из-за того, что знаковый бит может быть потерян.</p>
<p>Для работы с числами со знаком существуют команды арифметического сдвига. Команды <code>shl</code> и <code>sal</code> выполняют полностью идентичные действия, так как при сдвиге влево знаковый бит не теряется (расширение знакового бита влево становится новым знаковым битом). Для сдвига вправо применяется команда <code>sar</code>. Она «вдвигает» слева знаковый бит исходного значения, таким образом сохраняя знак числа:</p>
<pre>                  До сдвига:
        +----------------------------------+     +---+
        | 10001000100010001000100010001011 |     | ? |
        +----------------------------------+     +---+
        Операнд                                  Флаг CF
        старший бит равен 1 ==&gt;
          ==&gt; значение отрицательное ==&gt;
          ==&gt; "вдвинуть" бит 1 ---+
                                  |
  +-------------------------------+
  |
  V       Арифметический сдвиг вправо на 1 бит:
        +----------------------------------+     +---+
  1 --&gt; | 11000100010001000100010001000101 | --&gt; | 1 |
        +----------------------------------+     +---+
        Операнд                                 Флаг CF

          Арифметический сдвиг вправо на 3 бита:
        +----------------------------------+     +---+  +----+
111 --&gt; | 11110001000100010001000100010001 | --&gt; | 0 |  | 11 |
        +----------------------------------+     +---+  +----+
        Операнд                                 Флаг CF Улетели
                                                        в никуда
</pre>
<p>Многие программисты Си знают об умножении и делении на степени двойки (2, 4, 8…) при помощи сдвигов. Этот трюк отлично работает и в ассемблере, используйте его для оптимизации.</p>
<p>Кроме сдвигов обычных, существуют циклические сдвиги:</p>
<pre> /* ROtate Right */
 ror   <i>количество_сдвигов</i>, <i>назначение</i>

 /* ROtate Left */
 rol   <i>количество_сдвигов</i>, <i>назначение</i>
</pre>
<p>Объясню на примере циклического сдвига влево на три бита: три старших («левых») бита «выдвигаются» из регистра влево и «вдвигаются» в него справа. При этом в флаг <code>cf</code> записывается самый последний «выдвинутый» бит.</p>
<p>Принцип работы команды <code>rol</code>:</p>
<pre>                              До сдвига:
      +---+         +----------------------------------+
      | ? |         | 10001000100010001000100010001011 |
      +---+         +----------------------------------+
     Флаг CF        Операнд
 
                      Циклический сдвиг влево на 1 бит:
      +---+  1    1 +----------------------------------+
      | 1 | &lt;--+--- | 00010001000100010001000100010111 | ---+
      +---+    |    +----------------------------------+    |
     Флаг CF   V    Операнд                                 ^
               |                                            |
               +-------------------&gt;---&gt;---&gt;----------------+
                1
 
                      Циклический сдвиг влево на 3 бита:
      +---+  0  100 +----------------------------------+
      | 0 | &lt;--+--- | 01000100010001000100010001011100 | ---+
      +---+    |    +----------------------------------+    |
     Флаг CF   V    Операнд                                 ^
               |                                            |
               +-------------------&gt;---&gt;---&gt;----------------+
                100
</pre>
<p>Принцип работы команды <code>ror</code>:</p>
<pre>                  До сдвига:
        +----------------------------------+         +---+
        | 10001000100010001000100010001011 |         | ? |
        +----------------------------------+         +---+
        Операнд                                     Флаг CF

          Циклический сдвиг вправо на 1 бит:
        +----------------------------------+ 1    1  +---+
   +--- | 11000100010001000100010001000101 | ---+--&gt; | 1 |
   |    +----------------------------------+    |    +---+
   ^    Операнд                                 V   Флаг CF
   |                                            |
   +-------------------&lt;---&lt;---&lt;----------------+
                                               1

          Циклический сдвиг вправо на 3 бита:
        +----------------------------------+ 011  0  +---+
   +--- | 01110001000100010001000100010001 | ---+--&gt; | 0 |
   |    +----------------------------------+    |    +---+
   ^    Операнд                                 V   Флаг CF
   |                                            |
   +-------------------&lt;---&lt;---&lt;----------------+
                                             011
</pre>
<p>Существует ещё один вид сдвигов — циклический сдвиг через флаг <code>cf</code>. Эти команды рассматривают флаг <code>cf</code> как продолжение операнда.</p>
<pre> /* Rotate through Carry Right */
 rcr   <i>количество_сдвигов</i>, <i>назначение</i> 

 /* Rotate through Carry Left */
 rcl   <i>количество_сдвигов</i>, <i>назначение</i>
</pre>
<p>Принцип работы команды <code>rcl</code>:</p>
<pre>                              До сдвига:
         +---+      +----------------------------------+
         | X |      | 10001000100010001000100010001011 |
         +---+      +----------------------------------+
        Флаг CF     Операнд
 
                      Циклический сдвиг влево через CF на 1 бит:
      X  +---+      +----------------------------------+
    +-&lt;- | 1 | &lt;--- | 0001000100010001000100010001011X | ---+
    |    +---+      +----------------------------------+    |
    V   Флаг CF     Операнд                                 ^
    |                                                       |
    +------------------------------&gt;---&gt;---&gt;----------------+
 
                      Циклический сдвиг влево через CF на 3 бита:
     X10 +---+      +----------------------------------+
    +-&lt;- | 0 | &lt;--- | 01000100010001000100010001011X10 | ---+
    |    +---+      +----------------------------------+    |
    V   Флаг CF     Операнд                                 ^
    |                                                       |
    +------------------------------&gt;---&gt;---&gt;----------------+
</pre>
<p>Принцип работы команды <code>rcr</code>:</p>
<pre>                   До сдвига:
         +----------------------------------+      +---+
         | 10001000100010001000100010001011 |      | X |
         +----------------------------------+      +---+
         Операнд                                  Флаг CF
 
           Циклический сдвиг вправо через CF на 1 бит:
         +----------------------------------+      +---+  X
    +--- | X1000100010001000100010001000101 | ---&gt; | 1 | -&gt;-+
    |    +----------------------------------+      +---+    |
    ^    Операнд                                  Флаг CF   V
    |                                                       |
    +-------------------&lt;---&lt;---&lt;---------------------------+
 
           Циклический сдвиг вправо через CF на 3 бита:
         +----------------------------------+      +---+ 11X
    +--- | 11X10001000100010001000100010001 | ---&gt; | 0 | -&gt;-+
    |    +----------------------------------+      +---+    |
    ^    Операнд                                  Флаг CF   V
    |                                                       |
    +-------------------&lt;---&lt;---&lt;---------------------------+
</pre>
<p>Эти сложные циклические сдвиги вам редко понадобятся в реальной работе, но уже сейчас нужно знать, что такие инструкции существуют, чтобы не изобретать велосипед потом. Ведь в языке Си циклический сдвиг производится приблизительно так:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x11223344</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">shift_count</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">shift_count</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">shift_count</span><span class="p">));</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h3><span class="mw-headline" id=".D0.9F.D0.BE.D0.B4.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D1.8B">Подпрограммы</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=35" title="Редактировать раздел «Подпрограммы»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Термином «подпрограмма» будем называть и функции, которые возвращают значение, и функции, не возвращающие значение (<code>void proc(…)</code>). Подпрограммы нужны для достижения одной простой цели — избежать дублирования кода. В ассемблере есть две команды для организации работы подпрограмм.</p>
<pre>call  <i>метка</i>
</pre>
<p>Используется для вызова подпрограммы, код которой находится по адресу <i>метка</i>. Принцип работы:</p>
<ul>
<li>Поместить в стек адрес следующей за <code>call</code> команды. Этот адрес называется адресом возврата.</li>
<li>Передать управление на метку.</li>
</ul>
<p>Для возврата из подпрограммы используется команда <code>ret</code>.</p>
<pre>ret
ret   <i>число</i>
</pre>
<p>Принцип работы:</p>
<ul>
<li>Извлечь из стека новое значение регистра <code>%eip</code> (то есть передать управление на команду, расположенную по адресу из стека).</li>
<li>Если команде передан операнд <i>число</i>, <code>%esp</code> увеличивается на это число. Это необходимо для того, чтобы подпрограмма могла убрать из стека свои параметры.</li>
</ul>
<p>Существует несколько способов передачи аргументов в подпрограмму.</p>
<ul>
<li><b>При помощи регистров.</b> Перед вызовом подпрограммы вызывающий код помещает необходимые данные в регистры. У этого способа есть явный недостаток: число регистров ограничено, соответственно, ограничено и максимальное число передаваемых параметров. Также, если передать параметры почти во всех регистрах, подпрограмма будет вынуждена сохранять их в стек или память, так как ей может не хватить регистров для собственной работы. Несомненно, у этого способа есть и преимущество: доступ к регистрам очень быстрый.</li>
<li><b>При помощи общей области памяти.</b> Это похоже на глобальные переменные в Си. Современные рекомендации написания кода (а часто и стандарты написания кода в больших проектах) запрещают этот метод. Он не поддерживает многопоточное выполнение кода. Он использует глобальные переменные неявным образом — смотря на определение функции типа <code>void func(void)</code> невозможно сказать, какие глобальные переменные она изменяет и где ожидает свои параметры. Вряд ли у этого метода есть преимущества. Не используйте его без крайней необходимости.</li>
<li><b>При помощи стека.</b> Это самый популярный способ. Вызывающий код помещает аргументы в стек, а затем вызывает подпрограмму.</li>
</ul>
<p>Рассмотрим передачу аргументов через стек подробнее. Предположим, нам нужно написать подпрограмму, принимающую три аргумента типа <code>long</code> (4 байта). Код:</p>
<pre>sub:
        pushl %ebp              /* запоминаем текущее значение 
                                   регистра %ebp, при этом %esp -= 4 */
        movl  %esp, %ebp        /* записываем текущее положение 
                                   вершины стека в %ebp              */
 
        /* пролог закончен, можно начинать работу */
 
        subl  $8, %esp          /* зарезервировать место для локальных 
                                   переменных                        */
 
 
        movl  8(%ebp),  %eax    /* что-то cделать с параметрами      */
        movl  12(%ebp), %eax
        movl  16(%ebp), %eax
 
 
        /* эпилог */
 
        movl  %ebp, %esp        /* возвращем вершину стека в исходное 
                                   положение                         */
        popl  %ebp              /* восстанавливаем старое значение 
                                   %ebp, при этом %esp += 4          */
        ret
 
main:
        pushl $0x00000010       /* поместить параметры в стек        */
        pushl $0x00000020
        pushl $0x00000030
        call  sub               /* вызвать подпрограмму              */
        addl  $12, %esp
</pre>
<p>С вызовом всё ясно: помещаем аргументы в стек и даём команду <code>call</code>. А вот как в подпрограмме удобно достать параметры из стека? Вспомним про регистр <code>%ebp</code>.</p>
<p>Мы сохраняем предыдущее значение регистра <code>%ebp</code>, а затем записываем в него указатель на текущую вершину стека. Теперь у нас есть указатель на стек в известном состоянии. Сверху в стек можно помещать сколько угодно данных, <code>%esp</code> поменяется, но у нас останется доступ к параметрам через <code>%ebp</code>. Часто эта последовательность команд в начале подпрограммы называется «прологом».</p>
<pre>.                      .
.                      .
.                      .
+----------------------+ 0x0000F040 &lt;-- новое значение %ebp
| старое значение %ebp |
+----------------------+ 0x0000F044 &lt;-- %ebp + 4
|    адрес возврата    |
+----------------------+ 0x0000F048 &lt;-- %ebp + 8
|      0x00000030      |
+----------------------+ 0x0000F04C &lt;-- %ebp + 12
|      0x00000020      |
+----------------------+ 0x0000F050 &lt;-- %ebp + 16
|      0x00000010      |
+----------------------+ 0x0000F054
.                      .
.                      .
.                      .
</pre>
<p>Используя адрес из <code>%ebp</code>, мы можем ссылаться на параметры:</p>
<pre> 8(%ebp) = 0x00000030
12(%ebp) = 0x00000020
16(%ebp) = 0x00000010
</pre>
<p>Как видите, если идти от вершины стека в сторону аргументов, то мы будем встречать аргументы в обратном порядке по отношению к тому, как их туда поместили. Нужно сделать одно из двух: или помещать аргументы в обратном порядке (чтобы доставать их в прямом порядке), или учитывать обратный порядок аргументов в подпрограмме. В Си принято при вызове помещать аргументы в обратном порядке. Так как операционная система Linux и большинство библиотек для неё написаны именно на Си, для обеспечения переносимости и совместимости лучше использовать «сишный» способ передачи аргументов и в ваших ассемблерных программах.</p>
<p>Подпрограмме могут понадобится собственные локальные переменные. Их принято держать в стеке, так как в этом случае легко обеспечить необходимое время жизни локальных переменных: достаточно в конце подпрограммы вытолкнуть их из стека. Для того, чтобы зарезервировать для них место, мы просто уменьшим содержимое регистра <code>%esp</code> на размер наших переменных. Это действие эквивалентно использованию соответствующего количества команд <code>push</code>, только быстрее, так как не требует записи в память. Предположим, что нам нужно 2 переменные типа <code>long</code> (4 байта), итого 2 × 4 = 8 байт. Таким образом, регистр <code>%esp</code> нужно уменьшить на 8. Теперь стек выглядит так:</p>
<pre>.                        .
.                        .
.                        .
+------------------------+ 0x0000F038 &lt;-- %ebp - 8
| локальная переменная 2 |
+------------------------+ 0x0000F03C &lt;-- %ebp - 4
| локальная переменная 1 |
+------------------------+ 0x0000F040 &lt;-- %ebp
|  старое значение %ebp  |
+------------------------+ 0x0000F044 &lt;-- %ebp + 4
|     адрес возврата     |
+------------------------+ 0x0000F048 &lt;-- %ebp + 8
|       0x00000030       |
+------------------------+ 0x0000F04C &lt;-- %ebp + 12
|       0x00000020       |
+------------------------+ 0x0000F050 &lt;-- %ebp + 16
|       0x00000010       |
+------------------------+ 0x0000F054
.                        .
.                        .
.                        .
</pre>
<p>Вы не можете делать никаких предположений о содержимом локальных переменных. Никто их для вас не инициализировал нулём. Можете для себя считать, что там находятся случайные значения.</p>
<p>При возврате из процедуры мы восстанавливаем старое значение <code>%ebp</code> из стека, потому что после возврата вызывающая функция вряд ли будет рада найти в регистре <code>%ebp</code> неизвестно что (а если серьёзно, этого требует ABI). Для этого необходимо, чтобы старое значение <code>%ebp</code> было на вершине стека. Если подпрограмма что-то поместила в стек после старого <code>%ebp</code>, она должна это убрать. К счастью, мы не должны считать, сколько байт мы поместили, сколько достали и сколько ещё осталось. Мы можем просто поместить значение регистра <code>%ebp</code> в регистр <code>%esp</code>, и стек станет точно таким же, как и после сохранения старого <code>%ebp</code> в начале подпрограммы. После этого команда <code>ret</code> возвращает управление вызывающему коду. Эта последовательность команд часто называется «эпилогом» подпрограммы.</p>
<table class="metadata plainlinks ambox ambox-style">
<tbody><tr>
<td class="ambox-image">
<div><a href="https://ru.wikibooks.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:Nuvola_apps_important_yellow.svg" class="image" title="⚠"><img alt="⚠" src="./Ассемблер в Linux для программистов C — Викиучебник_files/50px-Nuvola_apps_important_yellow.svg.png" width="50" height="42" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Nuvola_apps_important_yellow.svg/75px-Nuvola_apps_important_yellow.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Nuvola_apps_important_yellow.svg/100px-Nuvola_apps_important_yellow.svg.png 2x" data-file-width="600" data-file-height="500"></a></div>
</td>
<td class="ambox-text"><b>Внимание!</b> Сразу после того, как вы восстановили значение <code>%esp</code> в эпилоге, вы должны считать, что локальные переменные уничтожены. Хотя они ещё не перезаписаны, они, несомненно, будут затёрты последующими командами <code>push</code>, поэтому вы не должны сохранять указатели на локальные переменные дальше эпилога своей функции.</td>
<td class="widthhack"></td>
</tr>
</tbody></table>
<p>Остаётся одна маленькая проблема: в стеке всё ещё находятся аргументы для подпрограммы. Это можно решить одним из следующих способов:</p>
<ul>
<li>использовать команду <code>ret</code> с аргументом;</li>
<li>использовать необходимое число раз команду <code>pop</code> и выбросить результат;</li>
<li>увеличить <code>%esp</code> на размер всех помещенных в стек параметров.</li>
</ul>
<p>В Си используется последний способ. Так как мы поместили в стек 3 значения типа <code>long</code> по 4 байта каждый, мы должны увеличить <code>%esp</code> на 12, что и делает команда <code>addl</code> сразу после <code>call</code>.</p>
<p>Заметьте, что не всегда обязательно выравнивать стек. Если вы вызываете несколько подпрограмм подряд (но не в цикле!), то можно разрешить аргументам «накопиться» в стеке, а потом убрать их всех одной командой. Если ваша подпрограмма не содержит вызовов других подпрограмм в цикле и вы уверены, что оставшиеся аргументы в стеке не вызовут проблем переполнения стека, то аргументы можно не убирать вообще. Всё равно это сделает команда эпилога, которая восстанавливает <code>%esp</code> из <code>%ebp</code>. С другой стороны, если не уверены — лучше уберите аргументы, от одной лишней команды программа медленнее не станет.</p>
<p>Строго говоря, все эти действия с <code>%ebp</code> не требуются. Вы можете использовать <code>%ebp</code> для хранения своих значений, никак не связанных со стеком, но тогда вам придётся обращаться к аргументам и локальным переменным через <code>%esp</code> или другие регистры, в которые вы поместите указатели. Трюк состоит в том, чтобы не изменять <code>%esp</code> после резервирования места для локальных переменных и до конца функции: так вы сможете использовать <code>%esp</code> на манер <code>%ebp</code>, как было показано выше. Не изменять <code>%esp</code> значит, что вы не сможете использовать <code>push</code> и <code>pop</code> (иначе все смещения переменных в стеке относительно <code>%esp</code> «поплывут»); вам понадобится создать необходимое число локальных переменных для хранения этих временных значений. С одной стороны, этот способ доступа к переменным немного сложнее, так как вы должны заранее просчитать, сколько места в стеке вам понадобится. С другой стороны, у вас появляется еще один свободный регистр <code>%ebp</code>. Так что если вы решите пойти этой дорогой, вы должны заранее продумать, сколько места для локальных переменных вам понадобится, и дальше обращаться к ним через смещения относительно <code>%esp</code>.</p>
<p>И последнее: если вы хотите использовать вашу подпрограмму за пределами данного файла, не забудьте сделать её глобальной с помощью директивы <code>.globl</code>.</p>
<p>Посмотрим на код, который выводил содержимое регистра <code>%eax</code> на экран, вызывая функцию стандартной библиотеки Си <code>printf(3)</code>. Вы его уже видели в предыдущих программах, но там он был приведен без объяснений. Для справки привожу цитату из <code>man</code>:</p>
<pre>PRINTF(3)            Linux Programmer's Manual            PRINTF(3)
 
NAME
       printf - formatted output conversion
 
SYNOPSIS
       #include &lt;stdio.h&gt;
 
       int printf(const char *format, ...);
</pre>
<pre>.data
printf_format:
        .string "%d\n"
 
.text
        /* printf(printf_format, %eax); */
        pushl %eax              /* аргумент, подлежащий печати       */
        pushl $printf_format    /* аргумент format                   */
        call  printf            /* вызов printf()                    */
        addl  $8, %esp          /* выровнять стек                    */
</pre>
<p>Обратите внимание на обратный порядок аргументов и очистку стека от аргументов.</p>
<table class="metadata plainlinks ambox ambox-style">
<tbody><tr>
<td class="ambox-image">
<div><a href="https://ru.wikibooks.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:Nuvola_apps_important_yellow.svg" class="image" title="⚠"><img alt="⚠" src="./Ассемблер в Linux для программистов C — Викиучебник_files/50px-Nuvola_apps_important_yellow.svg.png" width="50" height="42" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Nuvola_apps_important_yellow.svg/75px-Nuvola_apps_important_yellow.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Nuvola_apps_important_yellow.svg/100px-Nuvola_apps_important_yellow.svg.png 2x" data-file-width="600" data-file-height="500"></a></div>
</td>
<td class="ambox-text"><b>Внимание!</b> Значения регистров глобальны, вызывающая и вызываемая подпрограммы видят одни и те же регистры. Конечно же, подпрограмма может изменять значения любых пользовательских регистров, но она обязана при возврате восстановить значения регистров <code>%ebp</code>, <code>%ebx</code>, <code>%esi</code>, <code>%edi</code> и <code>%esp</code>. Сохранение остальных регистров перед вызовом подпрограммы — задача программиста. Даже если вы заметили, что подпрограмма не изменяет какой-то регистр, это не повод его не сохранять. Ведь неизвестно, как будут обстоять дела в следующей версии подпрограммы. Вы не должны делать каких-либо предположений о состоянии регистров на момент выхода из подпрограммы. Можете считать, что они содержат случайные значения.
<p>Также внимания требует флаг <code>df</code>. При вызове подпрограмм флаг должен быть равен 0. Подпрограмма при возврате также должна установить флаг в 0. Коротко: если вам вдруг нужно установить этот флаг для какой-то операции, сбросьте его сразу, как только надобность в нём исчезнет.</p>
</td>
<td class="widthhack"></td>
</tr>
</tbody></table>
<p>До этого момента мы обходились общим термином «подпрограмма». Но если подпрограмма — функция, она должна как-то передать возвращаемое значение. Это принято делать при помощи регистра <code>%eax</code>. Перед началом эпилога функция должна поместить в <code>%eax</code> возвращаемое значение.</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0:_.D0.BF.D0.B5.D1.87.D0.B0.D1.82.D1.8C_.D1.82.D0.B0.D0.B1.D0.BB.D0.B8.D1.86.D1.8B_.D1.83.D0.BC.D0.BD.D0.BE.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F">Программа: печать таблицы умножения</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=36" title="Редактировать раздел «Программа: печать таблицы умножения»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Рассмотрим программу посложнее. Итак, программа для печати таблицы умножения. Размер таблицы умножения вводит пользователь. Нам понадобится вызвать функцию <code>scanf(3)</code> для ввода, <code>printf(3)</code> для вывода и организовать два вложенных цикла для вычислений.</p>
<pre>.data
input_prompt:
        .string "enter size (1-255): "
 
scanf_format:
        .string "%d"
 
printf_format:
        .string "%5d "
 
printf_newline:
        .string "\n"
 
size:
        .long 0
 
.text
.globl main
main:
        /* запросить у пользователя размер таблицы */
        pushl $input_prompt     /* format                            */
        call  printf            /* вызов printf                      */
 
        /* считать размер таблицы в переменную size */
        pushl $size             /* указатель на переменную size      */
        pushl $scanf_format     /* format                            */
        call  scanf             /* вызов scanf                       */
 
        addl  $12, %esp         /* выровнять стек одной командой сразу 
                                   после двух функций                */
 
        movl  $0, %eax          /* в регистре %ax команда mulb будет 
                                   выдавать результат, но мы печатаем 
                                   всё содержимое %eax, поэтому два 
                                   старших байта %eax должны быть 
                                   нулевыми                          */
 
        movl  $0, %ebx          /* номер строки                      */
 
print_line:
        incl  %ebx              /* увеличить номер строки на 1       */
        cmpl  size, %ebx
        ja    print_line_end    /* если номер строки больше 
                                   запрошенного размера, завершить цикл
                                                                     */
 
        movl  $0, %ecx          /* номер колонки                     */
 
print_num:
        incl  %ecx              /* увеличить номер колонки на 1      */
        cmpl  size, %ecx
        ja    print_num_end     /* если номер колонки больше 
                                   запрошенного размера, завершить цикл
                                                                     */
 
        movb  %bl, %al          /* команда mulb ожидает второй 
                                   операнд в %al                     */
        mulb  %cl               /* вычислить %ax = %cl * %al         */
 
        pushl %ebx              /* сохранить используемые регистры 
                                   перед вызовом printf              */
        pushl %ecx
 
        pushl %eax              /* данные для печати                 */
        pushl $printf_format    /* format                            */
        call  printf            /* вызов printf                      */
        addl  $8, %esp          /* выровнять стек                    */
 
        popl  %ecx              /* восстановить регистры             */
        popl  %ebx
 
        jmp   print_num         /* перейти в начало цикла            */
print_num_end:
 
        pushl %ebx              /* сохранить регистр                 */
 
        pushl $printf_newline   /* напечатать символ новой строки    */
        call  printf
        addl  $4, %esp
 
        popl  %ebx              /* восстановить регистр              */
 
        jmp   print_line        /* перейти в начало цикла            */
print_line_end:
 
        movl  $0, %eax          /* завершить программу               */
        ret
</pre>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0:_.D0.B2.D1.8B.D1.87.D0.B8.D1.81.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.84.D0.B0.D0.BA.D1.82.D0.BE.D1.80.D0.B8.D0.B0.D0.BB.D0.B0">Программа: вычисление факториала</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=37" title="Редактировать раздел «Программа: вычисление факториала»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Теперь напишем рекурсивную функцию для вычисления факториала. Она основана на следующей формуле: <img class="mwe-math-fallback-image-inline tex" alt="0! = 1, \quad n! = n \cdot (n-1)!" src="./Ассемблер в Linux для программистов C — Викиучебник_files/293a4acf99ccacb903b8e03ba84c5af9.png"></p>
<pre>.data
printf_format:
        .string "%d\n"
 
.text
/* int factorial(int) */
factorial:
        pushl %ebp
        movl  %esp, %ebp
 
        /* извлечь аргумент в %eax */
        movl  8(%ebp), %eax
 
        /* факториал 0 равен 1 */
        cmpl  $0, %eax
        jne   not_zero
 
        movl  $1, %eax
        jmp   return
not_zero:
 
        /* следующие 4 строки вычисляют выражение
           %eax = factorial(%eax - 1) */
 
        decl  %eax
        pushl %eax
        call  factorial
        addl  $4, %esp
 
        /* извлечь в %ebx аргумент и вычислить %eax = %eax * %ebx */
 
        movl  8(%ebp), %ebx
        mull  %ebx
 
        /* результат в паре %edx:%eax, но старшие 32 бита нужно 
           отбросить, так как они не помещаются в int */
 
return:
        movl  %ebp, %esp
        popl  %ebp
        ret
 
.globl main
main:
        pushl %ebp
        movl  %esp, %ebp
 
        pushl $5
        call  factorial
 
        pushl %eax
        pushl $printf_format
        call  printf
 
        /* стек можно не выравнивать, это будет сделано
           во время выполнения эпилога */
 
        movl  $0, %eax                  /* завершить программу */
 
        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
<p>Любой программист знает, что если существует очевидное итеративное (реализуемое при помощи циклов) решение задачи, то именно ему следует отдавать предпочтение перед рекурсивным. Итеративный алгоритм нахождения факториала даже проще, чем рекурсивный; он следует из определения факториала: <img class="mwe-math-fallback-image-inline tex" alt="n! = 1 \cdot 2 \cdot \ldots \cdot n" src="./Ассемблер в Linux для программистов C — Викиучебник_files/0f9db30666fbef7b633ff71b49096000.png"></p>
<p>Говоря проще, нужно перемножить все числа от 1 до <img class="mwe-math-fallback-image-inline tex" alt="n" src="./Ассемблер в Linux для программистов C — Викиучебник_files/7b8b965ad4bca0e41ab51de7b31363a1.png">.</p>
<p>Функция — на то и функция, что её можно заменить, при этом не изменяя вызывающий код. Для запуска следующего кода просто замените функцию из предыдущей программы вот этой новой версией:</p>
<pre>factorial:
        movl  4(%esp), %ecx
 
        cmpl  $0, %ecx
        jne   not_zero
 
        movl  $1, %eax
        ret
 
not_zero:
 
        movl  $1, %eax
loop_start:
        mull  %ecx
        loop  loop_start
 
        ret
</pre>
<p>Что же здесь изменено? Рекурсия переписана в виде цикла. Кадр стека больше не нужен, так как в стек ничего не перемещается и другие функции не вызываются. Пролог и эпилог поэтому убраны, при этом регистр <code>%ebp</code> не используется вообще. Но если бы он использовался, сначала нужно было бы сохранить его значение, а перед возвратом восстановить.</p>
<p>Автор увлёкся процессом и написал 64-битную версию этой функции. Она возвращает результат в паре <code>%eax:%edx</code> и может вычислить <img class="mwe-math-fallback-image-inline tex" alt="20! = 2432902008176640000" src="./Ассемблер в Linux для программистов C — Викиучебник_files/9171204a2ee73154cd6c63128c855b41.png">.</p>
<pre>.data
printf_format:
        .string "%llu\n"
 
.text
.type   factorial, @function    /* long long int factorial(int)      */
factorial:
        movl  4(%esp), %ecx
 
        cmpl  $0, %ecx
        jne   not_zero
 
        movl  $1, %eax
        ret
 
not_zero:
 
        movl  $1, %esi          /* младшие 32 бита                   */
        movl  $0, %edi          /* старшие 32 бита                   */
loop_start:
        movl  %esi, %eax        /* загрузить младшие биты для 
                                   умножения                         */
        mull  %ecx              /* %eax:%edx = младшие биты * %ecx   */
        movl  %eax, %esi        /* записать младшие биты 
                                   обратно в %esi                    */
 
        movl  %edi, %eax        /* загрузить старшие биты            */
        movl  %edx, %edi        /* записать в %edi старшие биты 
                                   предыдущего умножения; теперь 
                                   результат умножения младших битов 
                                   находится в %esi:%edi, а старшие 
                                   биты — в %eax для следующего 
                                   умножения                         */
        mull  %ecx              /* %eax:%edx = старшие биты * %ecx   */
        addl  %eax, %edi        /* сложить полученный результат со 
                                   старшими битами предыдущего 
                                   умножения                         */
 
        loop  loop_start
 
        movl  %esi, %eax        /* результат вернуть в паре          */
        movl  %edi, %edx        /* %eax:%edx                         */
 
        ret
.size   factorial, .-factorial
 
.globl main
main:
        pushl %ebp
        movl  %esp, %ebp
 
        pushl $20
        call  factorial
 
        pushl %edx
        pushl %eax
        pushl $printf_format
        call  printf
 
        /* стек можно не выравнивать, это будет сделано во время 
           выполнения эпилога */
 
        movl  $0, %eax          /* завершить программу               */
 
        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
<p>Умножение 64-битного числа на 32-битное делается как при умножении «в столбик»:</p>
<pre>     %edi       %esi
×               %ecx
---------------------
%edi×%ecx  %esi×%ecx
    A           |
   /|\          |
    +--&lt;--&lt;--&lt;--+
   старшие 32 бита
</pre>
<p>Но произведение <code>%esi</code> × <code>%ecx</code> не поместится в 32 бита, останутся ещё старшие 32 бита. Их мы должны прибавить к старшим 32-м битам результата. Приблизительно так вы это делаете на бумаге в десятичной системе:</p>
<pre>  2  5      25 × 3 = 75
×    3
  ----
    15
+ 6
  ----
  7  5
</pre>
<p>Задание: напишите программу-считалочку. Есть числа от 0 до <img class="mwe-math-fallback-image-inline tex" alt="m" src="./Ассемблер в Linux для программистов C — Викиучебник_files/6f8f57715090da2632453988d9a1501b.png">, которые располагаются по кругу. Счёт начинается с элемента 0. Каждый <img class="mwe-math-fallback-image-inline tex" alt="n" src="./Ассемблер в Linux для программистов C — Викиучебник_files/7b8b965ad4bca0e41ab51de7b31363a1.png">-й элемент удаляют. Счёт продолжается с элемента, следующего за удалённым. Напишите программу, выводящую список вычеркнутых элементов. Подсказка: используйте <code>malloc(3)</code> для получения <img class="mwe-math-fallback-image-inline tex" alt="m + 1" src="./Ассемблер в Linux для программистов C — Викиучебник_files/c2ae2329632cc86715f8a4de7a056880.png"> байт памяти и занесите в каждый байт число 1 при помощи <code>memset(3)</code>. Значение 1 означает, что элемент существует, значением 0 отмечайте удалённые элементы. При счете пропускайте удалённые элементы.</p>
<h3><span class="mw-headline" id=".D0.A1.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.BD.D1.8B.D0.B5_.D0.B2.D1.8B.D0.B7.D0.BE.D0.B2.D1.8B">Системные вызовы</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=38" title="Редактировать раздел «Системные вызовы»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Программа, которая не взаимодействует с внешним миром, вряд ли может сделать что-то полезное. Вывести сообщение на экран, прочитать данные из файла, установить сетевое соединение — это всё примеры действий, которые программа не может совершить без помощи операционной системы. В Linux пользовательский интерфейс ядра организован через системные вызовы. Системный вызов можно рассматривать как функцию, которую для вас выполняет операционная система.</p>
<p>Теперь наша задача состоит в том, чтобы разобраться, как происходит системный вызов. Каждый системный вызов имеет свой номер. Все они перечислены в файле <code>/usr/include/asm-i386/unistd.h</code>.</p>
<p>Системные вызовы считывают свои параметры из регистров. Номер системного вызова нужно поместить в регистр <code>%eax</code>. Параметры помещаются в остальные регистры в таком порядке:</p>
<ol>
<li>первый — в <code>%ebx</code>;</li>
<li>второй — в <code>%ecx</code>;</li>
<li>третий — в <code>%edx</code>;</li>
<li>четвертый — в <code>%esi</code>;</li>
<li>пятый — в <code>%edi</code>;</li>
<li>шестой — в <code>%ebp</code>.</li>
</ol>
<p>Таким образом, используя все регистры общего назначения, можно передать максимум 6 параметров. Системный вызов производится вызовом прерывания <code>0x80</code>. Такой способ вызова (с передачей параметров через регистры) называется <code>fastcall</code>. В других системах (например, <a href="https://ru.wikipedia.org/wiki/BSD" class="extiw" title="w:BSD">*BSD</a>) могут применяться другие способы вызова.</p>
<p>Следует отметить, что не следует использовать системные вызовы везде, где только можно, без особой необходимости. В разных версиях ядра порядок аргументов у некоторых системных вызовов может отличаться, и это приводит к ошибкам, которые довольно трудно найти. Поэтому стоит использовать функции стандартной библиотеки Си, ведь их сигнатуры не изменяются, что обеспечивает переносимость кода на Си. Почему бы нам не воспользоваться этим и не «заложить фундамент» переносимости наших ассемблерных программ? Только если вы пишете маленький участок самого нагруженного кода и для вас недопустимы накладные расходы, вносимые вызовом стандартной библиотеки Си, — только тогда стоит использовать системные вызовы напрямую.</p>
<p>В качестве примера можете посмотреть код программы Hello world.</p>
<h3><span class="mw-headline" id=".D0.A1.D1.82.D1.80.D1.83.D0.BA.D1.82.D1.83.D1.80.D1.8B">Структуры</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=39" title="Редактировать раздел «Структуры»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Объявляя структуры в Си, вы не задумывались о том, как располагаются в памяти её элементы. В ассемблере понятия «структура» нет, зато есть «блок памяти», его адрес и смещение в этом блоке. Объясню на примере:</p>
<table class="standard">
<tbody><tr>
<td><code>0x23</code></td>
<td><code>0x72</code></td>
<td><code>0x45</code></td>
<td><code>0x17</code></td>
</tr>
</tbody></table>
<p>Пусть этот блок памяти размером 4 байта расположен по адресу <code>0x00010000</code>. Это значит, что адрес байта <code>0x23</code> равен <code>0x00010000</code>. Соответственно, адрес байта <code>0x72</code> равен <code>0x00010001</code>. Говорят, что байт <code>0x72</code> расположен по смещению 1 от начала блока памяти. Тогда байт <code>0x45</code> расположен по смещению 2, а байт <code>0x17</code> — по смещению 3. Таким образом, адрес элемента = базовый адрес + смещение.</p>
<p>Приблизительно так в ассемблере организована работа со структурами: к базовому адресу структуры прибавляется смещение, по которому находится нужный элемент. Теперь вопрос: как определить смещение? В Си компилятор руководствуется следующими правилами:</p>
<ul>
<li>Вся структура должна быть выровнена так, как выровнен её элемент с наибольшим выравниванием.</li>
<li>Каждый элемент находится по наименьшему следующему адресу с подходящим выравниванием. Если необходимо, для этого в структуру включается нужное число байт-заполнителей.</li>
<li>Размер структуры должен быть кратен её выравниванию. Если необходимо, для этого в конец структуры включается нужное число байт-заполнителей.</li>
</ul>
<p>Примеры (внизу указано смещение элементов в байтах; заполнители обозначены <code>XX</code>):</p>
<pre>struct     Выравнивание структуры: 1, размер: 1
{          +----+
  char c;  | c  |
};         +----+
           0

struct     Выравнивание структуры: 2, размер: 4
{          +----+----+----+----+
  char c;  | c  | XX |    s    |
  short s; +----+----+----+----+
};          0         2

struct     Выравнивание структуры: 4, размер: 8
{          +----+----+----+----+----+----+----+----+
  char c;  | с  | XX   XX   XX |         i         |
  int i;   +----+----+----+----+----+----+----+----+
};          0                   4

struct     Выравнивание структуры: 4, размер: 8
{          +----+----+----+----+----+----+----+----+
  int i;   |         i         | c  | XX   XX   XX |
  char c;  +----+----+----+----+----+----+----+----+
};          0                   4

struct     Выравнивание структуры: 4, размер: 12
{          +----+----+----+----+----+----+----+----+----+----+----+----+
  char c;  | c  | XX   XX   XX |         i         |    s    | XX   XX |
  int i;   +----+----+----+----+----+----+----+----+----+----+----+----+
  short s;  0                   4                   8
};

struct     Выравнивание структуры: 4, размер: 8
{          +----+----+----+----+----+----+----+----+
  int i;   |         i         | c  | XX |    s    |
  char c;  +----+----+----+----+----+----+----+----+
  short s;  0                   4         6
};
</pre>
<p>Обратите внимание на два последних примера: элементы структур одни и те же, только расположены в разном порядке. Но размер структур получился разный!</p>
<h4><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0:_.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4_.D1.80.D0.B0.D0.B7.D0.BC.D0.B5.D1.80.D0.B0_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0">Программа: вывод размера файла</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=40" title="Редактировать раздел «Программа: вывод размера файла»">править</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Напишем программу, которая выводит размер файла. Для этого потребуется вызвать функцию <code>stat(2)</code> и прочитать данные из структуры, которую она заполнит. <code>man 2 stat</code>:</p>
<pre>STAT(2)                  Системные вызовы                  STAT(2)
 
ИМЯ
       stat, fstat, lstat - получить статус файла
 
КРАТКАЯ СВОДКА
       #include &lt;sys/types.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;unistd.h&gt;
 
       int stat(const char *file_name, struct stat *buf);
 
ОПИСАНИЕ
       stat возвращает информацию о файле, заданном с помощью 
       file_name, и заполняет буфер buf.
 
       Все эти функции возвращают структуру stat, которая содержит 
       такие поля:
 
          struct stat {
              dev_t         st_dev;     /* устройство                */
              ino_t         st_ino;     /* индексный дескриптор      */
              mode_t        st_mode;    /* режим доступа             */
              nlink_t       st_nlink;   /* количество жестких ссылок */
              uid_t         st_uid;     /* идентификатор 
                                           пользователя-владельца    */
              gid_t         st_gid;     /* идентификатор 
                                           группы-владельца          */
              dev_t         st_rdev;    /* тип устройства (если это 
                                           устройство)               */
              off_t         st_size;    /* общий размер в байтах     */
              unsigned long st_blksize; /* размер блока ввода-вывода */
                                        /* в файловой системе        */
              unsigned long st_blocks;  /* количество выделенных 
                                           блоков                    */
              time_t        st_atime;   /* время последнего доступа  */
              time_t        st_mtime;   /* время последнего 
                                           изменения                 */
              time_t        st_ctime;   /* время последней смены 
                                           состояния                 */
          };
</pre>
<p>Так, теперь осталось только вычислить смещение поля <code>st_size</code>… Но что это за типы — <code>dev_t</code>, <code>ino_t</code>? Какого они размера? Следует заглянуть в заголовочный файл и узнать, что обозначено при помощи <code>typedef</code>. Я сделал так:</p>
<pre>[user@host:~]$ cpp /usr/include/sys/types.h | less
</pre>
<p>Далее, ищу в выводе препроцессора определение <code>dev_t</code>, нахожу:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="k">typedef</span> <span class="n">__dev_t</span> <span class="kt">dev_t</span><span class="p">;</span>
</pre></div>
<p>Ищу <code>__dev_t</code>:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="n">__extension__</span> <span class="k">typedef</span> <span class="n">__u_quad_t</span> <span class="n">__dev_t</span><span class="p">;</span>
</pre></div>
<p>Ищу <code>__u_quad_t</code>:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="n">__extension__</span> <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">__u_quad_t</span><span class="p">;</span>
</pre></div>
<p>Значит, <code>sizeof(dev_t)</code> = 8.</p>
<p>Мы бы могли и дальше продолжать искать, но в реальности всё немного по-другому. Если вы посмотрите на определение <code>struct stat</code> (<code>cpp /usr/include/sys/stat.h | less</code>), вы увидите поля с именами <code>__pad1</code>, <code>__pad2</code>, <code>__unused4</code> и другие (зависит от системы). Эти поля не используются, они нужны для совместимости, и поэтому в <code>man</code> они не описаны. Так что самый верный способ не ошибиться — это просто попросить компилятор Си посчитать это смещение для нас (вычитаем из адреса поля адрес структуры, получаем смещение):</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">stat</span> <span class="n">t</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof = %zu, offset = %td</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
         <span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
         <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">st_size</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>На моей системе программа напечатала <code>sizeof = 88, offset = 44</code>. На вашей системе это значение может отличаться по описанным причинам. Теперь у нас есть все нужные данные об этой структуре, пишем программу:</p>
<pre>.data
str_usage:
        .string "usage: %s filename\n"
 
printf_format:
        .string "%u\n"
 
.text
.globl main
main:
        pushl %ebp
        movl  %esp, %ebp
 
        subl  $88, %esp         /* выделить 88 байт под struct stat  */
 
        cmpl  $2, 8(%ebp)       /* argc == 2?                        */
        je    args_ok
                                /* программе передали не 2 аргумента, 
                                   вывести usage                     */
        movl  12(%ebp), %ebx    /* поместить в %ebx адрес массива argv 
                                                                     */
        pushl (%ebx)            /* argv[0]                           */
        pushl $str_usage
        call  printf
 
        movl  $1, %eax          /* выйти с кодом 1                   */
        jmp   return
 
args_ok:
        leal  -88(%ebp), %ebx   /* поместить адрес структуры в 
                                   регистр %ebx                      */
        pushl %ebx
 
        movl  12(%ebp), %ecx    /* поместить в %ecx адрес массива argv 
                                                                     */
        pushl 4(%ecx)           /* argv[1] — имя файла               */
        call  stat
 
        cmpl  $0, %eax          /* stat() вернул 0?                  */
        je    stat_ok
 
        /* stat() вернул ошибку, нужно вызвать perror(argv[1]) и 
           завершить программу */
 
        movl  12(%ebp), %ecx
        pushl 4(%ecx)
        call  perror
 
        movl  $1, %eax
        jmp   return
 
stat_ok:
        pushl 44(%ebx)          /* нужное нам поле по смещению 44    */
        pushl $printf_format
        call  printf
 
        movl  $0, %eax          /* выйти с кодом 0                   */
 
return:
        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
<p>Обратите внимание на обработку ошибок: если передано не 2 аргумента — выводим описание использования программы и выходим, если <code>stat(2)</code> вернул ошибку — выводим сообщение об ошибке и выходим.</p>
<p>Наверное, могут возникнуть некоторые сложности с пониманием, как расположены <code>argc</code> и <code>argv</code> в стеке. Допустим, вы запустили программу как</p>
<pre>[user@host:~]$ ./program test-file
</pre>
<p>Тогда стек будет выглядеть приблизительно так:</p>
<pre>.                        .
.                        .
.                        .
+------------------------+ 0x0000EFE4 &lt;-- %ebp - 88
|       struct stat      |
+------------------------+ 0x0000F040 &lt;-- %ebp
|  старое значение %ebp  |
+------------------------+ 0x0000F044 &lt;-- %ebp + 4
|     адрес возврата     |
+------------------------+ 0x0000F048 &lt;-- %ebp + 8
|          argc          |
+------------------------+ 0x0000F04C &lt;-- %ebp + 12
|  указатель на argv[0]  | ---------------------------- 
+------------------------+ 0x0000F050 &lt;-- %ebp + 16   | 
.                        .              --------------- 
.                        .              | 
.                        .              V 
                                 +-------------+        +-------------+
                                 | argv[0]     | -----&gt; | "./program" |
                                 +-------------+        +-------------+
                                 | argv[1]     | -\
                                 +-------------+   \    +-------------+
                                 | argv[2] = 0 |    \-&gt; | "test-file" |
                                 +-------------+        +-------------+
</pre>
<p>Таким образом, в стек помещается два параметра: <code>argc</code> и указатель на первый элемент массива <code>argv[]</code>. Где-то в памяти расположен блок из трёх указателей: указатель на строку <code>"./program"</code>, указатель на строку <code>"test-file"</code> и указатель <code>NULL</code>. Нам в стеке передали адрес этого блока памяти.</p>
<h4><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0:_.D0.BF.D0.B5.D1.87.D0.B0.D1.82.D1.8C_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0_.D0.BD.D0.B0.D0.BE.D0.B1.D0.BE.D1.80.D0.BE.D1.82">Программа: печать файла наоборот</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=41" title="Редактировать раздел «Программа: печать файла наоборот»">править</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Напишем программу, которая читает со стандартного ввода всё до конца файла, а потом выводит введённые строки в обратном порядке. Для этого мы во время чтения будем помещать строки в связный список, а потом пройдем этот список в обратном порядке и напечатаем строки.</p>
<table class="metadata plainlinks ambox ambox-style">
<tbody><tr>
<td class="ambox-image">
<div><a href="https://ru.wikibooks.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:Nuvola_apps_important_yellow.svg" class="image" title="⚠"><img alt="⚠" src="./Ассемблер в Linux для программистов C — Викиучебник_files/50px-Nuvola_apps_important_yellow.svg.png" width="50" height="42" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Nuvola_apps_important_yellow.svg/75px-Nuvola_apps_important_yellow.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Nuvola_apps_important_yellow.svg/100px-Nuvola_apps_important_yellow.svg.png 2x" data-file-width="600" data-file-height="500"></a></div>
</td>
<td class="ambox-text"><b>Внимание!</b> Сохраните исходный код этой программы в файл с расширением <code>.S</code> — S в верхнем регистре.</td>
<td class="widthhack"></td>
</tr>
</tbody></table>
<pre>.data
printf_format:
        .string "&lt;%s&gt;\n"

#define READ_CHUNK 128

.text

/* char *read_str(int *is_eof) */
read_str:
        pushl %ebp
        movl  %esp, %ebp

        pushl %ebx              /* сохранить регистры                */
        pushl %esi
        pushl %edi

        movl  $0,   %ebx        /* прочитано байт                    */
        movl  $READ_CHUNK, %edi /* размер буфера                     */
        pushl %edi
        call  malloc
        addl  $4, %esp          /* убрать аргументы                  */
        movl  %eax, %esi        /* указатель на начало буфера        */
        decl  %edi              /* в конце должен быть нулевой байт, 
                                   зарезервировать место для него    */

        pushl stdin             /* fgetc() всегда будет вызываться с 
                                   этим аргументом                   */

1: /* read_start */
        call  fgetc             /* прочитать 1 символ                */
        cmpl  $0xa, %eax        /* новая строка '\n'?                */
        je    2f                /* read_end                          */
        cmpl  $-1, %eax         /* конец файла?                      */
        je    4f                /* eof_yes                           */
        movb  %al, (%esi,%ebx,1)  /* записать прочитанный символ в 
                                   буфер                             */
        incl  %ebx              /* инкрементировать счётчик 
                                   прочитанных байт                  */
        cmpl  %edi, %ebx        /* буфер заполнен?                   */
        jne   1b                /* read_start                        */

        addl  $READ_CHUNK, %edi /* увеличить размер буфера           */
        pushl %edi              /* размер                            */
        pushl %esi              /* указатель на буфер                */
        call  realloc
        addl  $8, %esp          /* убрать аргументы                  */
        movl  %eax, %esi        /* результат в %eax — новый указатель 
                                                                     */
        jmp   1b                /* read_start                        */
2: /* read_end */

3: /* eof_no */
        movl  8(%ebp), %eax     /* *is_eof = 0                       */
        movl  $0, (%eax)
        jmp   5f                /* eof_end                           */
4: /* eof_yes */
        movl  8(%ebp), %eax     /* *is_eof = 1                       */
        movl  $1, (%eax)
5: /* eof_end */

        movb  $0, (%esi,%ebx,1) /* записать в конец буфера '\0'      */

        movl  %esi, %eax        /* результат в %eax                  */

        addl  $4, %esp          /* убрать аргумент fgetc()           */

        popl  %edi              /* восстановить регистры             */
        popl  %esi              
        popl  %ebx

        movl  %ebp, %esp
        popl  %ebp
        ret

/*
struct list_node
{
  struct list_node *prev;
  char *str;
};
*/

.globl main
main:
        pushl %ebp
        movl  %esp, %ebp

        subl  $4, %esp          /* int is_eof;                       */

        movl  $0, %edi          /* в %edi будет храниться указатель на 
                                   предыдущую структуру              */

1: /* read_start */
        leal  -4(%ebp), %eax    /* %eax = &amp;is_eof;                   */
        pushl %eax
        call  read_str
        movl  %eax, %esi        /* указатель на прочитанную строку 
                                   поместить в %esi                  */

        pushl $8                /* выделить 8 байт под структуру     */
        call  malloc

        movl  %edi, (%eax)      /* указатель на предыдущую структуру */
        movl  %esi, 4(%eax)     /* указатель на строку               */

        movl  %eax, %edi        /* теперь эта структура — предыдущая */

        addl  $8, %esp          /* убрать аргументы                  */

        cmpl  $0, -4(%ebp)      /* is_eof == 0?                      */
        jne   2f
        jmp   1b
2: /* read_end */


3: /* print_start */
                                /* просматривать список в обратном 
                                   порядке, так что в %edi адрес 
                                   текущей структуры                 */
        pushl 4(%edi)           /* указатель на строку из текущей 
                                   структуры                         */
        pushl $printf_format
        call  printf            /* вывести на экран                  */

        addl  $4, %esp          /* убрать из стека только 
                                   $printf_format                    */
        call  free              /* освободить память, занимаемую 
                                   строкой                           */

        pushl %edi              /* указатель на структуру для 
                                   освобождения памяти               */
        movl  (%edi), %edi      /* заменить указатель в %edi на 
                                   следующий                         */
        call  free              /* освободить память, занимаемую 
                                   структурой                        */

        addl  $8, %esp          /* убрать аргументы                  */

        cmpl  $0, %edi          /* адрес новой структуры == NULL?    */
        je    4f
        jmp   3b
4: /* print_end */

        movl  $0, %eax          /* выйти с кодом 0                   */

return:
        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
<table style="margin: 1em 2.5% 0 2.5%; padding: 0 10px; border: 1px solid #aaa;">
<tbody><tr>
<td style="width:42px;text-align:center"><a href="https://ru.wikibooks.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:Information_icon.svg" class="image" title="Информация"><img alt="Информация" src="./Ассемблер в Linux для программистов C — Викиучебник_files/32px-Information_icon.svg.png" width="32" height="32" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/3/35/Information_icon.svg/48px-Information_icon.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/35/Information_icon.svg/64px-Information_icon.svg.png 2x" data-file-width="620" data-file-height="620"></a></td>
<td style="vertical-align:middle">
<p>Для того, чтобы послать с клавиатуры сигнал о конце файла, нажмите Ctrl-D.</p>
</td>
</tr>
</tbody></table>
<pre>[user@host:~]$ gcc print.S -o print
[user@host:~]$ ./print
aaa
bbbb
ccccc
^D&lt;&gt;
&lt;ccccc&gt;
&lt;bbbb&gt;
&lt;aaa&gt;
</pre>
<p>Обратите внимание, что мы ввели 4 строки: <code>"aaa"</code>, <code>"bbbb"</code>, <code>"ccccc"</code>, <code>""</code>.</p>
<p>В этой программе был использован некоторый новый синтаксис. Во-первых, вы видите директиву препроцессора <code>#define</code>. Препроцессор Си (cpp) может быть использован для обработки исходного кода на ассемблере: нужно всего лишь использовать расширение <code>.S</code> для файла с исходным кодом. Файлы с таким расширением gcc предварительно обрабатывает препроцессором cpp, после чего компилирует как обычно.</p>
<p>Во-вторых, были использованы метки-числа, причём некоторые из них повторяются в двух функциях. Почему бы не использовать текстовые метки, как в предыдущих примерах? Можно, но они должны быть уникальными. Например, если бы мы определили метку <code>read_start</code> и в функции <code>read_str</code>, и в <code>main</code>, GCC бы выдал ошибку при компиляции:</p>
<pre>[user@host:~]$ gcc print.S
print.S: Assembler messages:
print.S:85: Error: symbol `read_start' is already defined
</pre>
<p>Поэтому, используя текстовые метки, приходится каждый раз придумывать уникальное имя. А можно использовать метки-числа, компилятор преобразует их в уникальные имена сам. Чтобы поставить метку, просто используйте любое положительное число в качестве имени. Чтобы сослаться на метку, которая определена ранее, используйте <code>Nb</code> (мнемоническое значение — backward), а чтобы сослаться на метку, которая определена дальше в коде, используйте <code>Nf</code> (мнемоническое значение — forward).</p>
<h3><span class="mw-headline" id=".D0.9E.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.D1.81_.D1.86.D0.B5.D0.BF.D0.BE.D1.87.D0.BA.D0.B0.D0.BC.D0.B8_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85">Операции с цепочками данных</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=42" title="Редактировать раздел «Операции с цепочками данных»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>При обработке данных часто приходится иметь дело с цепочками данных. Цепочка, как подсказывает название, представляет собой массив данных — несколько переменных одного размера, расположенных друг за другом в памяти. В Си вы использовали массив и индексную переменную, например, <code>argv[i]</code>. Но в ассемблере для последовательной обработки цепочек есть специализированные команды. Синтаксис:</p>
<pre> lods
 stos
</pre>
<p>«Странно», — скажет кто-то, — «откуда эти команды знают, где брать данные и куда их записывать? Ведь у них и аргументов-то нет!» Вспомните про регистры <code>%esi</code> и <code>%edi</code> и про их немного странные имена: «индекс источника» (англ. source index) и «индекс приёмника» (англ. destination index). Так вот, все цепочечные команды подразумевают, что в регистре <code>%esi</code> находится указатель на следующий необработанный элемент цепочки-источника, а в регистре <code>%edi</code> — указатель на следующий элемент цепочки-приёмника.</p>
<p>Направление просмотра цепочки задаётся флагом <code>df</code>: 0 — просмотр вперед, 1 — просмотр назад.</p>
<p>Итак, команда <code>lods</code> загружает элемент из цепочки-источника в регистр <code>%eax</code>/<code>%ax</code>/<code>%al</code> (размер регистра выбирается в зависимости от суффикса команды). После этого значение регистра <code>%esi</code> увеличивается или уменьшается (в зависимости от направления просмотра) на значение, равное размеру элемента цепочки.</p>
<p>Команда stos записывает содержимое регистра <code>%eax</code>/<code>%ax</code>/<code>%al</code> в цепочку-приёмник. После этого значение регистра <code>%edi</code> увеличивается или уменьшается (в зависимости от направления просмотра) на значение, равное размеру элемента цепочки.</p>
<p>Вот пример программы, которая работает с цепочечными командами. Конечно же, она занимается бестолковым делом, но в противном случае она была бы гораздо сложнее. Она увеличивает каждый байт строки <code>str_in</code> на 1, то есть заменяет a на b, b на с, и так далее.</p>
<pre>.data
printf_format:
        .string "%s\n"

str_in:
        .string "abc123()!@!777"
        .set str_in_length, .-str_in

.bss
str_out:
        .space str_in_length

.text
.globl main
main:
        pushl %ebp
        movl  %esp, %ebp

        movl  $str_in, %esi     /* цепочка-источник                  */
        movl  $str_out, %edi    /* цепочка-приёмник                  */

        movl  $str_in_length - 1, %ecx  /* длина строки без нулевого 
                                   байта (нулевой байт не обрабатываем)
                                                                     */
1:
        lodsb                   /* загрузить байт из источника в %al */
        incb  %al               /* произвести какую-то операцию с %al 
                                                                     */
        stosb                   /* сохранить %al в приёмнике         */
        loop  1b

        movsb                   /* копировать нулевой байт           */

        /* важно: сейчас %edi указывает на конец цепочки-приёмника */

        pushl $str_out
        pushl $printf_format
        call  printf            /* вывести на печать                 */

        movl  $0, %eax

        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
<pre>[user@host:~]$ ./stringop
bcd234)*"A"888
[user@host:~]$ 
</pre>
<p>Но с цепочками мы часто выполняем довольно стандартные действия. Например, при копировании блоков памяти мы просто пересылаем байты из одной цепочки в другую, без обработки. При сравнении строк мы сравниваем элементы двух цепочек. При вычислении длины строки в Си мы считаем байты до тех пор, пока не встретим нулевой байт. Эти действия очень просты, но, в тоже время, используются очень часто, поэтому были введены следующие команды:</p>
<pre> movs
 cmps
 scas
</pre>
<p>Размер элементов цепочки, которые обрабатывают эти команды, зависит от использованного суффикса команды.</p>
<p>Команда <code>movs</code> выполняет копирование одного элемента из цепочки-источника в цепочку-приёмник.</p>
<p>Команда <code>cmps</code> выполняет сравнение элемента из цепочки-источника и цепочки-приёмника (фактически, как и <code>cmp</code>, выполняет вычитание, источник — приёмник, результат никуда не записывается, но флаги устанавливаются).</p>
<p>Команда <code>scas</code> предназначена для поиска определённого элемента в цепочке. Она сравнивает содержимое регистра <code>%eax</code>/<code>%ax</code>/<code>%al</code> и содержимое элемента цепочки (выполняется вычитание <code>%eax</code>/<code>%ax</code>/<code>%al</code> — элемент_цепочки, результат не записывается, но флаги устанавливаются). Адрес цепочки должен быть помещён в регистр <code>%edi</code>.</p>
<p>После того, как эти команды выполнили своё основное действие, они увеличивают/уменьшают индексные регистры на размер элемента цепочки.</p>
<p>Подчеркну тот факт, что эти команды обрабатывают только один элемент цепочки. Таким образом, нужно организовать что-то вроде цикла для обработки всей цепочки. Для этих целей существуют префиксы команд:</p>
<pre> rep
 repe/repz
 repne/repnz
</pre>
<p>Эти префиксы ставятся перед командой, например: <code>repe scas</code>. Префикс организовывает как бы цикл из одной команды, при этом с каждым шагом цикла значение регистра <code>%ecx</code> автоматически уменьшается на 1.</p>
<ul>
<li><code>rep</code> повторяет команду, пока <code>%ecx</code> не равен нулю.</li>
<li><code>repe</code> (или <code>repz</code> — то же самое) повторяет команду, пока <code>%ecx</code> не равен нулю и установлен флаг <code>zf</code>. Анализируя значение регистра <code>%ecx</code>, можно установить точную причину выхода из цикла: если <code>%ecx</code> равен нулю, значит, <code>zf</code> всегда был установлен, и вся цепочка пройдена до конца, если <code>%ecx</code> больше нуля — значит, флаг <code>zf</code> в какой-то момент был сброшен.</li>
<li><code>repne</code> (или <code>repnz</code> — то же самое) повторяет команду, пока <code>%ecx</code> не равен нулю и не установлен флаг <code>zf</code>.</li>
</ul>
<p>Также следует указать команды для управления флагом <code>df</code>:</p>
<pre> cld
 std
</pre>
<p><code>cld</code> (CLear Direction flag) сбрасывает флаг <code>df</code>.</p>
<p><code>std</code> (SeT Direction flag) устанавливает флаг <code>df</code>.</p>
<h4><span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_memcpy">Пример: memcpy</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=43" title="Редактировать раздел «Пример: memcpy»">править</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Вооружившись новыми знаниями, попробуем заново изобрести функцию <code>memcpy(3)</code>:</p>
<pre>.data
printf_format:
        .string "%s\n"

str_in:
        .string "abc123()!@!777"
        .set str_in_length, .-str_in

.bss
str_out:
        .space str_in_length

.text

/* void *my_memcpy(void *dest, const void *src, size_t n); */

my_memcpy:
        pushl %ebp
        movl  %esp, %ebp

        pushl %esi
        pushl %edi

        movl  8(%ebp), %edi     /* цепочка-назначение                */
        movl  12(%ebp), %esi    /* цепочка-источник                  */
        movl  16(%ebp), %ecx    /* длина                             */

        rep movsb

        movl  8(%ebp), %eax     /* вернуть dest                      */

        popl  %edi
        popl  %esi

        movl  %ebp, %esp
        popl  %ebp
        ret

.globl main
main:
        pushl %ebp
        movl  %esp, %ebp

        pushl $str_in_length
        pushl $str_in
        pushl $str_out
        call  my_memcpy

        pushl $str_out
        pushl $printf_format
        call  printf

        movl  $0, %eax

        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
<p>Вы, наверно, будете удивлены, если я вам скажу, что эта реализация <code>memcpy</code> всё равно не самая быстрая. «Что ещё можно сделать?» — спросите вы. Ведь мы можем копировать данные не по одному байту, а по целых 4 байта за раз при помощи <code>movsl</code>. Тогда у нас получается приблизительно такой алгоритм: копируем как можно больше данных блоками по 4 байта, после этого остаётся хвостик в 0, 1, 2 или 3 байта; этот остаток можно скопировать при помощи <code>movsb</code>. Поэтому нашу <code>memcpy</code> лучше переписать вот так:</p>
<pre>/* void *my_memcpy(void *dest, const void *src, size_t n); */

my_memcpy:
        pushl %ebp
        movl  %esp, %ebp

        pushl %esi
        pushl %edi

        movl  8(%ebp), %edi     /* цепочка-назначение                */
        movl  12(%ebp), %esi    /* цепочка-источник                  */
        movl  16(%ebp), %edx    /* длина                             */

        movl  %edx, %ecx
        shrl  $2, %ecx          /* делить на 2^2 = 4; теперь в 
                                   находится %ecx количество 4-байтных 
                                   кусочков                          */
        rep movsl

        movl  %edx, %ecx
        andl  $3, %ecx          /* $3 == $0b11, оставить только два 
                                   младших бита, то есть остаток от 
                                   деления на 4                      */
        jz    1f                /* если результат 0, пропустить 
                                   цепочечную команду                */
        rep movsb
1:

        movl  8(%ebp), %eax     /* вернуть dest                      */

        popl  %edi
        popl  %esi

        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
<h4><span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_strlen">Пример: strlen</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=44" title="Редактировать раздел «Пример: strlen»">править</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Теперь <code>strlen</code>: нам нужно сравнить каждый байт цепочки с 0, остановиться, когда найдём 0, и вернуть количество ненулевых байт. Как счетчик мы будем использовать регистр <code>%ecx</code>, который автоматически изменяют все префиксы. Но префиксы уменьшают счетчик и прекращают выполнение команды, когда <code>%ecx</code> равен 0. Поэтому перед цепочечной командой мы поместим в <code>%ecx</code> число <code>0xffffffff</code>, и этот регистр будет уменьшатся в ходе выполнения цепочечной команды. Результат получится в обратном коде, поэтому мы используем команду <code>not</code> для инвертирования всех битов. И после этого ещё уменьшим результат на 1, так как нулевой байт тоже был посчитан.</p>
<pre>.data
printf_format:
        .string "%u\n"

str_in:
        .string "abc123()!@!777"

.text

/* size_t my_strlen(const char *s); */

my_strlen:
        pushl %ebp
        movl  %esp, %ebp

        pushl %edi

        movl  8(%ebp), %edi             /* цепочка */

        movl  $0xffffffff, %ecx
        xorl  %eax, %eax                /* %eax = 0 */

        repne scasb

        notl  %ecx
        decl  %ecx

        movl  %ecx, %eax

        popl  %edi

        movl  %ebp, %esp
        popl  %ebp
        ret

.globl main
main:
        pushl %ebp
        movl  %esp, %ebp

        pushl $str_in
        call  my_strlen

        pushl %eax
        pushl $printf_format
        call  printf

        movl  $0, %eax

        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
<p>Как реализованы другие стандартные цепочечные функции, можно посмотреть, например, в исходных кодах ядра Linux в файлах <code>/usr/src/linux/arch/x86/include/asm/string_*.h</code>, <code>/usr/src/linux/arch/x86/lib/{mem*,str*}</code>. Оттуда взяты все примеры для этого раздела.</p>
<p>В заключение обсуждения цепочечных команд нужно сказать следующее: не следует заново изобретать стандартные функции, как мы это только что сделали. Это всего лишь пример и объяснение принципов их работы. В реальных программах используйте цепочечные команды, только когда они реально смогут помочь при нестандартной обработке цепочек, а для стандартных операций лучше вызывать библиотечные функции.</p>
<h3><span class="mw-headline" id=".D0.9A.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.86.D0.B8.D1.8F_switch">Конструкция switch</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=45" title="Редактировать раздел «Конструкция switch»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Оператор <code>switch</code> языка Си можно переписать на ассемблере разными способами. Рассмотрим несколько вариантов того, какими могут быть значения у case:</p>
<ul>
<li>значения из определённого маленького промежутка (все или почти все), например, 23, 24, 25, 27, 29, 30;</li>
<li>значения, между которыми большие «расстояния» на числовой прямой, например, 5, 15, 80, 3800;</li>
<li>комбинированный вариант: 35, 36, 37, 38, 39, 1200, 1600, 7000.</li>
</ul>
<p>Рассмотрим решение для первого случая. Вспомним, что команда <code>jmp</code> принимает адрес не только в виде непосредственного значения (метки), но и как обращение к памяти. Значит, мы можем осуществлять переход на адрес, вычисленный в процессе выполнения. Теперь вопрос: как можно вычислить адрес? А нам не нужно ничего вычислять, мы просто поместим все адреса case-веток в массив. Пользуясь проверяемым значением как индексом массива, выбираем нужный адрес case-ветки. Таким образом, процессор всё вычислит за нас. Посмотрите на следующий код:</p>
<pre>.data
printf_format:
        .string "%u\n"

.text
.globl main

main:
        pushl %ebp
        movl  %esp, %ebp

        movl  $1, %eax          /* получить в %eax некоторое 
                                   интересующее нас значение         */

                                /* мы предусмотрели случаи только для 
                                   0, 1, 3, поэтому,                 */
        cmpl  $3, %eax          /* если %eax больше 3 
                                   (как беззнаковое),                */
        ja    case_default      /* перейти к default                 */

        jmp   *jump_table(,%eax,4) /* перейти по адресу, содержащемуся 
                                   в памяти jump_table + %eax*4      */

.section .rodata
        .p2align 4
jump_table:                     /* массив адресов                    */
        .long case_0            /* адрес этого элемента массива: 
                                                     jump_table + 0  */
        .long case_1            /*                   jump_table + 4  */
        .long case_default      /*                   jump_table + 8  */
        .long case_3            /*                   jump_table + 12 */
.text

case_0:
        movl  $5, %ecx          /* тело case-блока                   */
        jmp   switch_end        /* имитация break — переход в конец 
                                   switch                            */

case_1:
        movl  $15, %ecx
        jmp   switch_end

case_3:
        movl  $35, %ecx
        jmp   switch_end

case_default:
        movl  $100, %ecx

switch_end:

        pushl %ecx              /* вывести %ecx на экран, выйти      */
        pushl $printf_format
        call  printf

        movl  $0, %eax

        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
<p>Этот код эквивалентен следующему коду на Си:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
      <span class="n">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
      <span class="n">c</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
      <span class="n">c</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
      <span class="n">c</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Смотрите: в секции <code>.rodata</code> (данные только для чтения) создаётся массив из 4 значений. Мы обращаемся к нему как к обычному массиву, индексируя его по <code>%eax</code>: <code>jump_table(,%eax,4)</code>. Но зачем перед этим стоит звёздочка? Она означает, что мы хотим перейти по адресу, содержащемуся в памяти по адресу jump_table(,%eax,4) (если бы её не было, мы бы перешли по этому адресу и начали исполнять массив <code>jump_table</code> как код).</p>
<p>Заметьте, что тут нам понадобились значения 0, 1, 3, укладывающиеся в маленький промежуток [0; 3]. Так как для значения 2 не предусмотрено особой обработки, в массиве адресов <code>jump_table</code> индексу 2 соответствует <code>case_default</code>. Перед тем, как сделать <code>jmp</code>, нужно обязательно убедиться, что проверяемое значение входит в наш промежуток, и если не входит — перейти на <code>default</code>. Если вы этого не сделаете, то, когда попадётся значение, находящееся за пределами массива, программа, в лучшем случае, получит segmentation fault, а в худшем (если рядом с этим масивом адресов в памяти окажется еще один массив адресов) код продолжит исполнение вообще непонятно где.</p>
<p>Теперь рассмотрим случай, когда значения для веток case находятся на большом расстоянии друг от друга. Очевидно, что способ с массивом адресов не подходит, иначе массив занимал бы большое количество памяти и содержал в основном адреса ветки <code>default</code>. В этом случае лучшее, что может сделать программист, — выразить <code>switch</code> как последовательное сравнение со всеми перечисленными значениями. Если значений довольно много, придётся применить немного логики: приблизительно прикинуть, какие ветки будут исполняться чаще всего, и отсортировать их в таком порядке в коде. Это нужно для того, чтобы наиболее часто исполняемые ветки исполнялись после маленького числа сравнений. Допустим, у нас есть варианты 5, 38, 70 и 1400, причём 70 будет появляться чаще всего:</p>
<pre>.data
printf_format:
        .string "%u\n"

.text
.globl main

main:
        pushl %ebp
        movl  %esp, %ebp

        movl  $70, %eax         /* получить в %eax некоторое 
                                   интересующее нас значение         */

        cmpl  $70, %eax
        je    case_70

        cmpl  $5, %eax
        je    case_5

        cmpl  $38, %eax
        je    case_38

        cmpl  $1400, %eax
        je    case_1400

case_default:
        movl  $100, %ecx
        jmp   switch_end

case_5:
        movl  $5, %ecx
        jmp   switch_end

case_38:
        movl  $15, %ecx
        jmp   switch_end

case_70:
        movl  $25, %ecx
        jmp   switch_end

case_1400:
        movl  $35, %ecx

switch_end:

        pushl %ecx

        pushl $printf_format
        call  printf

        movl  $0, %eax

        movl  %ebp, %esp
        popl  %ebp
        ret
</pre>
<p>Единственное, на что хочется обратить внимание, — на расположение ветки <code>default</code>: если все сравнения оказались ложными, код <code>default</code> выполняется автоматически.</p>
<p>Наконец, третий, комбинированный, вариант. Путь имеем варианты 35, 36, 37, 39, 1200, 1600 и 7000. Тогда мы видим промежуток [35; 39] и ещё три числа. Код будет выглядеть приблизительно так:</p>
<pre>        movl  $1, %eax          /* получить в %eax некоторое 
                                   интересующее нас значение         */

        cmpl  $35, %eax
        jb    case_default

        cmpl  $39, %eax
        ja    switch_compare

        jmp   *jump_table-140(,%eax,4)

.section .rodata
        .p2align 4
jump_table:
        .long case_35
        .long case_36
        .long case_37
        .long case_default
        .long case_39
.text

switch_compare:
        cmpl  $1200, %eax
        jmp   case_1200

        cmpl  $1600, %eax
        jmp   case_1600

        cmpl  $7000, %eax
        jmp   case_7000

case_default:
        /* ... */
        jmp   switch_end

case_35:
        /* ... */
        jmp   switch_end

        ... ещё код ...
switch_end:
</pre>
<p>Заметьте, что промежуток начинается с числа 35, а не с 0. Для того, чтобы не производить вычитание 35 отдельной командой и не создавать массив, в котором от 0 до 34 идёт адреса метки default, сначала проверяется принадлежность числа промежутку [35; 39], а затем производится переход, но массив адресов считается размещённым на 35 двойных слов «ниже» в памяти (то есть, на 35 × 4 = 140 байт). В результате получается, что адрес перехода считывается из памяти по адресу <code>jump_table - 35*4 +&nbsp;%eax*4 = jump_table + (%eax - 35)*4</code>. Выиграли одно вычитание.</p>
<p>В этом примере, как и в предыдущих, имеет смысл переставить некоторые части этого кода в начало, если вы заранее знаете, какие значения вам придётся обрабатывать чаще всего.</p>
<h4><span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D0.BF.D1.80.D0.B5.D1.82.D0.B0.D1.82.D0.BE.D1.80_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0_Brainfuck">Пример: интерпретатор языка Brainfuck</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=46" title="Редактировать раздел «Пример: интерпретатор языка Brainfuck»">править</a><span class="mw-editsection-bracket">]</span></span></h4>
<p><a href="https://ru.wikipedia.org/wiki/Brainfuck" class="extiw" title="w:Brainfuck">Brainfuck</a> — это эзотерический язык программирования, то есть язык, предназначенный не для практического применения, а придуманный как головоломка, как задача, которая заставляет программиста думать нестандартно. Команды Brainfuck управляют массивом целых чисел с неограниченным набором ячеек, есть понятие текущей ячейки.</p>
<ul>
<li>Команды <code>&lt;</code> и <code>&gt;</code> дают возможность перемещаться по массиву на одну ячейку влево и, соответственно, вправо.</li>
<li>Команды <code>+</code> и <code>-</code> увеличивают и, соответственно, уменьшают содержимое текущей ячейки на 1.</li>
<li>Команда <code>.</code> выводит содержимое текущей ячейки на экран как один символ; команда <code>,</code> читает один символ и помещает его в текущую ячейку.</li>
<li>Команды циклов <code>[</code> и <code>]</code> должны всегда находиться в парах и соблюдать правила вложенности (как скобки в математических выражениях). Команда <code>[</code> сравнивает значение текущей ячейки с 0: если оно равно 0, то выполняется команда, следующая за соответствующей <code>]</code>, если не равно, то просто выполняется следующая команда. Команда <code>]</code> передаёт управление на соответствующую <code>[</code>.</li>
<li>Остальные символы в коде программы являются комментариями, и их следует пропускать.</li>
</ul>
<p>В начальном состоянии все ячейки содержат значение 0, а текущей является крайняя левая ячейка.</p>
<p>Вот несколько программ с объяснениями:</p>
<pre>+&gt;+&gt;+        Устанавливает первые три ячейки в 1
[-]          Обнуляет текущую ячейку
[&gt;&gt;&gt;+&lt;&lt;&lt;-]   Перемещает значение текущей ячейки в ячейку, расположенную
             "тремя шагами правее"
</pre>
<p>Интерпретация программы состоит из двух шагов: загрузка программы и собственно исполнение. Во время загрузки следует проверить корректность программы (соответствие <code>[]</code>) и расположить код программы в памяти в удобном для выполнения виде. Для этого каждой команде присваивается номер операции, начиная с 0, — для того, чтобы можно было выполнять операции при помощи помощи перехода по массиву адресов, как в <code>switch</code>.</p>
<p>Большинство программ на Brainfuck содержат последовательности одинаковых команд <code>&lt;</code> <code>&gt;</code> <code>+</code> <code>-</code>, которые можно выполнять не по одной, а все сразу. Например, выполняя код <code>+++++</code>, можно выполнить пять раз увеличение на 1, или один раз увеличение на 5. Таким образом, довольно простыми средствами можно сильно оптимизировать выполнение программы.</p>
<p>Вот программы, которые вызовут ошибки загрузки:</p>
<pre>[       No matching ']' found for a '['
]       No matching '[' found for a ']'
</pre>
<p>А эти программы вызовут ошибки выполнения:</p>
<pre>&lt;       Memory underflow
+[&gt;+]   Memory overflow
</pre>
<p>Исходный код:</p>
<pre>#define BF_PROGRAM_SIZE 1024
#define BF_MEMORY_CELLS 32768
#define BF_MEMORY_SIZE BF_MEMORY_CELLS*4

#define BF_OP_LOOP_START 0
#define BF_OP_LOOP_END   1
#define BF_OP_MOVE_LEFT  2
#define BF_OP_MOVE_RIGHT 3
#define BF_OP_INC        4
#define BF_OP_DEC        5
#define BF_OP_PUTC       6
#define BF_OP_GETC       7
#define BF_OP_EXIT       8

.section .rodata
str_memory_underflow:
        .string "Memory underflow\n"

str_memory_overflow:
        .string "Memory overflow\n"

str_loop_start_not_found:
        .string "No matching '[' found for a ']'\n"

str_loop_end_not_found:
        .string "No matching ']' found for a '['\n"

.data
bf_program_ptr:
        .long 0

bf_program_size:
        .long 0

/*
 * Программа загружается в память вот так:
 * =============================
 * код_операции, операнд,
 * код_операции, операнд,
 * код_операции, операнд, ...
 * =============================
 * И код_операции, и операнд занимают по 4 байта.
 * Таким образом, одна команда занимает в памяти 8 байт.
 *
 * Для команды [ (начало цикла) операндом является номер команды, 
 * следующий за концом цикла.
 *
 * Для команды ] (конец цикла) операндом является номер команды-начала 
 * цикла ].
 *
 * Для остальных команд (&lt; &gt; + - . ,) операнд задаёт количество 
 * повторений этой команды.  Например, для кода +++++ должен быть 
 * сгенерирован код операции BF_OP_INC с операндом 5, который при 
 * выполнении увеличит текущую ячейку на 5.
 */

.text
.globl main
main:
        pushl %ebp
        movl  %esp, %ebp

/* ******************************************* */
/* загрузка программы                          */
/* ******************************************* */

        movl  $BF_PROGRAM_SIZE, %ecx
        movl  %ecx, bf_program_size
        pushl %ecx
        call  malloc
        movl  %eax, bf_program_ptr

        movl  %eax, %ebx        /* %ebx — указатель на блок памяти, 
                                   содержащий внутреннее представление 
                                   программы                         */
        xorl  %ecx, %ecx        /* %ecx — номер текущей команды      */
        xorl  %esi, %esi        /* %esi — предыдущая команда, символ */

bf_read_loop:
        pushl %ecx
        pushl stdin
        call  fgetc
        addl  $4, %esp
        popl  %ecx

        cmpl  $-1, %eax
        je    bf_read_end

        cmpl  $'[, %eax         /* команды, которые всегда 
                                   обрабатываются по одной: [ и ]    */
        je    bf_read_loop_start

        cmpl  $'], %eax
        je    bf_read_loop_end

        cmpl  %esi, %eax        /* текущая команда такая же, как и 
                                   предыдущая?                       */
        jne   not_dupe

        incl  -4(%ebx,%ecx,8)   /* такая же. Но %ecx указывает на 
                                   следующую команду, поэтому 
                                   используем отрицательное смещение -4
                                                                     */
        jmp   bf_read_loop

not_dupe:                       /* другая                            */
        cmpl  $'&lt;, %eax
        je    bf_read_move_left

        cmpl  $'&gt;, %eax
        je    bf_read_move_right

        cmpl  $'+, %eax
        je    bf_read_inc

        cmpl  $'-, %eax
        je    bf_read_dec

        cmpl  $'., %eax
        je    bf_read_putc

        cmpl  $',, %eax
        je    bf_read_getc

        jmp   bf_read_loop

bf_read_loop_start:
        movl  $BF_OP_LOOP_START, (%ebx,%ecx,8)
        movl  $0, 4(%ebx,%ecx,8)
        jmp   bf_read_switch_end

bf_read_loop_end:
        movl  $BF_OP_LOOP_END, (%ebx,%ecx,8)
        movl  %ecx, %edx
bf_read_loop_end_find:
        testl %edx, %edx
        jz    bf_read_loop_end_not_found
        decl  %edx
        cmpl  $0, 4(%ebx,%edx,8)
        je    bf_read_loop_end_found
        jmp   bf_read_loop_end_find
bf_read_loop_end_not_found:
        jmp   loop_start_not_found
bf_read_loop_end_found:
        leal  1(%ecx), %edi
        movl  %edi, 4(%ebx,%edx,8)
        movl  %edx, 4(%ebx,%ecx,8)
        jmp   bf_read_switch_end

bf_read_move_left:
        movl  $BF_OP_MOVE_LEFT, (%ebx,%ecx,8)
        jmp   bf_read_switch_end_1

bf_read_move_right:
        movl  $BF_OP_MOVE_RIGHT, (%ebx,%ecx,8)
        jmp   bf_read_switch_end_1

bf_read_inc:
        movl  $BF_OP_INC, (%ebx,%ecx,8)
        jmp   bf_read_switch_end_1

bf_read_dec:
        movl  $BF_OP_DEC, (%ebx,%ecx,8)
        jmp   bf_read_switch_end_1

bf_read_putc:
        movl  $BF_OP_PUTC, (%ebx,%ecx,8)
        jmp   bf_read_switch_end_1

bf_read_getc:
        movl  $BF_OP_GETC, (%ebx,%ecx,8)

bf_read_switch_end_1:
        movl  $1, 4(%ebx,%ecx,8)

bf_read_switch_end:

        movl  %eax, %esi        /* сохранить текущую команду для 
                                   сравнения                         */

        incl  %ecx

        leal  (,%ecx,8), %edx   /* блок памяти закончился?           */
        cmpl  bf_program_size, %edx
        jne   bf_read_loop

        addl  $BF_PROGRAM_SIZE, %edx  /* увеличить размер блока памяти 
                                                                     */
        movl  %edx, bf_program_size
        pushl %ecx
        pushl %edx
        pushl %ebx
        call  realloc
        addl  $8, %esp
        popl  %ecx
        movl  %eax, bf_program_ptr
        movl  %eax, %ebx

        jmp   bf_read_loop

bf_read_end:

        movl  $BF_OP_EXIT, (%ebx,%ecx,8)  /* последней добавить 
                                             команду выхода          */
        movl  $1, 4(%ebx,%ecx,8)

/*
 * Ищем незакрытые '[':
 * Ищем 0 в поле операнда.  Саму команду не проверяем, так как 0 может 
 * быть операндом только у '['.
 */

        xorl  %edx, %edx
1:
        cmpl  $0, 4(%ebx,%ecx,8)
        je    loop_end_not_found
        incl  %ecx
        testl %edx, %ecx
        je    2f
        jmp   1b
2:

/* ******************************************* */
/* выполнение программы                        */
/* ******************************************* */


        pushl $BF_MEMORY_SIZE   /* выделить блок памяти для памяти 
                                   программы                         */
        call  malloc
        addl  $4, %esp
        movl  %eax, %esi

        xorl  %ecx, %ecx        /* %ecx — номер текущей команды      */
        xorl  %edi, %edi        /* %edi — номер текущей ячейки памяти 
                                                                     */

interpreter_loop:
        movl  (%ebx,%ecx,8), %eax     /* %eax — команда              */
        movl  4(%ebx,%ecx,8), %edx    /* %edx — операнд              */

        jmp   *interpreter_jump_table(,%eax,4)
.section .rodata
interpreter_jump_table:
        .long bf_op_loop_start
        .long bf_op_loop_end
        .long bf_op_move_left
        .long bf_op_move_right
        .long bf_op_inc
        .long bf_op_dec
        .long bf_op_putc
        .long bf_op_getc
        .long bf_op_exit
.text

bf_op_loop_start:
        cmpl  $0, (%esi,%edi,4)
        je    bf_op_loop_start_jump
        incl  %ecx
        jmp   interpreter_loop
bf_op_loop_start_jump:
        movl  %edx, %ecx
        jmp   interpreter_loop

bf_op_loop_end:
        movl  %edx, %ecx
        jmp   interpreter_loop

bf_op_move_left:
        movl  %edi, %eax
        subl  %edx, %eax        /* если номер новой ячейки 
                                   памяти &lt; 0 ...                    */
        js    memory_underflow
        movl  %eax, %edi
        incl  %ecx
        jmp   interpreter_loop

bf_op_move_right:
        movl  %edi, %eax
        addl  %edx, %eax        /* если номер новой ячейки памяти 
                                   больше допустимого...             */
        cmpl  $BF_MEMORY_CELLS, %eax
        jae   memory_overflow
        movl  %eax, %edi
        incl  %ecx
        jmp   interpreter_loop

bf_op_inc:
        addl  %edx, (%esi,%edi,4)
        incl  %ecx
        jmp   interpreter_loop

bf_op_dec:
        subl  %edx, (%esi,%edi,4)
        incl  %ecx
        jmp   interpreter_loop

bf_op_putc:
        xorl  %eax, %eax
        movb  (%esi,%edi,4), %al
        pushl %ecx
        pushl %edi
        movl  %edx, %edi
        pushl stdout
        pushl %eax
bf_op_putc_loop:
        call  fputc
        decl  %edi
        testl %edi, %edi
        jne   bf_op_putc_loop
        addl  $4, %esp
        call  fflush
        addl  $4, %esp
        popl  %edi
        popl  %ecx
        incl  %ecx
        jmp   interpreter_loop

bf_op_getc:
        pushl %ecx
        pushl %edi
        movl  %edx, %edi
        pushl stdin
bf_op_getc_loop:
        call  getc
        decl  %edi
        testl %edi, %edi
        jne   bf_op_getc_loop
        addl  $4, %esp
        movl  %eax, (%esi,%edi,4)
        popl  %edi
        popl  %ecx
        incl  %ecx
        jmp   interpreter_loop

bf_op_exit:
        xorl  %eax, %eax
        jmp   interpreter_exit

/* ******************************************* */
/* обработчики ошибок                          */
/* ******************************************* */

memory_underflow:
        pushl $str_memory_underflow
        call  printf
        movl  $1, %eax
        jmp   interpreter_exit

memory_overflow:
        pushl $str_memory_overflow
        call  printf
        movl  $1, %eax
        jmp   interpreter_exit

loop_start_not_found:
        pushl $str_loop_start_not_found
        call  printf
        movl  $1, %eax
        jmp   interpreter_exit

loop_end_not_found:
        pushl $str_loop_end_not_found
        call  printf
        movl  $1, %eax

interpreter_exit:
        movl  %ebp, %esp
        popl  %ebp
        .size main, .-main
</pre>
<h3><span class="mw-headline" id=".D0.91.D1.83.D0.BB.D0.B5.D0.B2.D1.8B_.D0.B2.D1.8B.D1.80.D0.B0.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F">Булевы выражения</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=47" title="Редактировать раздел «Булевы выражения»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Рассмотрим такой код на языке Си:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="k">if</span><span class="p">(((</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">{</span>
  <span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
<p>В принципе, булево выражение можно вычислять как обычное арифметическое, то есть в такой последовательности:</p>
<ul>
<li><code>a &gt; 5</code></li>
<li><code>b &lt; 10</code></li>
<li><code>(a &gt; 5) &amp;&amp; (b &lt; 10)</code></li>
<li><code>c == 0</code></li>
<li><code>((a &gt; 5) &amp;&amp; (b &lt; 10)) || (c == 0)</code></li>
</ul>
<p>Такой способ вычисления называется полным. Можем ли мы вычислить значение этого выражения быстрее? Смотрите, если <code>c == 0</code>, то всё выражение будет иметь значение true в любом случае, независимо от <code>a</code> и <code>b</code>. А вот если <code>c&nbsp;!= 0</code>, то приходится проверять значения <code>a</code> и <code>b</code>. Таким образом, наш код (фактически) превращается в такой:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">goto</span> <span class="n">do_it</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span><span class="p">((</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">{</span>
  <span class="k">goto</span> <span class="n">do_it</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">goto</span> <span class="n">dont_do_it</span><span class="p">;</span>

<span class="nl">do_it</span><span class="p">:</span>
  <span class="n">do_something</span><span class="p">();</span>

<span class="nl">dont_do_it</span><span class="p">:</span>
</pre></div>
<p>В принципе, можно пойти дальше: если <code>a &lt;= 5</code>, нас не интересует сравнение <code>b &lt; 10</code>: всё равно выражение равно false.</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">goto</span> <span class="n">do_it</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">goto</span> <span class="n">do_it</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">goto</span> <span class="n">dont_do_it</span><span class="p">;</span>

<span class="nl">do_it</span><span class="p">:</span>
  <span class="n">do_something</span><span class="p">();</span>

<span class="nl">dont_do_it</span><span class="p">:</span>
</pre></div>
<p>Такой способ вычисления выражений называется сокращённым (от англ. short-circuit evaluation), потому что позволяет вычислить выражение, не проверяя всех входящих в него подвыражений. Можно вывести такие формальные правила:</p>
<ul>
<li>если у оператора OR хотя бы один операнд имеет значение true, всё выражение имеет значение true;</li>
<li>если у оператора AND хотя бы один операнд имеет значение false, всё выражение имеет значение false.</li>
</ul>
<p>В принципе, сокращённое вычисление булевых выражений помогает написать более быстрый (а часто и более простой) код. С другой стороны, возникают проблемы, если одно из подвыражений при вычислении вызывает побочные эффекты (англ. side effects), например вызов функции:</p>
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="k">if</span><span class="p">((</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">foo</span><span class="p">())</span>
<span class="p">{</span>
  <span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
<p>Если мы используем сокращённое вычисление и оказывается, что <code>c == 0</code>, то функция <code>foo()</code> вызвана не будет, потому что от её результата значение выражения уже не зависит. Хорошо это или плохо, зависит от конкретной ситуации, но, без сомнения, способ выполнения такого кода становится не очевидным.</p>
<p>Во многих языках высокого уровня сокращённое вычисление выражений требуется от компилятора стандартом языка (например, в Си). Однако, обычно задаются более строгие правила вычислений. В большинстве стандартов языков требуется, чтобы выражения соединённые оператором OR (или AND) вычислялись строго слева направо, и если очередное значение будет true (соответственно, false для AND), то вычисление данной цепочки OR-ов (AND-ов) прекращается. Но нужно отметить, что первый пример в этой главе всё равно является корректным с точки зрения стандарта Си (хотя <code>c == 0</code> стоит в конце выражения, а вычисляется первым), так как сравнение локальных переменных не вызывает побочных эффектов и компилятор вправе реорганизовать код таким образом.</p>
<p>Теперь перейдём к тому, как это реализовывается на ассемблере. Начнём с полного вычисления:</p>
<pre>cmpl  $5, a
/* так, а что дальше? */
</pre>
<p>Действительно, нам нужно сохранить результат сравнения в переменную. Из команд, анализирующих флаги, мы знаем только семейство <code>jcc</code>, но они нам не подходят. Кроме <code>jcc</code>, существует семейство <code>setcc</code>. Они проверяют состояние флагов точно так же, как и <code>jcc</code>. На основе флагов операнд устанавливается в 1, если проверяемое условие <code>cc</code> истинно, и в 0, если условие ложно.</p>
<pre>setcc <i>операнд</i>
</pre>
<p>Требуется заметить, что команды <code>setcc</code> работают только с операндами (хранящимися в регистрах и памяти) размером один байт.</p>
<p>Тогда полное вычисление будет выглядеть так:</p>
<pre>        cmpl  $5, a
        seta  %al
        cmpl  $10, b
        setb  %bl
        andb  %bl, %al
        cmpl  $0, c
        sete  %bl
        orb   %bl, %al
        jz    is_false
is_true:
        ...
is_false:
        ...
</pre>
<p>Обратите внимание, что команда <code>or</code> устанавливает флаги, и нам не нужно отдельно сравнивать <code>%al</code> с нулём.</p>
<p>Сокращённое вычисление:</p>
<pre>        cmpl  $0, c
        je    is_true
        cmpl  $5, a
        jbe   is_false
        cmpl  $10, b
        jae   is_false
is_true:
        ...
is_false:
        ...
</pre>
<p>Как видите, этот код является не только более коротким, но и завершает своё исполнение, как только результат становится известен. Таким образом, сокращённое вычисление намного быстрее полного.</p>
<h4><span class="mw-headline" id=".D0.A1.D0.BC._.D1.82.D0.B0.D0.BA.D0.B6.D0.B5_2">См. также</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=48" title="Редактировать раздел «См. также»">править</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/en:Short-circuit_evaluation" class="extiw" title="w:en:Short-circuit evaluation">Short-circuit evaluation</a></li>
</ul>
<h2><span class="mw-headline" id=".D0.9E.D1.82.D0.BB.D0.B0.D0.B4.D1.87.D0.B8.D0.BA_GDB">Отладчик GDB</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=49" title="Редактировать раздел «Отладчик GDB»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Цель отладки программы — устранение ошибок в её коде. Для этого вам, скорее всего, придётся исследовать состояние переменных во время выполнения, равно как и сам процесс выполнения (например, отслеживать условные переходы). Тут отладчик — наш первый помощник. Конечно же, в Си достаточно много возможностей отладки без непосредственной остановки программы: от простого <code>printf(3)</code> до специальных систем ведения логов по сети и <code>syslog</code>. В ассемблере такие методы тоже применимы, но вам может понадобиться наблюдение за состоянием регистров, образ (dump) оперативной памяти и другие вещи, которые гораздо удобнее сделать в интерактивном отладчике. В общем, если вы пишете на ассемблере, то без отладчика вы вряд ли обойдётесь.</p>
<p>Начать отладку можно с определения точки останова (breakpoint), если вы уже приблизительно знаете, какой участок кода нужно исследовать. Этот способ используется чаще всего: ставим точку останова, запускам программу и проходим её выполнение по шагам, попутно наблюдая за необходимыми переменными и регистрами. Вы также можете просто запустить программу под отладчиком и поймать момент, когда она аварийно завершается из-за segmentation fault, — так можно узнать, какая инструкция пытается получить доступ к памяти, подробнее рассмотреть приводящую к ошибке переменную и так далее. Теперь можно исследовать этот код ещё раз, пройти его по шагам, поставив точку останова чуть раньше момента сбоя.</p>
<p>Начнём с простого. Возьмём программу Hello world и скомпилируем её с отладочной информацией при помощи ключа компилятора <code>-g</code>:</p>
<pre>[user@host:~]$ gcc -g hello.s -o hello
[user@host:~]$ 
</pre>
<p>Запускаем gdb:</p>
<pre>[user@host:~]$ gdb ./hello
GNU gdb 6.4.90-debian
Copyright (C) 2006 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and 
you are welcome to change it and/or distribute copies of it under 
certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB. Type "show warranty" for 
details.
This GDB was configured as "i486-linux-gnu"...Using host libthread_db 
library "/lib/tls/libthread_db.so.1".

(gdb) 
</pre>
<p>GDB запустился, загрузил исследуемую программу, вывел на экран приглашение <code>(gdb)</code> и ждёт команд. Мы хотим пройти программу «по шагам» (single-step mode). Для этого нужно указать команду, на которой программа должна остановиться. Можно указать подпрограмму — тогда остановка будет осуществлена перед началом исполнения инструкций этой подпрограммы. Ещё можно указать имя файла и номер строки.</p>
<pre>(gdb) b main
Breakpoint 1 at 0x8048324: file hello.s, line 17.
(gdb) 
</pre>
<p><code>b</code> — сокращение от <code>break</code>. Все команды в GDB можно сокращать, если это не создаёт двусмысленных расшифровок. Запускаем программу командой <code>run</code>. Эта же команда используется для перезапуска ранее запущенной программы.</p>
<pre>(gdb) r
Starting program: /tmp/hello

Breakpoint 1, main () at hello.s:17
17      movl  $4, %eax   /* поместить номер системного вызова write = 4
Current language:  auto; currently asm
(gdb) 
</pre>
<p>GDB остановил программу и ждёт команд. Вы видите команду вашей программы, которая будет выполнена следующей, имя функции, которая сейчас исполняется, имя файла и номер строки. Для пошагового исполнения у нас есть две команды: <code>step</code> (сокращённо <code>s</code>) и <code>next</code> (сокращённо <code>n</code>). Команда <code>step</code> производит выполнение программы с заходом в тела подпрограмм. Команда <code>next</code> выполняет пошагово только инструкции текущей подпрограммы.</p>
<pre>(gdb) n
20      movl  $1, %ebx          /* первый параметр - в регистр %ebx  */
(gdb) 
</pre>
<p>Итак, инструкция на строке 17 выполнена, и мы ожидаем, что в регистре <code>%eax</code> находится число 4. Для вывода на экран различных выражений используется команда <code>print</code> (сокращённо <code>p</code>). В отличие от команд ассемблера, GDB в записи регистров использует знак <code>$</code> вместо <code>%</code>. Посмотрим, что в регистре <code>%eax</code>:</p>
<pre>(gdb) p $eax
$1 = 4
(gdb) 
</pre>
<p>Действительно 4! GDB нумерует все выведенные выражения. Сейчас мы видим первое выражение (<code>$1</code>), которое равно 4. Теперь к этому выражению можно обращаться по имени. Также можно производить простые вычисления:</p>
<pre>(gdb) p $1
$2 = 4
(gdb) p $1 + 10
$3 = 14
(gdb) p 0x10 + 0x1f
$4 = 47
(gdb) 
</pre>
<p>Пока мы играли с командой <code>print</code>, мы уже забыли, какая инструкция исполняется следующей. Команда <code>info line</code> выводит информацию об указанной строке кода. Без аргументов выводит информацию о текущей строке.</p>
<pre>(gdb) info line
Line 20 of "hello.s" starts at address 0x8048329 &lt;main+5&gt; and ends at 
0x804832e &lt;main+10&gt;.
(gdb) 
</pre>
<p>Команда <code>list</code> (сокращённо <code>l</code>) выводит на экран исходный код вашей программы. В качестве аргументов ей можно передать:</p>
<ul>
<li><i>номер_строки</i> — номер строки в текущем файле;</li>
<li><i>файл</i>:<i>номер_строки</i> — номер строки в указанном файле;</li>
<li><i>имя_функции</i> — имя функции, если нет неоднозначности;</li>
<li><i>файл</i>:<i>имя_функции</i> — имя функции в указанном файле;</li>
<li><i>*адрес</i> — адрес в памяти, по которому расположена необходимая инструкция.</li>
</ul>
<p>Если передавать один аргумент, команда <code>list</code> выведет 10 строк исходного кода вокруг этого места. Передавая два аргумента, вы указываете строку начала и строку конца листинга.</p>
<pre>(gdb) l main
12                                 за пределами этого файла          */
13      .type  main, @function  /* main — функция (а не данные)      */
14
15
16      main:
17              movl  $4, %eax  /* поместить номер системного вызова 
18                                 write = 4 в регистр %eax          */
19
20              movl  $1, %ebx  /* первый параметр поместить в регистр 
21                                 %ebx; номер файлового дескриптора 
22                                 stdout = 1                        */
(gdb) l *$eip
0x8048329 is at hello.s:20.
15
16      main:
17              movl  $4, %eax  /* поместить номер системного вызова 
18                                 write = 4 в регистр %eax          */
19
20              movl  $1, %ebx  /* первый параметр поместить в регистр 
21                                 %ebx; номер файлового дескриптора 
22                                 stdout = 1                        */
23              movl  $hello_str, %ecx  /* второй параметр поместить в 
24                                 регистр %ecx; указатель на строку */
(gdb) l 20, 25
20              movl  $1, %ebx  /* первый параметр поместить в регистр 
21                                 %ebx; номер файлового дескриптора 
22                                 stdout = 1                        */
23              movl  $hello_str, %ecx  /* второй параметр поместить в 
24                                 регистр %ecx; указатель на строку */
25
(gdb) 
</pre>
<p>Запомните эту команду: <code>list *$eip</code>. С её помощью вы всегда можете просмотреть исходный код вокруг инструкции, выполняющейся в текущий момент. Выполняем нашу программу дальше:</p>
<pre>(gdb) n
23              movl  $hello_str, %ecx  /* второй параметр поместить в 
                                           регистр %ecx
(gdb) n
26              movl  $hello_str_length, %edx /* третий параметр 
                                           поместить в регистр %edx
(gdb) 
</pre>
<p>Не правда ли, утомительно каждый раз нажимать <code>n</code>? Если просто нажать Enter, GDB повторит последнюю команду:</p>
<pre>(gdb) 
29              int   $0x80     /* вызвать прерывание 0x80           */
(gdb) 
Hello, world!
31              movl  $1, %eax  /* номер системного вызова exit = 1  */
(gdb) 
</pre>
<p>Ещё одна удобная команда, о которой стоит знать — <code>info registers</code>. Конечно же, её можно сократить до <code>i r</code>. Ей можно передать параметр — список регистров, которые необходимо напечатать. Например, когда выполнение происходит в защищённом режиме, нам вряд ли будут интересны значения сегментных регистров.</p>
<pre>(gdb) info registers
eax            0xe      14
ecx            0x804955c        134518108
edx            0xe      14
ebx            0x1      1
esp            0xbfabb55c       0xbfabb55c
ebp            0xbfabb5a8       0xbfabb5a8
esi            0x0      0
edi            0xb7f6bcc0       -1208566592
eip            0x804833a        0x804833a &lt;main+22&gt;
eflags         0x246    [ PF ZF IF ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
(gdb) info registers eax ecx edx ebx esp ebp esi edi eip eflags
eax            0xe      14
ecx            0x804955c        134518108
edx            0xe      14
ebx            0x1      1
esp            0xbfabb55c       0xbfabb55c
ebp            0xbfabb5a8       0xbfabb5a8
esi            0x0      0
edi            0xb7f6bcc0       -1208566592
eip            0x804833a        0x804833a &lt;main+22&gt;
eflags         0x246    [ PF ZF IF ]
(gdb)
</pre>
<p>Так, а кроме регистров у нас ведь есть ещё и память, и частный случай памяти — стек. Как просмотреть их содержимое? Команда <code>x/<i>формат</i> <i>адрес</i></code> отображает содержимое памяти, расположенной по адресу в заданном формате. Формат — это (в таком порядке) количество элементов, буква формата и размер элемента. Буквы формата: o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char) и s(string). Размер: b(byte), h(halfword), w(word), g(giant, 8 bytes). Например, напечатаем 14 символов строки <code>hello_str</code>:</p>
<pre>(gdb) x/14c &amp;hello_str
0x804955c &lt;hello_str&gt;: 72 'H' 101 'e' 108 'l' 108 'l' 111 'o' 44 ',' 
                       32 ' ' 119 'w'
0x8049564 &lt;hello_str+8&gt;: 111 'o' 114 'r' 108 'l' 100 'd' 33 '!'  10 '\n'
(gdb) 
</pre>
<p>То же самое, только в шестнадцатеричном виде:</p>
<pre>(gdb) x/14xb &amp;hello_str
0x804955c &lt;hello_str&gt;:   0x48  0x65  0x6c  0x6c  0x6f  0x2c  0x20  0x77
0x8049564 &lt;hello_str+8&gt;: 0x6f  0x72  0x6c  0x64  0x21  0x0a
(gdb) 
</pre>
<p>Напечатаем 8 верхних слов (4 байта) из стека (для «погружения в стек» читаем слева направо и сверху вниз):</p>
<pre>(gdb) x/8xw $esp
0xbfd8902c:  0xb7e14ea8      0x00000001      0xbfd890a4      0xbfd890ac
0xbfd8903c:  0x00000000      0xb7f2dff4      0x00000000      0xb7f53cc0
(gdb) 
</pre>
<p>Было бы хорошо, если бы GDB отображал значение какого-то выражения автоматически. Это делает команда <code>display/<i>формат</i> <i>выражение</i></code>. Если в формате будет указан размер, то принцип действия аналогичен <code>x</code>. Если размер не указан, команда ведёт себя как <code>print</code>.</p>
<pre>(gdb) display/4xw $esp
1: x/4xw $esp
0xbf8fdb9c:  0xb7e4dea8      0x00000001      0xbf8fdc14      0xbf8fdc1c
(gdb) display/x $eax
2: /x $eax = 0xe
(gdb) n
32              movl  $0, %ebx  /* передать 0 как значение параметра */
2: /x $eax = 0x1
1: x/4xw $esp
0xbf8fdb9c:  0xb7e4dea8      0x00000001      0xbf8fdc14      0xbf8fdc1c
(gdb) 
</pre>
<h2><span class="mw-headline" id=".D0.A1.D1.81.D1.8B.D0.BB.D0.BA.D0.B8">Ссылки</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit&amp;section=50" title="Редактировать раздел «Ссылки»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<dl>
<dt>Книги и спецификации</dt>
</dl>
<ul>
<li><a rel="nofollow" class="external free" href="http://www.intel.com/products/processor/manuals/">http://www.intel.com/products/processor/manuals/</a> — Документация от Intel</li>
<li><a rel="nofollow" class="external free" href="http://developer.amd.com/documentation/guides/Pages/default.aspx">http://developer.amd.com/documentation/guides/Pages/default.aspx</a> — Документация от AMD</li>
<li><a rel="nofollow" class="external free" href="http://download.savannah.gnu.org/releases/pgubook/">http://download.savannah.gnu.org/releases/pgubook/</a></li>
<li><a rel="nofollow" class="external free" href="http://www.drpaulcarter.com/pcasm/">http://www.drpaulcarter.com/pcasm/</a></li>
<li><a rel="nofollow" class="external free" href="http://refspecs.freestandards.org/">http://refspecs.freestandards.org/</a> — SysV ABI, различные psABI (Processor Suppliment aBI)</li>
<li><a rel="nofollow" class="external free" href="http://www.sco.com/developers/devspecs/">http://www.sco.com/developers/devspecs/</a> — i386 psABI</li>
<li><a rel="nofollow" class="external free" href="http://www.x86-64.org/documentation.html">http://www.x86-64.org/documentation.html</a> — x86-64 psABI</li>
</ul>
<p>Программы</p>
<ul>
<li><a rel="nofollow" class="external free" href="http://ald.sourceforge.net/">http://ald.sourceforge.net/</a></li>
<li><a rel="nofollow" class="external text" href="http://www.gnu.org/software/binutils/">info gas</a></li>
<li><a rel="nofollow" class="external text" href="http://www.gnu.org/software/gdb/">info gdb</a></li>
<li><a rel="nofollow" class="external text" href="https://access.redhat.com/knowledge/docs/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/index.html">Using ld, the GNU Linker</a></li>
</ul>
<dl>
<dt>Руководства и ответы на часто задаваемые вопросы</dt>
</dl>
<ul>
<li><a rel="nofollow" class="external text" href="http://yurichev.com/writings/RE_for_beginners-ru.pdf">Введение в reverse engineering для начинающих</a></li>
<li><a rel="nofollow" class="external free" href="http://gazette.linux.ru.net/lg94/ramankutty.html">http://gazette.linux.ru.net/lg94/ramankutty.html</a></li>
<li><a rel="nofollow" class="external free" href="http://lists.canonical.org/pipermail/kragen-fw/2002-April/000226.html">http://lists.canonical.org/pipermail/kragen-fw/2002-April/000226.html</a></li>
<li><a rel="nofollow" class="external free" href="http://la.kmv.ru/intro/Assembly-Intro.html">http://la.kmv.ru/intro/Assembly-Intro.html</a></li>
<li><a rel="nofollow" class="external free" href="http://web.cecs.pdx.edu/~bjorn/CS200/linux_tutorial/">http://web.cecs.pdx.edu/~bjorn/CS200/linux_tutorial/</a></li>
<li><a rel="nofollow" class="external free" href="http://docs.cs.up.ac.za/programming/asm/derick_tut/">http://docs.cs.up.ac.za/programming/asm/derick_tut/</a></li>
<li><a rel="nofollow" class="external free" href="http://www.unknownroad.com/rtfm/gdbtut/">http://www.unknownroad.com/rtfm/gdbtut/</a></li>
<li><a rel="nofollow" class="external free" href="http://asm.sourceforge.net/resources.html">http://asm.sourceforge.net/resources.html</a></li>
<li><a rel="nofollow" class="external free" href="http://urls.net.ru/computer/programming/asm/">http://urls.net.ru/computer/programming/asm/</a></li>
<li><a class="external free" href="https://en.wikibooks.org/wiki/X86_Assembly">http://en.wikibooks.org/wiki/X86_Assembly</a></li>
<li><a class="external free" href="https://en.wikipedia.org/wiki/X86">http://en.wikipedia.org/wiki/X86</a></li>
<li><a rel="nofollow" class="external text" href="http://www.bravegnu.org/gnu-eprog/index.html">Embedded Programming with the GNU Toolchain</a></li>
</ul>
<dl>
<dt>Floating-point</dt>
</dl>
<ul>
<li><a rel="nofollow" class="external free" href="http://www.rsdn.ru/article/alg/fastpow.xml">http://www.rsdn.ru/article/alg/fastpow.xml</a> — Возведение числа в действительную степень. Варианты алгоритма возведения в степень: повышение точности и ускорение</li>
</ul>
<dl>
<dt>Операционные системы и особенности реализации</dt>
</dl>
<ul>
<li><a rel="nofollow" class="external free" href="http://www.trilithium.com/johan/2005/08/linux-gate/">http://www.trilithium.com/johan/2005/08/linux-gate/</a> — Что такое linux-gate.so.1?</li>
<li><a rel="nofollow" class="external free" href="http://hdante.blogspot.com/2007/02/new-style-system-call-in-linux-x86-ref.html">http://hdante.blogspot.com/2007/02/new-style-system-call-in-linux-x86-ref.html</a></li>
<li><a rel="nofollow" class="external free" href="http://hdante.blogspot.com/2007/02/getting-vsyscall-address-from-elf.html">http://hdante.blogspot.com/2007/02/getting-vsyscall-address-from-elf.html</a></li>
</ul>
<dl>
<dt>Inline Assembly</dt>
</dl>
<ul>
<li><a rel="nofollow" class="external free" href="http://www.ibm.com/developerworks/library/l-ia.html">http://www.ibm.com/developerworks/library/l-ia.html</a> — Inline assembly for x86 in Linux</li>
<li><a rel="nofollow" class="external free" href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a> — GCC Inline Assembly HOWTO</li>
</ul>
<dl>
<dt>x86-64 (AMD64 и Intel 64)</dt>
</dl>
<ul>
<li><a class="external free" href="https://en.wikipedia.org/wiki/X86-64">http://en.wikipedia.org/wiki/X86-64</a> — x86-64: общая информация, терминология, история</li>
<li><a rel="nofollow" class="external free" href="http://www.x86-64.org/documentation/assembly.html">http://www.x86-64.org/documentation/assembly.html</a></li>
</ul>
<hr>
<div class="references-small" style="">
<ol class="references">
<li id="cite_note-1"><b><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#cite_ref-1">↑</a></b> <span class="reference-text">Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1: Basic Architecture, 3.2 Overview of the basic execution environment</span></li>
<li id="cite_note-2"><b><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#cite_ref-2">↑</a></b> <span class="reference-text">Intel® 64 and IA-32 Architectures Software Developer’s Manual, 4.1 Instructions (N-Z), PUSH</span></li>
<li id="cite_note-3"><b><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#cite_ref-3">↑</a></b> <span class="reference-text">Intel® 64 and IA-32 Architectures Optimization Reference Manual, 3.5.1.3 Using LEA</span></li>
<li id="cite_note-4"><b><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#cite_ref-4">↑</a></b> <span class="reference-text">Intel® 64 and IA-32 Architectures Optimization Reference Manual, 3.5.1.7 Compares</span></li>
<li id="cite_note-5"><b><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#cite_ref-5">↑</a></b> <span class="reference-text">Intel® 64 and IA-32 Architectures Optimization Reference Manual, 3.5.1.6 Clearing Registers and Dependency Breaking Idioms</span></li>
</ol>
</div>


<!-- 
NewPP limit report
Parsed by mw1218
Cached time: 20160320183334
Cache expiry: 2592000
Dynamic content: false
CPU time usage: 0.179 seconds
Real time usage: 0.232 seconds
Preprocessor visited node count: 1460/1000000
Preprocessor generated node count: 0/1500000
Post‐expand include size: 10276/2097152 bytes
Template argument size: 7926/2097152 bytes
Highest expansion depth: 6/40
Expensive parser function count: 0/500
Number of Wikibase entities loaded: 0-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%   86.630      1 - -total
 16.38%   14.186      5 - Шаблон:Внимание
 16.34%   14.155      1 - Шаблон:Эпиграф
 10.20%    8.838      1 - Шаблон:Reflist
  9.00%    7.795      1 - Шаблон:Qif
  8.49%    7.353      5 - Шаблон:Ambox
  5.88%    5.096      1 - Шаблон:Подпись
  2.57%    2.229      1 - Шаблон:Info
-->

<!-- Saved in parser cache with key ruwikibooks:pcache:idhash:6230-0!*!0!!ru!4!*!math=0 and timestamp 20160320183334 and revision id 122296
 -->
<noscript>&lt;img src="//ru.wikibooks.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" /&gt;</noscript></div>					<div class="printfooter">
						Источник — «<a dir="ltr" href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;oldid=122296">https://ru.wikibooks.org/w/index.php?title=Ассемблер_в_Linux_для_программистов_C&amp;oldid=122296</a>»					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8" title="Служебная:Категории">Категория</a>: <ul><li><a href="https://ru.wikibooks.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80" title="Категория:Ассемблер">Ассемблер</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Навигация</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Персональные инструменты</h3>
						<ul>
							<li id="pt-anonuserpage">Вы не представились системе</li><li id="pt-anontalk"><a href="https://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9C%D0%BE%D1%91_%D0%BE%D0%B1%D1%81%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5" title="Страница обсуждений для моего IP [alt-shift-n]" accesskey="n">Обсуждение</a></li><li id="pt-anoncontribs"><a href="https://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9C%D0%BE%D0%B9_%D0%B2%D0%BA%D0%BB%D0%B0%D0%B4" title="Список правок, сделанных с этого IP-адреса [alt-shift-y]" accesskey="y">Вклад</a></li><li id="pt-createaccount"><a href="https://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%92%D1%85%D0%BE%D0%B4&amp;returnto=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80+%D0%B2+Linux+%D0%B4%D0%BB%D1%8F+%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2+C&amp;type=signup" title="Мы предлагаем вам создать учётную запись и войти в систему, хотя это и не обязательно.">Создать учётную запись</a></li><li id="pt-login"><a href="https://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%92%D1%85%D0%BE%D0%B4&amp;returnto=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80+%D0%B2+Linux+%D0%B4%D0%BB%D1%8F+%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2+C" title="Здесь можно зарегистрироваться в системе, но это необязательно. [alt-shift-o]" accesskey="o">Войти</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Пространства имён</h3>
						<ul>
															<li id="ca-nstab-main" class="selected"><span><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C" title="Просмотр основной страницы [alt-shift-c]" accesskey="c">Учебник</a></span></li>
															<li id="ca-talk"><span><a href="https://ru.wikibooks.org/wiki/%D0%9E%D0%B1%D1%81%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5:%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C" title="Обсуждение основной страницы [alt-shift-t]" accesskey="t" rel="discussion">Обсуждение</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label" tabindex="0">
							<span>Варианты</span><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#" tabindex="-1"></a>
						</h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Просмотры</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C">Читать</a></span></li>
															<li id="ca-edit"><span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=edit" title="Редактировать данную страницу [alt-shift-e]" accesskey="e">Править</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=history" title="Журнал изменений страницы [alt-shift-h]" accesskey="h">История</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label" tabindex="0"><span>Ещё</span><a href="https://ru.wikibooks.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C#" tabindex="-1"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Поиск</label>
						</h3>

						<form action="https://ru.wikibooks.org/w/index.php" id="searchform">
							<div id="simpleSearch">
							<input type="search" name="search" placeholder="Поиск" title="Искать в Викиучебнике [alt-shift-f]" accesskey="f" id="searchInput" tabindex="1" autocomplete="off"><input type="hidden" value="Служебная:Поиск" name="title"><input type="submit" name="go" value="Перейти" title="Перейти к странице, имеющей в точности такое название" id="searchButton" class="searchButton">							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="https://ru.wikibooks.org/wiki/%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Перейти на заглавную страницу"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Навигация</h3>

			<div class="body">
									<ul>
						<li id="n-mainpage"><a href="https://ru.wikibooks.org/wiki/%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Перейти на заглавную страницу [alt-shift-z]" accesskey="z">Заглавная страница</a></li><li id="n-catalog"><a href="https://ru.wikibooks.org/wiki/%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3_%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA%D0%BE%D0%B2">Каталог учебников</a></li><li id="n-cookbook"><a href="https://ru.wikibooks.org/wiki/%D0%9A%D1%83%D0%BB%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%B0%D1%8F_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0">Кулинарная книга</a></li><li id="n-randompage"><a href="https://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%BB%D1%83%D1%87%D0%B0%D0%B9%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Посмотреть случайно выбранную страницу [alt-shift-x]" accesskey="x">Случайная статья</a></li>					</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-participation" aria-labelledby="p-participation-label">
			<h3 id="p-participation-label">Участие</h3>

			<div class="body">
									<ul>
						<li id="n-help"><a href="https://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0" title="Место, где можно получить справку">Справка</a></li><li id="n-forum"><a href="https://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%9E%D0%B1%D1%89%D0%B8%D0%B9_%D1%84%D0%BE%D1%80%D1%83%D0%BC">Форум</a></li><li id="n-recentchanges"><a href="https://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8" title="Список последних изменений [alt-shift-r]" accesskey="r">Свежие правки</a></li><li id="n-newpages"><a href="https://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9D%D0%BE%D0%B2%D1%8B%D0%B5_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B">Новые страницы</a></li><li id="n-sitesupport"><a href="https://donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&amp;utm_medium=sidebar&amp;utm_campaign=C13_ru.wikibooks.org&amp;uselang=ru" title="Поддержите нас">Пожертвовать</a></li>					</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Инструменты</h3>

			<div class="body">
									<ul>
						<li id="t-whatlinkshere"><a href="https://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8_%D1%81%D1%8E%D0%B4%D0%B0/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C" title="Список всех страниц, ссылающихся на данную [alt-shift-j]" accesskey="j">Ссылки сюда</a></li><li id="t-recentchangeslinked"><a href="https://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C" title="Последние изменения в страницах, на которые ссылается эта страница [alt-shift-k]" accesskey="k">Связанные правки</a></li><li id="t-specialpages"><a href="https://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%BF%D0%B5%D1%86%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B" title="Список служебных страниц [alt-shift-q]" accesskey="q">Спецстраницы</a></li><li id="t-permalink"><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;oldid=122296" title="Постоянная ссылка на эту версию страницы">Постоянная ссылка</a></li><li id="t-info"><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;action=info" title="Подробнее об этой странице">Сведения о&nbsp;странице</a></li><li id="t-cite"><a href="https://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A6%D0%B8%D1%82%D0%B0%D1%82%D0%B0&amp;page=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;id=122296" title="Информация о том, как цитировать эту страницу">Цитировать страницу</a></li>					</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-coll-print_export" aria-labelledby="p-coll-print_export-label">
			<h3 id="p-coll-print_export-label">Печать/экспорт</h3>

			<div class="body">
									<ul>
						<li id="coll-create_a_book"><a href="https://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F_%D0%BA%D0%BD%D0%B8%D0%B3&amp;bookcmd=book_creator&amp;referer=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80+%D0%B2+Linux+%D0%B4%D0%BB%D1%8F+%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2+C">Создать книгу</a></li><li id="coll-download-as-rdf2latex"><a href="https://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F_%D0%BA%D0%BD%D0%B8%D0%B3&amp;bookcmd=render_article&amp;arttitle=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80+%D0%B2+Linux+%D0%B4%D0%BB%D1%8F+%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2+C&amp;returnto=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80+%D0%B2+Linux+%D0%B4%D0%BB%D1%8F+%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2+C&amp;oldid=122296&amp;writer=rdf2latex">Скачать как PDF</a></li><li id="t-print"><a href="https://ru.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;printable=yes" title="Версия этой страницы для печати [alt-shift-p]" accesskey="p">Версия для печати</a></li>					</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-lang" aria-labelledby="p-lang-label"><span class="uls-settings-trigger" title="Установки языка" tabindex="0" role="button" aria-haspopup="true"></span>
			<h3 id="p-lang-label">Языки</h3>

			<div class="body">
									<ul>
											</ul>
				<div class="after-portlet after-portlet-lang"><span class="wb-langlinks-add wb-langlinks-link"><a href="https://www.wikidata.org/wiki/Special:NewItem?site=ruwikibooks&amp;page=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80+%D0%B2+Linux+%D0%B4%D0%BB%D1%8F+%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2+C" title="Добавить интервики-ссылки" class="wbc-editpage">Добавить ссылки</a></span></div>			</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> Последнее изменение этой страницы: 15:35, 2 октября 2015.</li>
											<li id="footer-info-copyright">Текст доступен по <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.ru">лицензии Creative Commons Attribution-ShareAlike</a>, в отдельных случаях могут действовать дополнительные условия. Подробнее см. <a href="https://wikimediafoundation.org/wiki/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Условия использования</a>.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="https://wikimediafoundation.org/wiki/Privacy_policy" title="wmf:Privacy policy">Политика конфиденциальности</a></li>
											<li id="footer-places-about"><a href="https://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%9E%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5" title="Викиучебник:Описание">Описание Викиучебника</a></li>
											<li id="footer-places-disclaimer"><a href="https://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%9E%D1%82%D0%BA%D0%B0%D0%B7_%D0%BE%D1%82_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="Викиучебник:Отказ от ответственности">Отказ от ответственности</a></li>
											<li id="footer-places-developers"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute">Разработчики</a></li>
											<li id="footer-places-cookiestatement"><a href="https://wikimediafoundation.org/wiki/Cookie_statement">Соглашение о Cookie</a></li>
											<li id="footer-places-mobileview"><a href="https://ru.m.wikibooks.org/w/index.php?title=%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80_%D0%B2_Linux_%D0%B4%D0%BB%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2_C&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Мобильная версия</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
							<a href="https://wikimediafoundation.org/"><img src="./Ассемблер в Linux для программистов C — Викиучебник_files/wikimedia-button.png" srcset="/static/images/wikimedia-button-1.5x.png 1.5x, /static/images/wikimedia-button-2x.png 2x" width="88" height="31" alt="Wikimedia Foundation"></a>						</li>
											<li id="footer-poweredbyico">
							<a href="https://www.mediawiki.org/"><img src="./Ассемблер в Linux для программистов C — Викиучебник_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/w/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /w/resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"></a>						</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>(window.RLQ = window.RLQ || []).push(function () {
mw.loader.state({"ext.globalCssJs.site":"ready","ext.globalCssJs.user":"ready","user":"ready","user.groups":"ready"});mw.loader.load(["ext.cite.a11y","mediawiki.toc","mediawiki.action.view.postEdit","site","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.eventLogging.subscriber","ext.gadget.edittop","mmv.bootstrap.autostart","ext.visualEditor.targetLoader","ext.wikimediaEvents","ext.navigationTiming","schema.UniversalLanguageSelector","ext.uls.eventlogger","ext.uls.interlanguage"]);
} );</script><script>(window.RLQ = window.RLQ || []).push(function () {
mw.config.set({"wgBackendResponseTime":73,"wgHostname":"mw1218"}); /* @nomin */
} );</script>
	

<div class="suggestions" style="display: none; font-size: 13px;"><div class="suggestions-results"></div><div class="suggestions-special"></div></div></body></html>