Синтаксис комманд - продолжение

http://cs.mipt.ru/fileadmin/assembler/severov/2016/05-mashinnyi___uroven_2_Upravlenie.pdf

http://cs.mipt.ru/fileadmin/assembler/severov/2016/06-mashinnyi___uroven_3_Procedury.pdf


Пример программы HELLO WORLD

```asm
.data                         /* поместить следующее в сегмент данных
                                                                    */
 
hello_str:                    /* наша строка                        */
        .string "Hello, world!\n"
 
                              /* длина строки                       */
        .set hello_str_length, . - hello_str - 1
 
.text                         /* поместить следующее в сегмент кода */
 
.globl  main                  /* main - глобальный символ, видимый
                                 за пределами текущего файла        */
.type   main, @function       /* main - функция (а не данные)       */
 
 
main:
        movl    $4, %eax      /* поместить номер системного вызова
                                 write = 4 в регистр %eax           */
 
        movl    $1, %ebx      /* первый параметр - в регистр %ebx;
                                 номер файлового дескриптора 
                                 stdout - 1                         */
 
        movl    $hello_str, %ecx  /* второй параметр - в регистр %ecx;
                                     указатель на строку            */
 
        movl    $hello_str_length, %edx /* третий параметр - в регистр
                                           %edx; длина строки       */
 
        int     $0x80         /* вызвать прерывание 0x80            */
 
        movl    $1, %eax      /* номер системного вызова exit - 1   */
        movl    $0, %ebx      /* передать 0 как значение параметра  */
        int     $0x80         /* вызвать exit(0)                    */
 
        .size   main, . - main    /* размер функции main            */
```

Компиляция:
```bash
gcc file.s -o file
```

В случае использование _start вместо main нужно компилить:

```bash
gcc -c file.s
ld -s -o file file.o
```

Некоторые секции:

1. .text — скомпилированный машинный код

2. .data — глобальные и статические переменные;

3. .rodata — аналог .data для неизменяемых данных;

4. .bss — глобальные и статические переменные, которые при старте содержат нулевое значение. Секция bss используется как место для хранения глобальных переменных. Вы можете выделить адресное пространство для секции bss, но Вы не можете указать, какие данные будут загружены в нее до исполнения программы. Когда пpогpамма начинает pаботy, секция bss заполнена нулями.

Программы в Linux состоят из секций, каждая из которых имеет свое назначение. 
Для указания конца секции директив не существует — секция автоматически заканчивается приобъявлении новой секции или в конце программы. 
Порядок следования секций в программе не имеет значения. 
В программе обязательно должна быть объявлена метка с именем main (или _start) – это точка входа в программу. 
Кроме того, метка точки входа должна быть объявлена как глобальный идентификатор директивой GLOBAL main. 


##Данные
Существуют директивы ассемблера, которые размещают в памяти данные, определенные программистом. Аргументы этих директив — список выражений, разделенных запятыми.

.byte — размещает каждое выражение как 1 байт;

.short — 2 байта;

.long — 4 байта;

.quad — 8 байт.


Например:

.byte   0x10, 0xf5, 0x42, 0x55

.long   0xaabbaabb

.short  -123, 456

Также существуют директивы для размещения в памяти строковых литералов:

.ascii "STR" размещает строку STR. Нулевых байтов не добавляет.

.string "STR" размещает строку STR, после которой следует нулевой байт (как в языке Си).

У директивы .string есть синоним .asciz (z от англ. zero — ноль, указывает на добавление нулевого байта).

Строка-аргумент этих директив может содержать стандартные escape-последовательности, которые вы использовали в Си, например, \n, \r, \t, \\, \" и так далее.

Данные нужно помещать в секцию .data.

###обращение к данным

Обращение к данным происходит по меткам. Метка — это просто константа, значение которой — адрес.

```asm
hello_str:
        .string "Hello, world!\n"
```

Сама метка, в отличие от данных, места в памяти программы не занимает. 
Когда компилятор встречает в исходном коде метку, он запоминает текущий адрес и читает код дальше.
В результате компилятор помнит все метки и адреса, на которые они указывают. 
Программист может ссылаться на метки в своём коде. 

Существует специальная псевдометка, указывающая на текущий адрес. **Это метка . (точка).**


Для создания нового символа используется директива `.set`. 
Синтаксис:

```asm
 .set    символ, выражение
```

Например, определим символ foo = 42:

```asm
.set    foo, 42
```

Ещё пример из hello.s:

```asm
hello_str:                              
        .string "Hello, world!\n"                    /* наша строка  */
        .set    hello_str_length, . - hello_str - 1  /* длина строки */
```

Сначала определяется символ hello_str, который содержит адрес строки. 
После этого мы определяем символ hello_str_length, который, судя по названию, содержит длину строки. 
Директива .set позволяет в качестве значения символа использовать арифметические выражения. 
Мы из значения текущего адреса (метка «точка») вычитаем адрес начала строки — получаем длину строки в байтах. Потом мы вычитаем ещё единицу, потому что директива .string добавляет в конце строки нулевой байт (а на экран мы его выводить не хотим).

###выравнивание
Выравнивание задано у каждого фундаментального типа данных (типа данных, которым процессор может оперировать непосредственно). 
Например, выравнивание word — 4 байта. 
Это значит, что данные типа word должны располагаться по адресу, кратному 4 (например, 0x00000100, 0x03284478). 
Архитектура рекомендует, но не требует выравнивания: доступ к невыровненным данным может быть медленнее, но принципиальной разницы нет и ошибки это не вызовет.

Для соблюдения выравнивания в распоряжении программиста есть директива `.p2align`.

```asm
 .p2align степень_двойки, заполнитель, максимум
```
 
Директива .p2align выравнивает текущий адрес до заданной границы. 
Граница выравнивания задаётся как степень числа 2: например, если вы указали .p2align 3 — следующее значение будет выровнено по 8-байтной границе. 
Для выравнивания размещается необходимое количество байт-заполнителей со значением заполнитель. 
Если для выравнивания требуется разместить более чем максимум байт-заполнителей, то выравнивание не выполняется.

Второй и третий аргумент являются необязательными.


##Пример - печать чисел Фиббоначи

```asm
        .global main

        .text
main:
        push    %rbx                    # we have to save this since we use it

        mov     $90, %ecx               # ecx will countdown to 0
        xor     %rax, %rax              # rax will hold the current number
        xor     %rbx, %rbx              # rbx will hold the next number
        inc     %rbx                    # rbx is originally 1
print:
        # We need to call printf, but we are using eax, ebx, and ecx.  printf
        # may destroy eax and ecx so we will save these before the call and
        # restore them afterwards.

        push    %rax                    # caller-save register
        push    %rcx                    # caller-save register

        mov     $format, %rdi           # set 1st parameter (format)
        mov     %rax, %rsi              # set 2nd parameter (current_number)
        xor     %rax, %rax              # because printf is varargs

        # Stack is already aligned because we pushed three 8 byte registers
        call    printf                  # printf(format, current_number)

        pop     %rcx                    # restore caller-save register
        pop     %rax                    # restore caller-save register

        mov     %rax, %rdx              # save the current number
        mov     %rbx, %rax              # next number is now current
        add     %rdx, %rbx              # get the new next number
        dec     %ecx                    # count down
        jnz     print                   # if not done counting, do some more

        pop     %rbx                    # restore rbx before returning
        ret
format:
        .asciz  "%20ld\n"
```
###Соглашения о вызове

1. Порядок, по которому выделяются регистры: Для целых: rdi, rsi, rdx, rcx, r8, r9. Для вещественных: (float, double), xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7
2. Дополнительные параметры помещаются в стек, и удаляются вызывающей функцией после вызова
3. После того как параметры засунуты в стек, сделан call , то адрес возврата лежит в  (%rsp), первый параметр памяти в  8(%rsp), и т.д.
4. Указатель стека %RSP должен быть выровнен по 16-байтной границы перед совершением вызова. Процесс вызова делает push адреса возврата (8 байт) в стек, поэтому, когда функция получает управление - %RSP не выровнен. Нужно сделать это самостоятельно через push или вычитания из 8 из %rsp.
5. Единственные регистры которые вызываемая функция должна сохранить это rbp, rbx, r12, r13, r14, r15. Остальные регистры могут быть изменены вызываемой функцией.
6. Целые возвращаются в rax или rdx:rax, вещественные в xmm0 или xmm1:xmm0 
 

Компиляция c в ассемблер

gcc -S add.c
