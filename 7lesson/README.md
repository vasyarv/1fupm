##Сортировка

Время — основной параметр, характеризующий быстродействие алгоритма. 
Называется также вычислительной сложностью. 
Для упорядочения важны худшее,среднее и лучшее поведение алгоритма в терминах мощности входного множества A. 
Если на вход алгоритму подаётся множество A, то обозначим n = |A|. 
Для типичного алгоритма хорошее поведение — это O(n log n) и плохое поведение — это O(n2). 
Идеальное поведение для упорядочения — O(n). 
Алгоритмы сортировки, использующие только абстрактную операцию сравнения ключей всегда нуждаются по меньшей мере в Ω(n log n) сравнениях. 

Быстрая сортировка (англ. quicksort), часто называемая qsort по имени реализации в стандартной библиотеке языка Си — широко известный алгоритм сортировки, разработанный английским информатиком Чарльзом Хоаром во время его работы в МГУв 1960 году. 
Один из самых быстрых известных универсальных алгоритмов сортировки массивов (в среднем O(n log n) обменов при упорядочении n элементов); 
из-за наличия ряда недостатков на практике обычно используется с некоторыми доработками.

###qsort
"Быстрая сортировка", хоть и была разработана более 40 лет назад, является наиболее широко применяемым и одним их самых эффективных алгоритмов.

Метод основан на подходе "разделяй-и-властвуй". Общая схема такова:

  1. из массива выбирается некоторый опорный элемент a[i],
  2. запускается процедура разделения массива, которая перемещает все ключи, меньшие, либо равные a[i], влево от него, а все ключи, большие, либо равные a[i] - вправо,
  3. теперь массив состоит из двух подмножеств, причем левое меньше, либо равно правого,
![alt text](http://algolist.manual.ru/sort/gif/22.gif)
  4. для обоих подмассивов: если в подмассиве более двух элементов, рекурсивно запускаем для него ту же процедуру.
В конце получится полностью отсортированная последовательность.

Рассмотрим алгоритм подробнее.

  1. На входе массив a[0]...a[N] и опорный элемент p, по которому будет производиться разделение.
  2. Введем два указателя: i и j. В начале алгоритма они указывают, соответственно, на левый и правый конец последовательности.
  3. Будем двигать указатель i с шагом в 1 элемент по направлению к концу массива, пока не будет найден элемент a[i] >= p. Затем аналогичным образом начнем двигать указатель j от конца массива к началу, пока не будет найден a[j] <= p.
  4. Далее, если i <= j, меняем a[i] и a[j] местами и продолжаем двигать i,j по тем же правилам...

Повторяем шаг 3, пока i <= j.

Рассмотрим работу процедуры для массива a[0]...a[6] и опорного элемента p = a[3].

![alt text](http://algolist.manual.ru/sort/gif/23.gif)
