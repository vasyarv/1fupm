##Сортировка

Время — основной параметр, характеризующий быстродействие алгоритма. 
Называется также вычислительной сложностью. 
Для упорядочения важны худшее,среднее и лучшее поведение алгоритма в терминах мощности входного множества A. 
Если на вход алгоритму подаётся множество A, то обозначим n = |A|. 
Для типичного алгоритма хорошее поведение — это O(n log n) и плохое поведение — это O(n2). 
Идеальное поведение для упорядочения — O(n). 
Алгоритмы сортировки, использующие только абстрактную операцию сравнения ключей всегда нуждаются по меньшей мере в Ω(n log n) сравнениях. 

Быстрая сортировка (англ. quicksort), часто называемая qsort по имени реализации в стандартной библиотеке языка Си — широко известный алгоритм сортировки, разработанный английским информатиком Чарльзом Хоаром во время его работы в МГУв 1960 году. 
Один из самых быстрых известных универсальных алгоритмов сортировки массивов (в среднем O(n log n) обменов при упорядочении n элементов); 
из-за наличия ряда недостатков на практике обычно используется с некоторыми доработками.

###Быстрая сортировка
"Быстрая сортировка", хоть и была разработана более 40 лет назад, является наиболее широко применяемым и одним их самых эффективных алгоритмов.

Метод основан на подходе "разделяй-и-властвуй". Общая схема такова:

  1. из массива выбирается некоторый опорный элемент a[i],
  2. запускается процедура разделения массива, которая перемещает все ключи, меньшие, либо равные a[i], влево от него, а все ключи, большие, либо равные a[i] - вправо,
  3. теперь массив состоит из двух подмножеств, причем левое меньше, либо равно правого,
![alt text](http://algolist.manual.ru/sort/gif/22.gif)
  4. для обоих подмассивов: если в подмассиве более двух элементов, рекурсивно запускаем для него ту же процедуру.
В конце получится полностью отсортированная последовательность.

Рассмотрим алгоритм подробнее.

  1. На входе массив a[0]...a[N] и опорный элемент p, по которому будет производиться разделение.
  2. Введем два указателя: i и j. В начале алгоритма они указывают, соответственно, на левый и правый конец последовательности.
  3. Будем двигать указатель i с шагом в 1 элемент по направлению к концу массива, пока не будет найден элемент a[i] >= p. Затем аналогичным образом начнем двигать указатель j от конца массива к началу, пока не будет найден a[j] <= p.
  4. Далее, если i <= j, меняем a[i] и a[j] местами и продолжаем двигать i,j по тем же правилам...

Повторяем шаг 3, пока i <= j.

Рассмотрим работу процедуры для массива a[0]...a[6] и опорного элемента p = a[3].

![alt text](http://algolist.manual.ru/sort/gif/23.gif)

Псевдокод
```c
quickSort ( массив a, верхняя граница N ) {
    Выбрать опорный элемент p - середину массива
    Разделить массив по этому элементу
    Если подмассив слева от p содержит более одного элемента, 
        вызвать quickSort для него. 
    Если подмассив справа от p содержит более одного элемента,
         вызвать quickSort для него. 
}
```

Си

```c
void quickSortR(T* a, long N) {
// На входе - массив a[], a[N] - его последний элемент.

  long i = 0, j = N-1; 		// поставить указатели на исходные места
  T temp, p;

  p = a[ N>>1 ];		// центральный элемент

  // процедура разделения
  do {
    while ( a[i] < p ) i++;
    while ( a[j] > p ) j--;

    if (i <= j) {
      temp = a[i]; a[i] = a[j]; a[j] = temp;
      i++; j--;
    }
  } while ( i<=j );


  // рекурсивные вызовы, если есть, что сортировать 
  if ( j > 0 ) quickSortR(a, j);
  if ( N > i ) quickSortR(a+i, N-i);
}
```
Каждое разделение требует, очевидно, Theta(n) операций. Количество шагов деления(глубина рекурсии) составляет приблизительно log n, если массив делится на более-менее равные части. Таким образом, общее быстродействие: O(n log n), что и имеет место на практике.

Однако, возможен случай таких входных данных, на которых алгоритм будет работать за O(n2) операций. Такое происходит, если каждый раз в качестве центрального элемента выбирается максимум или минимум входной последовательности. Если данные взяты случайно, вероятность этого равна 2/n. И эта вероятность должна реализовываться на каждом шаге... Вообще говоря, малореальная ситуация.

Метод неустойчив. Поведение довольно естественно, если учесть, что при частичной упорядоченности повышаются шансы разделения массива на более равные части.

Сортировка использует дополнительную память, так как приблизительная глубина рекурсии составляет O(log n), а данные о рекурсивных подвызовах каждый раз добавляются в стек.

Модификации можно посмотреть здесь:

http://algolist.manual.ru/sort/quick_sort.php

###qsort
```c
#include<stdlib.h>
void qsort(void *base, size_t nelem, size_t width, int(*fcmp)(const void *, const void *));
```

Функция qsort     применяет    алгоритм    быстрой сортировки  "средний  из  трех".   
Функция   qsortсортирует  содержимое  таблицы  постоянно  вызывая функцию сравнения,  определяемой  пользователем  и адресуемой с помощью указателя fcmp.

base адресует базу (нулевой элемент) сортируемой таблицы.

nelem - число элементов таблицы;

width - размер каждого элемента таблицы в байтах.

Функция *fcmp - функция сравнения -  получает  два аргумента  elem1  и  elem2,  которые  представляют собой два указателя на 2 элемента таблицы. 
Функция сравнения   *fcmp   сравнивает   между  собой  два адресуемых элемента таблицы (*elem1  и  *elem2)  и возвращает  в  зависимости от результата сравнения целое число.

```c
                   Если элементы:        *fcmp возвращает:
                   --------------------------------------------------
                   *elem1<*elem2          целое <0
                   *elem1==*elem2         0
                   *elem1>elem2           целое >0
                   --------------------------------------------------
```

При сравнении  символ "меньше,  чем" (<) означает,что  левый  элемент  в  конце  сортировки   должен оказаться  перед  правым  аргументом.  
Аналогично, символ "больше,  чем" (>) означает,  что  в  конце сортировки  левый  элемент  должен оказаться после правого.

Функция ничего не возвращает

###Пример
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int sort_function(const void *a,const void *b);

char list[5][4] = {"cat", "car", "cab", "cap", "can"};

int main(void)
{
int x;
qsort((void *)&list, 5, sizeof(list[0]), sort_function);
for(x=0; x<5, x++)
    printf("%s\n",list[x]);
}

int sort_function(const void *a,const void *b)
{
   return(strcmp(a,b));
}
```

Вывод:

cab

can

cap

car

cat

