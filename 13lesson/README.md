#Битовые операции. Хранение и представление данных

Рекомендуются лекции:

http://cs.mipt.ru/fileadmin/assembler/severov/2015/02-predstavlenie_dannykh_1.pdf

http://cs.mipt.ru/fileadmin/assembler/severov/2015/03-predstavlenie_dannykh_2.pdf

Скалярными типами данных называются все типы, принимающие целочисленные значения: char, short int, int, long int, long long, а также их signed и unsigned модификации.

Для хранения каждого из этих типов в памяти отводится определенное количество байт. 
Для того, чтобы узнать размер памяти, отводимый для хранения той или иной переменной можно использовать оператор sizeof: например, sizeof(int) возвращает количество байт, необходимых для хранения переменной типа int, а sizeof(A), где A – идентификатор переменной, возвращает количество байт, необходимой для хранения переменной A.

Каждую переменную скалярного типа будем представлять в виде последовательности бит, нумеруя их от 0, биты будем записывать справа налево (то есть бит с номером 0 будет записан самым правым, а самый старший бит – самым левым).

Например, если переменная a объявлена, как unsigned char, то ее можно записать в виде последовательности из 8 бит:

     unsigned char a;
     a=0    ; // 00000000
     a=1    ; // 00000001
     a=2    ; // 00000010
     a=10   ; // 00001010
     a=255  ; // 11111111

Например, если a=10, то в битовой записи a биты с номерами 1 и 3 равны 1, а остальные биты равны 0.

Для двух переменных одинакового скалярного типа определены битовые операции:

& битовое И (AND)

| битовое ИЛИ (OR)

^ битовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)

~ битовое ОТРИЦАНИЕ (NOT) - унарный оператор

Битовые операторы работают следующим образом. Берутся два операнда, и к каждой паре соответствующих бит для левого и правого операнда применяется данная операция, результатом будет переменная того же типа, каждый бит которой есть результат применения соответствующей логической операции к соответствующим битам двух операндов. Рассмотрим пример:

     unsigned char a, b, c, d, e, f;
     a = 5     ; // 00000101
     b = 6     ; // 00000110
     
     c = a & b ; // 00000100 == 4
     d = a | b ; // 00000111 == 7
     e = a ^ b ; // 00000011 == 3
     f =  ~ a  ; // 11111010 == 250
Битовое отрицание числа (величина f в последнем примере) – это число, полученное из исходного заменой всех нулей на единицы и наоборот.

Будьте аккуратны, не путайте логические и битовые операции. Например, 2 && 1 == 1, поскольку применение логического "И" к двум значениям 2 и 1, то есть к двум "истинам", это истина, но 2 & 1 == 0!

Есть еще две операции, работающие с битами: это битовые сдвиги. Их две: сдвиг влево и вправо. Оператор a>>n возвращает число, которое получается из a сдвигом всех бит на n позиций вправо, при этом самые правые n бит отбрасываются. Например:

     unsigned char a, b, c, d, e;
     a = 43      ; // 00101011
     b = a >> 1  ; // 00010101 == 21
     c = a >> 2  ; // 00001010 == 10
     d = a >> 3  ; // 00000101 == 5
     e = a >> 5  ; // 00000001 == 1
Понятно, что для положительных чисел битовый сдвиг числа вправо на n равносилен целочисленному делению на 2n.

Аналогично, битовый сдвиг влево на n бит равносилен (для положительных чисел) умножению на 2n и осуществляется при помощи оператора <<:

     unsigned char a;
     a = 5       ; // 00000101
     b = a << 1  ; // 00001010 == 10
     c = a << 2  ; // 00010100 == 20
     d = 2 << 3  ; // 00101000 == 40

##Представление данных в памяти ЭВМ

Для представления информации в памяти ЭВМ (как числовой так и не числовой) используется двоичный способ кодирования.
Элементарная ячейка памяти ЭВМ имеет длину 8 бит (1 байт). 
Каждый байт имеет свой номер (его называют адресом). 
Наибольшую последовательность бит, которую ЭВМ может обрабатывать как единое целое, называют машинным словом.
Длина машинного слова зависит от разрядности процессора и может быть равной 16, 32 битам и т.д.

Для кодирования символов достаточно одного байта.
При этом можно представить 256 символов (с десятичными кодами от 0 до 255).
Набор символов персональных компьютеров чаще всего является расширением кода ASCII (American Standart Code of Information Interchange - стандартный американский код для обмена информацией).

Один из способов представления целых чисел - дополнительный код. Диапазон значений величин зависит от количества бит памяти отведенных для их хранения. Например, величины типа Integer лежат в диапазоне от
-32768 (-2^15) до 32677 (2^15-1) и для их хранения отводится 2 байта: типа LongInt - в диапазоне от -2^31 до 2^31-1 и размещаются в 4 байтах: типа Word - в диапазоне от 0 до 65535 (216-1) используется 2 байта и т.д.

Как видно из примеров, данные могут быть интерпретированы как числа со знаком, так и без знаков. 
В случае представления величины со знаком самый левый (старший) разряд указывает на положительное число, если содержит нуль, и на отрицательное, если - единицу.

Вообще, разряды нумеруются справа налево, начиная с нуля.

Дополнительный код положительного числа совпадает с его прямым кодом.
Прямой код целого числа может быть представлен следующим образом: число переводиться в двоичную систему счисления, а затем его двоичную запись слева дополняют таким количеством незначащих нулей, сколько требует тип данных, к которому принадлежит число. 
Например, если число **37(10) = 100101(2)** объявлено величиной типа Integer, то его прямым кодом будет **0000000000100101**, а если величиной типа LongInt, то его прямой код будет 00000000000000000000000000100101.
Для более компактной записи чаще используют шестнадцатеричный код.
Полученные коды можно переписать соответственно как 0025(16) и 00000025(16).

Дополнительный код целого отрицательного числа может быть получен по следующему алгоритму:

     1. записать прямой код модуля числа;
     2. инвертировать его (заменить единицы нулями, нули - единицами);
     3. прибавить к инверсионному коду единицу.

Например, запишем дополнительный код числа -37, интерпретируя его как величину типа LongInt:

     1. прямой код числа 37 есть 000000000000000000000000000100101
     2. инверсный код 11111111111111111111111111011010
     3. дополнительный код 11111111111111111111111111011011 или FFFFFFDB(16)
     
При получении по дополнительному коду самого числа, прежде всего, необходимо определить его знак.
Если число окажется положительным, то просто перевести его код в десятичную систему исчисления. 

В случае отрицательного числа необходимо выполнить следующий алгоритм:

     1. вычесть из кода 1;
     2. инвертировать код;
     3. перевести в десятичную систему счисления. Полученное число записать со знаком минус.

Примеры. Запишем числа, соответствующие дополнительным кодам:
0000000000010111.
Поскольку в старшем разряде записан нуль, то результат будет положительным. Это код числа 23.
1111111111000000.
Здесь записан код отрицательного числа, исполняем алгоритм:
1111111111000000(2) - 1(2) = 1111111110111111(2);
0000000001000000;
1000000(2) = 64(10)
Ответ: -64

Несколько иной способ применяется для представления в памяти персонального компьютера действительных чисел. Рассмотрим представление величин с плавающей точкой.

Любое действительное число можно записать в стандартном виде M*10^p, где 1 ≤ M < 10, р- целое число. 
Например, 120100000 = 1,201*10^8. 
Поскольку каждая позиция десятичного числа отличается от соседней на степень числа 10, умножение на 10 эквивалентно сдвигу десятичной запятой на 1 позицию вправо.
Аналогично деление на 10 сдвигает десятичную запятую на позицию влево. 
Поэтому приведенный выше пример можно продолжить: 120100000 = 1,201*10^8 = 0,1201*10^9 = 12,01*10^7... Десятичная запятая плавает в числе и больше не помечает абсолютное место между целой и дробной частями.

В приведённой выше записи М называют мантиссой числа, а р - его порядком. 
Для того чтобы сохранить максимальную точность, вычислительные машины почти всегда хранят мантиссу в нормализованном виде, что означает, что мантисса в данном случае есть число, лежащее между 1(10) и 2(10) (1 ≤ М < 2). 
Основные системы счисления здесь, как уже отмечалось выше,- 2. 
Способ хранения мантиссы с плавающей точкой подразумевает, что двоичная запятая находится на фиксированном месте.
Фактически подразумевается, что двоичная запятая следует после первой двоичной цифры, т.е. нормализация мантиссы делает единичным первый бит, помещая тем самым значение между единицей и двойкой. 
Место, отводимое для числа с плавающей точкой, делится на два поля. 
Одно поле содержит знак и значение мантиссы, а другое содержит знак и значение порядка.

Алгоритм для получения представления действительного числа в памяти ЭВМ:

     1. перевести модуль данного числа в двоичную систему счисления;
     2. нормализовать двоичное число, т.е. записать в виде М*2^p, где М - мантисса (ее целая часть равна 1(2)) и р - порядок, записанный в десятичной системе счисления;
     3. прибавить к порядку смещение и перевести смещенный порядок в двоичную систему счисления;
     4. учитывая знак заданного числа (0 - положительное; 1 - отрицательное), выписать его представление в памяти ЭВМ.

Пример. Запишем код числа -312,3125.

     1. Двоичная запись модуля этого числа имеет вид: 100111000,0101.
     2. Имеем 100111000,0101 = 1,001110000101*28.
     3. Получаем смещенный порядок 8 + 1023 = 1031. Далее имеем 1031(10) = 10000000111(2).

Хорошая статья про представление вещественных чисел:

http://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%87%D0%B8%D1%81%D0%B5%D0%BB
