#Стэк и очередь

Как известно, программы состоят из двух частей — алгоритмов и структур данных. 
В хорошей программе эти составляющие эффективно дополняют друг друга. 
Выбор и реализация структуры данных насколько же важны, как и процедуры для обработки данных. 
Способ организации и доступа к информации обычно определяется природой программируемой задачи. 
Таким образом, для программиста важно иметь в своем распоряжении приемы, подходящие для различных ситуаций.

На определенном уровне абстракции сугубо физические аспекты данных отходят на второй план вследствие введения механизма доступа (data engine) к данным, то есть механизма сохранения и получения информации. 
По существу, физические данные связываются с механизмом доступа, который управляет работой с данными из программы. 

Существует четыре механизма доступа:

  1. Очередь (queue)
  2. Стек (stack)
  3. Связанный список (linked list) 
  4. Двоичное дерево (binary tree) (поговорим в следующий раз!)
  
Каждый из этих методов дает возможность решать задачи определенного класса. 
Эти методы по существу являются механизмами, выполняющими определенные операции сохранения и получения передаваемой им информации на основе получаемых ими запросов. 
Они все сохраняют и получают элемент, здесь под элементом подразумевается информационная единица. 

###Очередь
Очередь — это линейный список информации, работа с которой происходит по принципу "первым пришел — первым вышел" (first-in, first-out); этот принцип (и очередь как структура данных) иногда еще называется FIFO.
Это значит, что первый помещенный в очередь элемент будет получен из нее первым, второй помещенный элемент будет извлечен вторым и т.д. 
Это единственный способ работы с очередью; произвольный доступ к отдельным элементам не разрешается.

Очереди очень часто встречаются в реальной жизни, например, около банков или ресторанов быстрого обслуживания. 
Чтобы представить себе работу очереди, давайте введем две функции: qstore() и qretrieve() (от "store"— "сохранять", "retrieve" — "получать"). 
Функция qstore() помещает элемент в конец очереди, а функция qretrieve() удаляет элемент из начала очереди и возвращает его значение. 


Следует иметь в виду, что операция извлечения удаляет элемент из очереди и уничтожает его, если он не хранится где-нибудь в другом месте. 
Поэтому после извлечения всех элементов очередь будет пуста.

В программировании очереди применяются при решении многих задач. 
Один из наиболее популярных видов таких задач — симуляция. 
Очереди также применяются в планировщиках задач операционных систем и при буферизации ввода/вывода.

###Стэк
Стек (stack) является как бы противоположностью очереди, поскольку он работает по принципу "последним пришел — первым вышел" (last-in, first-out, LIFO). 
Чтобы наглядно представить себе стек, вспомните стопку тарелок. 
Первая тарелка, стоящая на столе, будет использована последней, а последняя тарелка, положенная наверх — первой.
Стеки часто применяются в системном программном обеспечении, включая компиляторы и интерпретаторы.

При работе со стеками операции занесения и извлечения элемента являются основными. 
Данные операции традиционно называются "затолкать в стек" (push) и "вытолкнуть из стека" (pop).
Поэтому для реализации стека необходимо написать две функции: push(), которая "заталкивает" значение в стек, и pop(), которая "выталкивает" значение из стека. 
Также необходимо выделить область памяти, которая будет использоваться в качестве стека. 
Для этой цели можно отвести массив или динамически выделить фрагмент памяти с помощью функций языка С, предусмотренных для динамического распределения памяти. 
Как и в случае очереди, функция извлечения получает из списка элемент и удаляет его, если он не хранится где-либо еше. 

Далее поговорим про списки(главное не запутайтесь!)

###Список(односвязный)

Односвязный список – структура данных, в которой каждый элемент (узел) хранит информацию, а также ссылку на следующий элемент. Последний элемент списка ссылается на NULL.
Для нас односвязный список полезен тем, что

  1. Он очень просто устроен и все алгоритмы интуитивно понятны
  2. Односвязный список – хорошее упражнение для работы с указателями
  3. Его очень просто визаулизировать, это позволяет "в картинках" объяснить алгоритм
  4. Несмотря на свою простоту, односвязные списки часто используются в программировании, так что это не пустое упражнение.
  5. Эта структуру данных можно определить рекурсивно, и она часто используется в рекурсивных алгоритмах.
  
Для простоты рассмотрим односвязный список, который хранит целочисленное значение.
Односвязный список
Односвязный список состоит из узлов. Каждый узел содержит значение и указатель на следующий узел, поэтому представим его в качестве структуры

```c
typedef struct Node {
    int value;
    struct Node *next;
} Node;
```

Чтобы не писать каждый раз struct мы определили новый тип. 

Теперь наша задача написать функцию, которая бы собирала список из значений, которые мы ей передаём. Стандартное имя функции – push, она должна получать в качестве аргумента значение, которое вставит в список. Новое значение будет вставляться в начало списка. Каждый новый элемент списка мы должны создавать на куче. Следовательно, нам будет удобно иметь один указатель на первый элемент списка.

```c
Node *head = NULL;
```

Вначале списка нет и указатель ссылается на NULL. 
Для добавления нового узла необходимо
  1. Выделить под него память.
  2. Задать ему значение
  3. Сделать так, чтобы он ссылался на предыдущий элемент (или на NULL, если его не было)
  4. Перекинуть указатель head на новый узел.
  
Ну а дальше функции работы со списком реализуйте уж сами =)

*Какие еще бывают списки?*
