##Файлы и работа с ними
###Небольшое отступление - коды возврата exit
```c
void exit(int code);
```

int code – определяет статус завершения работы, 0 (`EXIT_SUCCESS`)– нормальное завершение работы, отличное от нуля значение (`EXIT_FAILURE`) – завершение работы с индикацией ошибки.

Функция `exit ()`, завершает работу программы. Аргумент code указывает статус завершения работы. При завершении работы в штатном порядке рекомендуется указывать значение статуса 0 или `EXIT_SUCCESS`. В противном случае рекомендуется указывать отличное от нуля значение или `EXIT_FAILURE`. 


###Введение

Если коротко: файл - именованная область данных на носителе информации.

Для удобства работы с ними каждая операционная система имеет файловую систему, определяющу порядок хранения, доступа и создания файлов.

В Windows и Linux файловые системы разные (в каждой из них возможны как минимум 3 разные файловые системы).
Как правило файловая система состоит из блоков (от 512байт), которые группируются в файлы операционной системой. 
Возможны так же виртуальные файловые системы и сетевые. 

Иерархическая структура файлов в Wndows:
```
C:
  \Program files
      \CDEx
           \CDEx.exe
           \CDEx.hlp
           \mppenc.exe
  \Мои документы
      \Wiki.txt
      \Tornado.jpg
D:
  \Music
      \ABBA
           \1974 Waterloo
           \1976 Arrival
               \Money, Money, Money.ogg
           \1977 The Album
(Иерархическая файловая система Windows/DOS)
```

Иерархическая структура файлов в Unix системах:
```
/
    /usr                                  
        /bin                              
            /arch                        
            /ls                         
            /raw                     
        /lib                           
            /libhistory.so.5.2           
            /libgpm.so.1                
    /home                                
        /lost+found                      
            /host.sh                    
        /guest                         
            /Pictures                   
                /example.png        
            /Video                     
                /matrix.avi            
                /news                
                    /lost_ship.mpeg    
```

В Unix системах имеется ОДНА корневая точка. 
Так же ~ обозначает домашнюю директорию.
И слэш смотрит в другую сторону.

###Права доступа к файлам

Каждый файл в ОС UNIX содержит набор прав доступа, по которому определяется, как пользователь взаимодействует с данным файлом. 
Этот набор хранится в индексном дескрипторе данного файла в виде целого значения, из которого обычно используется 12 битов. 
Причем каждый бит используется как переключатель, разрешая (значение 1) или запрещая (значение 0) тот или иной доступ.

Три первых бита устанавливают различные виды поведения при выполнении. 
Оставшиеся девять делятся на три группы по три, определяя права доступа для владельца, группы и остальных пользователей. Каждая группа задает права на чтение, запись и выполнение.

Базовые биты прав доступа представлены в таблице ниже. 
Там дано восьмеричное значение, задающее соответствующий бит, вид этого бита в первом столбце длинного листинга и право, задаваемое этим битом.

| Восьмеричное значение | Вид в столбце прав доступа | Право или назначение бита                                                     |
|-----------------------|----------------------------|-------------------------------------------------------------------------------|
| 4000                  | ---s------                 | Установленный эффективный идентификатор владельца (бит SUID)                  |
| 2000                  | ------s---                 | Установленный эффективный идентификатор группы (бит SПID)                     |
| 1000                  | ---------t---------T       | Клейкий (sticky) бит. Вид для каталогов и выполняемых файлов, соответственно. |
| 0400                  | -r--------                 | Право владельца на чтение                                                     |
| 0200                  | --w-------                 | Право владельца на запись                                                     |
| 0100                  | ---x------                 | Право владельца на выполнение                                                 |
| 0040                  | ----r-----                 | Право группы на чтение                                                        |
| 0020                  | -----w----                 | Право группы на запись                                                        |
| 0010                  | ------x---                 | Право группы на выполнение                                                    |
| 0004                  | -------r--                 | Право всех прочих на чтение                                                   |
| 0002                  | --------w-                 | Право всех прочих на запись                                                   |
| 0001                  | ---------x                 | Право всех прочих на выполнение                                               |


Бит чтения для всех типов файлов имеет одно и то же значение: он позволяет читать содержимое файла (получать листинг каталога командой ls).

Бит записи также имеет одно и то же значение: он позволяет писать в этот файл, включая и перезапись содержимого. Если у пользователя отсутствует право доступа на запись в каталоге, где находится данный файл, то пользователь не сможет его удалить. Аналогично, без этого же права пользователь не создаст новый файл в каталоге, хотя может сократить длину доступного на запись файла до нуля.

Если для некоторого файла установлен бит выполнения, то файл может выполняться как команда. В случае установки этого бита для каталога, этот каталог можно сделать текущим (перейти в него командой cd).

Установленный бит SUID означает, что доступный пользователю на выполнение файл будет выполняться с правами (с эффективным идентификатором) владельца, а не пользователя, вызвавшего файл (как это обычно происходит).

Установленный бит SGID означает, что доступный пользователю на выполнение файл будет выполняться с правами (с эффективным идентификатором) группы-владельца, а не пользователя, вызвавшего файл (как это обычно происходит).

Если бит SGID установлен для файла, не доступного для выполнения, он означает обязательное блокирование, т.е. неизменность прав доступа на чтение и запись пока файл открыт определенной программой.

Установленный клейкий бит для обычных файлов ранее (во времена PDP-11) означал необходимость сохранить образ программы в памяти после выполнения (для ускорения повторной загрузки). Сейчас при установке обычным пользователем он сбрасывается. Значение этого бита при установке пользователем root зависит от версии ОС и иногда необходимо. Так, в ОС Solaris необходимо устанавливать клейкий бит для обычных файлов, используемых в качестве области подкачки.

Установка клейкого бита для каталога означает, что файл в этом каталоге может быть удален или переименован только в следующих случаях:

  1. пользователем-владельцем файла;
  2. пользователем-владельцем каталога;
  3. если файл доступен пользователю на запись;
  4. пользователем root.

Для расчета прав доступа необходимо сложить восьмеричные значения всех необходимых установленных битов. В результате получится четырехзначное восьмеричное число. Если старший разряд имеет значение 0, его можно не указывать.

Например, если необходимо задать права доступа на чтение, запись и выполнение для владельца, на чтение и выполнение для группы и на выполнение для всех остальных пользователей, получаем следующее восьмеричное значение:

Чтение для владельца:	0400

Запись для владельца:	0200

Выполнение для владельца:	0100

Чтение для группы:	0040

Выполнение для группы:	0010

Выполнение для прочих:	0001

Сумма:	0751

Итак, соответствующие права доступа - 751. В длинном листинге эти права будут представлены в виде "-rwxr-x--x" (при "сложении" буквы с дефисом в символьном представлении остается буква).

###Обзор механизмов ввода-вывода в Linux

В языке C для осуществления файлового ввода-вывода используются механизмы стандартной библиотеки языка, объявленные в заголовочном файле `stdio.h`. 
Как вы вскоре узнаете консольный ввод-вывод - это не более чем частный случай файлового ввода-вывода. 
Однако все эти механизмы являются всего лишь надстройками над низкоуровневыми механизмами ввода-вывода ядра операционной системы.

С точки зрения модели КИС (Клиент-Интерфейс-Сервер), сервером стандартных механизмов ввода вывода языка C (printf, scanf, FILE*, fprintf, fputc и т. д.) является библиотека языка. 
А сервером низкоуровневого ввода-вывода в Linux, которому посвящена эта глава книги, является само ядро операционной системы.

Пользовательские программы взаимодействуют с ядром операционной системы посредством специальных механизмов, называемых системными вызовами (system calls, syscalls). 
Внешне системные вызовы реализованы в виде обычных функций языка C, однако каждый раз вызывая такую функцию, мы обращаемся непосредственно к ядру операционной системы. 
Список всех системных вызовов Linux можно найти в файле `/usr/include/asm/unistd.h`. 
Мы рассмотрим основные системные вызовы, осуществляющие ввод-вывод: `open(), close(), read(), write(), lseek()` и некоторые другие.

###Файловые дескрипторы

В языке C при осуществлении ввода-вывода мы используем указатель `FILE*`. 
Даже функция `printf()` в итоге сводится к вызову `vfprintf(stdout,...)`, разновидности функции `fprintf();` константа `stdout` имеет тип `struct _IO_FILE*`,синонимом которого является тип `FILE*`. 
Это я к тому, что консольный ввод-вывод - это файловый ввод-вывод. 
Стандартный поток ввода, стандартный поток вывода и поток ошибок (как в C, так и в C++) - это файлы. 
В Linux все, куда можно что-то записать или откуда можно что-то прочитать представлено (или может быть представлено) в виде файла. 
Экран, клавиатура, аппаратные и виртуальные устройства, каналы, сокеты - все это файлы. 
Это очень удобно, поскольку ко всему можно применять одни и те же механизмы ввода-вывода, с которыми мы и познакомимся в этой главе. 
Владение механизмами низкоуровневого ввода-вывода дает свободу перемещения данных в Linux. 
Работа с локальными файловыми системами, межсетевое взаимодействие, работа с аппаратными устройствами, - все это осуществляется в Linux посредством низкоуровневого ввода-вывода.

При запуске программы в системе создается новый процесс (здесь есть свои особенности, о которых пока говорить не будем). 
У каждого процесса (кроме init) есть свой родительский процесс (parent process или просто parent), для которого новоиспеченный процесс является дочерним (child process, child). 
Каждый процесс получает копию окружения (environment) родительского процесса. Оказывается, кроме окружения дочерний процесс получает в качестве багажа еще и копию таблицы файловых дескрипторов.

Файловый дескриптор (`file descriptor`) - это целое число (int), соответствующее открытому файлу. 
Дескриптор, соответствующий реально открытому файлу всегда больше или равен нулю. 
Копия таблицы дескрипторов (читай: таблицы открытых файлов внутри процесса) скрыта в ядре. 
Мы не можем получить прямой доступ к этой таблице, как при работе с окружением через environ. 
Можно, конечно, кое-что "вытянуть" через дерево /proc, но нам это не надо. 
Программист должен лишь понимать, что каждый процесс имеет свою копию таблицы дескрипторов. 
В пределах одного процесса все дескрипторы уникальны (даже если они соответствуют одному и тому же файлу или устройству). 
В разных процессах дескрипторы могут совпадать или не совпадать - это не имеет никакого значения, поскольку у каждого процесса свой собственный набор открытых файлов.

Возникает вопрос: сколько файлов может открыть процесс? В каждой системе есть свой лимит, зависящий от конфигурации. Если вы используете bash или ksh (Korn Shell), то можете воспользоваться внутренней командой оболочки ulimit, чтобы узнать это значение.

```bash
$ ulimit -n
1024
$
```

Если вы работаете с оболочкой C-shell (csh, tcsh), то в вашем распоряжении команда limit:

```bash
$ limit descriptors
descriptors 1024
$
```

В командной оболочке, в которой вы работаете (bash, например), открыты три файла: стандартный ввод (дескриптор 0), стандартный вывод (дескриптор 1) и стандартный поток ошибок (дескриптор 2). 
Когда под оболочкой запускается программа, в системе создается новый процесс, который является для этой оболочки дочерним процессом, следовательно, получает копию таблицы дескрипторов своего родителя (то есть все открытые файлы родительского процесса). 
Таким образом программа может осуществлять консольный ввод-вывод через эти дескрипторы. 
На протяжении всей книги мы будем часто играть с этими дескрипторами.

Таблица дескрипторов, помимо всего прочего, содержит информацию о текущей позиции чтения-записи для каждого дескриптора. При открытии файла, позиция чтения-записи устанавливается в ноль. Каждый прочитанный или записанный байт увеличивает на единицу указатель текущей позиции. 

###Системные вызовы для работы с файлами

####Открытие файла: системный вызов open()

Чтобы получить возможность прочитать что-то из файла или записать что-то в файл, его нужно открыть. 
Это делает системный вызов `open()`. 
Этот системный вызов не имеет постоянного списка аргументов (за счет использования механизма `va_arg`); в связи с этим существуют две "разновидности" `open()`.

Ниже приведены адаптированные прототипы системного вызова `open()`.

```c
int open (const char * filename, int flags, mode_t mode);
int open (const char * filename, int flags);
```

Системный вызов `open()` объявлен в заголовочном файле `fcntl.h`. Ниже приведен общий адаптированный прототип `open()`.

```c
int open (const char * filename, int flags, ...);
```

Начнем по порядку. 

Первый аргумент - имя файла в файловой системе в обычной форме: полный путь к файлу (если файл не находится в текущем каталоге) или сокращенное имя (если файл в текущем каталоге).

Второй аргумент - это режим открытия файла, представляющий собой один или несколько флагов открытия, объединенных оператором побитового ИЛИ. 
Список доступных флагов приведен таблице ниже. 
Наиболее часто используют только первые семь флагов. 
Если вы хотите, например, открыть файл в режиме чтения и записи, и при этом автоматически создать файл, если такового не существует, то второй аргумент `open()` будет выглядеть примерно так: `O_RDWR|O_CREAT`. 
Константы-флаги открытия объявлены в заголовочном файле `bits/fcntl.h`, однако не стоит включать этот файл в свои программы, поскольку он уже включен в файл `fcntl.h`.

Третий аргумент используется в том случае, если `open()` создает новый файл. В этом случае файлу нужно задать права доступа (режим), с которыми он появится в файловой системе. 
Права доступа задаются перечислением флагов, объединенных побитовым ИЛИ. 
Вместо флагов можно использовать число (как правило восьмиричное), однако первый способ нагляднее и предпочтительнее. 
Список флагов приведен в таблице ниже. 
Чтобы, например, созданный файл был доступен в режиме "чтение-запись" пользователем и группой и "только чтение" остальными пользователями, - в третьем аргументе `open()` надо указать примерно следующее: `S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH` или `0664`. 
Флаги режима доступа реально объявлены в заголовочном файле `bits/stat.h`, но он не предназначен для включения в пользовательские программы, и вместо него мы должны включать файл `sys/stat.h`. 
Тип mode_t объявлен в заголовочном файле `sys/types.h`.

Если файл был успешно открыт, `open()` возвращает файловый дескриптор, по которому мы будем обращаться к файлу.
Если произошла ошибка, то `open()` возвращает -1. 

####Закрытие файла: системный вызов close()
Системный вызов `close()` закрывает файл. 
Вообще говоря, по завершении процесса все открытые файлы (кроме файлов с дескрипторами 0, 1 и 2) автоматически закрываются. 
Тем не менее, это не освобождает нас от самостоятельного вызова `close()`, когда файл нужно закрыть. 
К тому же, если файлы не закрывать самостоятельно, то соответствующие дескрипторы не освобождаются, что может привести к превышению лимита открытых файлов. 
Простой пример: приложение может быть настроено так, чтобы каждую минуту открывать и перечитывать свой файл конфигурации для проверки обновлений. 
Если каждый раз файл не будет закрываться, то в моей системе, например, приложение может "накрыться медным тазом" примерно через 17 часов. 
Автоматически! 
Кроме того, файловая система Linux поддерживает механизм буферизации. 
Это означает, что данные, которые якобы записываются, реально записываются на носитель (синхронизируются) только через какое-то время, когда система сочтет это правильным и оптимальным. 
Это повышает производительность системы и даже продлевает ресурс жестких дисков. 
Системный вызов `close()` не форсирует запись данных на диск, однако дает больше гарантий того, что данные останутся в целости и сохранности.
Системный вызов `close()` объявлен в файле `unistd.h`. Ниже приведен его адаптированный прототип.

```c
int close (int fd);
```

Очевидно, что единственный аргумент - это файловый дескриптор. 
Возвращаемое значение - ноль в случае успеха, и -1 - в случае ошибки. 
Довольно часто close() вызывают без проверки возвращаемого значения. 
Это не очень грубая ошибка, но, тем не менее, иногда закрытие файла бывает неудачным (в случае неправильного дескриптора, в случае прерывания функции по сигналу или в случае ошибки ввода-вывода, например). 
В любом случае, если программа сообщит пользователю, что файл невозможно закрыть, это хорошо.

####Пример open() close()
Теперь можно написать простенкую программу, использующую системные вызовы `open()` и `close()`.
Мы еще не умеем читать из файлов и писать в файлы, поэтому напишем программу, которая создает файл с именем, переданным в качестве аргумента (argv[1]) и с правами доступа 0600 (чтение и запись для пользователя). 
Ниже приведен исходный код программы.

```c
/* openclose.c */
#include <fcntl.h>	/* open() and O_XXX flags */
#include <sys/stat.h>	/* S_IXXX flags */
#include <sys/types.h>	/* mode_t */
#include <unistd.h>	/* close() */
#include <stdlib.h>
#include <stdio.h>

int main (int argc, char ** argv)
{
	int fd;
	mode_t mode = S_IRUSR | S_IWUSR;
	int flags = O_WRONLY | O_CREAT | O_EXCL;
	if (argc < 2)
	{
		fprintf (stderr, "openclose: Too few arguments\n");
		fprintf (stderr, "Usage: openclose <filename>\n");
		exit (1);
	}

	fd = open (argv[1], flags, mode);
	if (fd < 0)
	{
		fprintf (stderr, "openclose: Cannot open file '%s'\n",
				argv[1]);
		exit (1);
	}
	
	if (close (fd) != 0)
	{
		fprintf (stderr, "Cannot close file (descriptor=%d)\n", fd);
		exit (1);
	}	
	exit (0);
}
```

Обратите внимание, если запустить программу дважды с одним и тем же аргументом, то на второй раз open() выдаст ошибку. 
В этом виноват флаг `O_EXCL` , который "дает добро" только на создание еще не существующих файлов. 
Наглядности ради, флаги открытия и флаги режима мы занесли в отдельные переменные, однако можно было бы сделать так:

```c
fd = open (argv[1], O_WRONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
```

Или так:

```c
fd = open (argv[1], O_WRONLY | O_CREAT | O_EXCL, 0600);
```

####Чтение файла: системный вызов read()

Системный вызов `read()`, объявленный в файле `unistd.h`, позволяет читать данные из файла. 
Системный вызов `read()` читает данные в "сыром" виде, то есть как последовательность байт, без какой-либо интерпретации. Ниже представлен адаптированный прототип `read(`.

```c
ssize_t read (int fd, void * buffer, size_t count);
```

Первый аргумент - это файловый дескриптор. 
Здесь больше сказать нечего. 
Второй аргумент - это указатель на область памяти, куда будут помещаться данные. 
Третий аргумент - количество байт, которые функция read() будет пытаться прочитать из файла.
Возвращаемое значение - количество прочитанных байт, если чтение состоялось и -1, если произошла ошибка. 
Хочу заметить, что если `read()` возвращает значение меньше count, то это не символизирует об ошибке.

Хочу сказать несколько слов о типах. Тип `size_t` в Linux используется для хранения размеров блоков памяти. 
Какой тип реально скрывается за size_t, зависит от архитектуры; как правило это `unsigned long int` или `unsigned int`. 
Тип `ssize_t (Signed SIZE Type)` - это тот же `size_t`, только знаковый. 
Используется, например, в тех случаях, когда нужно сообщить об ошибке, вернув отрицательный размер блока памяти.
Системный вызов read() именно так и поступает.

Теперь напишем программу, которая просто читает файл и выводит его содержимое на экран. Имя файла будет передаваться в качестве аргумента (argv[1]). Ниже приведен исходный код этой программы.

```c
/* myread.c */
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

int main (int argc, char ** argv)
{
	int fd;
	ssize_t ret;
	char ch;
	if (argc < 2)
	{
		fprintf (stderr, "Too few arguments\n");
		exit (1);
	}

	fd = open (argv[1], O_RDONLY);
	if (fd < 0)
	{
		fprintf (stderr, "Cannot open file\n");
		exit (1);
	}	
	
	while ((ret = read (fd, &ch, 1)) > 0)
	{
		putchar (ch);
	}

	if (ret < 0)
	{
		fprintf (stderr, "myread: Cannot read file\n");
		exit (1);
	}
	close (fd);
	exit (0);
}
```

В этом примере используется укороченная версия `open()`, так как файл открывается только для чтения. 
В качестве буфера (второй аргумент `read()`) мы передаем адрес переменной типа `char`. 
По этому адресу будут считываться данные из файла (по одному байту за раз) и передаваться на стандартный вывод.
Цикл чтения файла заканчивается, когда `read()` возвращает нуль (нечего больше читать) или -1 (ошибка). 
Системный вызов `close()` закрывает файл.

Как можно заметить, в нашем примере системный вызов `read()` вызывается ровно столько раз, сколько байт содержится в файле. 
Иногда это действительно нужно, но не здесь. 
Чтение-запись посимвольным методом (как в нашем примере) значительно замедляет процесс ввода-вывода за счет многократных обращений к системным вызовам. 
По этой же причине возрастает вероятность возникновения ошибки. 
Если нет действительной необходимости, файлы нужно читать блоками. 
Ниже приведен исходный код программы, которая делает то же самое, что и предыдущий пример, но с использованием блочного чтения файла. 
Размер блока установлен в 64 байта.

```c
/* myread1.c */
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

#define BUFFER_SIZE	64

int main (int argc, char ** argv)
{
	int fd;
	ssize_t read_bytes;
	char buffer[BUFFER_SIZE+1];
	if (argc < 2)
	{
		fprintf (stderr, "Too few arguments\n");
		exit (1);
	}

	fd = open (argv[1], O_RDONLY);
	if (fd < 0)
	{
		fprintf (stderr, "Cannot open file\n");
		exit (1);
	}	
	
	while ((read_bytes = read (fd, buffer, BUFFER_SIZE)) > 0)
	{
		buffer[read_bytes] = 0; /* Null-terminator for C-string */
		fputs (buffer, stdout);
	}

	if (read_bytes < 0)
	{
		fprintf (stderr, "myread: Cannot read file\n");
		exit (1);
	}
	close (fd);
	exit (0);
}
```

Теперь можно примерно оценить и сравнить скорость работы двух примеров. Для этого надо выбрать в системе достаточно большой файл (бинарник ядра или видеофильм, например) и посмотреть на то, как быстро читаются эти файлы:

```bash
$ time ./myread /boot/vmlinuz > /dev/null

real    0m1.443s
user    0m0.383s
sys     0m1.039s
$ time ./myread1 /boot/vmlinuz > /dev/null

real    0m0.055s
user    0m0.010s
sys     0m0.023s
$              
```

####Запись в файл: системный вызов write()

Для записи данных в файл используется системный вызов `write()`. 
Ниже представлен его прототип.

```c
ssize_t write (int fd, const void * buffer, size_t count);
```

Как видите, прототип `write()` отличается от `read()` только спецификатором const во втором аргументе. 
В принципе `write()` выполняет процедуру, обратную `read()`: записывает count байтов из буфера `buffer` в файл с дескриптором fd, возвращая количество записанных байтов или -1 в случае ошибки. 

Так просто, что можно сразу переходить к примеру. 
За основу возьмем программу myread1 из предыдущего раздела.

```c
/* rw.c */
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>	/* read(), write(), close() */
#include <fcntl.h>	/* open(), O_RDONLY */
#include <sys/stat.h>	/* S_IRUSR */
#include <sys/types.h>	/* mode_t */

#define BUFFER_SIZE	64

int main (int argc, char ** argv)
{
	int fd;
	ssize_t read_bytes;
	ssize_t written_bytes;
	char buffer[BUFFER_SIZE];
	if (argc < 2)
	{
		fprintf (stderr, "Too few arguments\n");
		exit (1);
	}

	fd = open (argv[1], O_RDONLY);
	if (fd < 0)
	{
		fprintf (stderr, "Cannot open file\n");
		exit (1);
	}	
	
	while ((read_bytes = read (fd, buffer, BUFFER_SIZE)) > 0)
	{		
		/* 1 == stdout */
		written_bytes = write (1, buffer, read_bytes);
		if (written_bytes != read_bytes)
		{
			fprintf (stderr, "Cannot write\n");
			exit (1);
		}
	}

	if (read_bytes < 0)
	{
		fprintf (stderr, "myread: Cannot read file\n");
		exit (1);
	}
	close (fd);
	exit (0);
}
```

В этом примере нам уже не надо изощеряться в попытках вставить нуль-терминатор в строку для записи, поскольку системный вызов write() не запишет большее количество байт, чем мы ему указали. 
В данном случае для демонстрации write() мы просто записывали данные в файл с дескриптором 1, то есть в стандартный вывод. 
Но прежде, чем переходить к чтению следующего раздела, попробуйте самостоятельно записать что-нибудь (при помощи write(), естественно) в обычный файл. 
Когда будете открывать файл для записи, обратите пожалуйста внимание на флаги `O_TRUNC, O_CREAT,O_APPEND`. Подумайте, все ли флаги сочетаются между собой по смыслу.
