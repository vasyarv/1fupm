##Файлы и работа с ними
###Небольшое отступление - коды возврата exit
```c
void exit(int code);
```

int code – определяет статус завершения работы, 0 (`EXIT_SUCCESS`)– нормальное завершение работы, отличное от нуля значение (`EXIT_FAILURE`) – завершение работы с индикацией ошибки.

Функция `exit ()`, завершает работу программы. Аргумент code указывает статус завершения работы. При завершении работы в штатном порядке рекомендуется указывать значение статуса 0 или `EXIT_SUCCESS`. В противном случае рекомендуется указывать отличное от нуля значение или `EXIT_FAILURE`. 


###Введение

Если коротко: файл - именованная область данных на носителе информации.

Для удобства работы с ними каждая операционная система имеет файловую систему, определяющу порядок хранения, доступа и создания файлов.

В Windows и Linux файловые системы разные (в каждой из них возможны как минимум 3 разные файловые системы).
Как правило файловая система состоит из блоков (от 512байт), которые группируются в файлы операционной системой. 
Возможны так же виртуальные файловые системы и сетевые. 

Иерархическая структура файлов в Wndows:
```
C:
  \Program files
      \CDEx
           \CDEx.exe
           \CDEx.hlp
           \mppenc.exe
  \Мои документы
      \Wiki.txt
      \Tornado.jpg
D:
  \Music
      \ABBA
           \1974 Waterloo
           \1976 Arrival
               \Money, Money, Money.ogg
           \1977 The Album
(Иерархическая файловая система Windows/DOS)
```

Иерархическая структура файлов в Unix системах:
```
/
    /usr                                  
        /bin                              
            /arch                        
            /ls                         
            /raw                     
        /lib                           
            /libhistory.so.5.2           
            /libgpm.so.1                
    /home                                
        /lost+found                      
            /host.sh                    
        /guest                         
            /Pictures                   
                /example.png        
            /Video                     
                /matrix.avi            
                /news                
                    /lost_ship.mpeg    
```

В Unix системах имеется ОДНА корневая точка. 
Так же ~ обозначает домашнюю директорию.
И слэш смотрит в другую сторону.

###Права доступа к файлам

Каждый файл в ОС UNIX содержит набор прав доступа, по которому определяется, как пользователь взаимодействует с данным файлом. 
Этот набор хранится в индексном дескрипторе данного файла в виде целого значения, из которого обычно используется 12 битов. 
Причем каждый бит используется как переключатель, разрешая (значение 1) или запрещая (значение 0) тот или иной доступ.

Три первых бита устанавливают различные виды поведения при выполнении. 
Оставшиеся девять делятся на три группы по три, определяя права доступа для владельца, группы и остальных пользователей. Каждая группа задает права на чтение, запись и выполнение.

Базовые биты прав доступа представлены в таблице ниже. 
Там дано восьмеричное значение, задающее соответствующий бит, вид этого бита в первом столбце длинного листинга и право, задаваемое этим битом.

| Восьмеричное значение | Вид в столбце прав доступа | Право или назначение бита                                                     |
|-----------------------|----------------------------|-------------------------------------------------------------------------------|
| 4000                  | ---s------                 | Установленный эффективный идентификатор владельца (бит SUID)                  |
| 2000                  | ------s---                 | Установленный эффективный идентификатор группы (бит SПID)                     |
| 1000                  | ---------t---------T       | Клейкий (sticky) бит. Вид для каталогов и выполняемых файлов, соответственно. |
| 0400                  | -r--------                 | Право владельца на чтение                                                     |
| 0200                  | --w-------                 | Право владельца на запись                                                     |
| 0100                  | ---x------                 | Право владельца на выполнение                                                 |
| 0040                  | ----r-----                 | Право группы на чтение                                                        |
| 0020                  | -----w----                 | Право группы на запись                                                        |
| 0010                  | ------x---                 | Право группы на выполнение                                                    |
| 0004                  | -------r--                 | Право всех прочих на чтение                                                   |
| 0002                  | --------w-                 | Право всех прочих на запись                                                   |
| 0001                  | ---------x                 | Право всех прочих на выполнение                                               |


Бит чтения для всех типов файлов имеет одно и то же значение: он позволяет читать содержимое файла (получать листинг каталога командой ls).

Бит записи также имеет одно и то же значение: он позволяет писать в этот файл, включая и перезапись содержимого. Если у пользователя отсутствует право доступа на запись в каталоге, где находится данный файл, то пользователь не сможет его удалить. Аналогично, без этого же права пользователь не создаст новый файл в каталоге, хотя может сократить длину доступного на запись файла до нуля.

Если для некоторого файла установлен бит выполнения, то файл может выполняться как команда. В случае установки этого бита для каталога, этот каталог можно сделать текущим (перейти в него командой cd).

Установленный бит SUID означает, что доступный пользователю на выполнение файл будет выполняться с правами (с эффективным идентификатором) владельца, а не пользователя, вызвавшего файл (как это обычно происходит).

Установленный бит SGID означает, что доступный пользователю на выполнение файл будет выполняться с правами (с эффективным идентификатором) группы-владельца, а не пользователя, вызвавшего файл (как это обычно происходит).

Если бит SGID установлен для файла, не доступного для выполнения, он означает обязательное блокирование, т.е. неизменность прав доступа на чтение и запись пока файл открыт определенной программой.

Установленный клейкий бит для обычных файлов ранее (во времена PDP-11) означал необходимость сохранить образ программы в памяти после выполнения (для ускорения повторной загрузки). Сейчас при установке обычным пользователем он сбрасывается. Значение этого бита при установке пользователем root зависит от версии ОС и иногда необходимо. Так, в ОС Solaris необходимо устанавливать клейкий бит для обычных файлов, используемых в качестве области подкачки.

Установка клейкого бита для каталога означает, что файл в этом каталоге может быть удален или переименован только в следующих случаях:

  1. пользователем-владельцем файла;
  2. пользователем-владельцем каталога;
  3. если файл доступен пользователю на запись;
  4. пользователем root.

Для расчета прав доступа необходимо сложить восьмеричные значения всех необходимых установленных битов. В результате получится четырехзначное восьмеричное число. Если старший разряд имеет значение 0, его можно не указывать.

Например, если необходимо задать права доступа на чтение, запись и выполнение для владельца, на чтение и выполнение для группы и на выполнение для всех остальных пользователей, получаем следующее восьмеричное значение:

Чтение для владельца:	0400

Запись для владельца:	0200

Выполнение для владельца:	0100

Чтение для группы:	0040

Выполнение для группы:	0010

Выполнение для прочих:	0001

Сумма:	0751

Итак, соответствующие права доступа - 751. В длинном листинге эти права будут представлены в виде "-rwxr-x--x" (при "сложении" буквы с дефисом в символьном представлении остается буква).

###Обзор механизмов ввода-вывода в Linux

В языке C для осуществления файлового ввода-вывода используются механизмы стандартной библиотеки языка, объявленные в заголовочном файле `stdio.h`. 
Как вы вскоре узнаете консольный ввод-вывод - это не более чем частный случай файлового ввода-вывода. 
Однако все эти механизмы являются всего лишь надстройками над низкоуровневыми механизмами ввода-вывода ядра операционной системы.

С точки зрения модели КИС (Клиент-Интерфейс-Сервер), сервером стандартных механизмов ввода вывода языка C (printf, scanf, FILE*, fprintf, fputc и т. д.) является библиотека языка. 
А сервером низкоуровневого ввода-вывода в Linux, которому посвящена эта глава книги, является само ядро операционной системы.

Пользовательские программы взаимодействуют с ядром операционной системы посредством специальных механизмов, называемых системными вызовами (system calls, syscalls). 
Внешне системные вызовы реализованы в виде обычных функций языка C, однако каждый раз вызывая такую функцию, мы обращаемся непосредственно к ядру операционной системы. 
Список всех системных вызовов Linux можно найти в файле `/usr/include/asm/unistd.h`. 
Мы рассмотрим основные системные вызовы, осуществляющие ввод-вывод: `open(), close(), read(), write(), lseek()` и некоторые другие.

###Файловые дескрипторы

В языке C при осуществлении ввода-вывода мы используем указатель `FILE*`. 
Даже функция `printf()` в итоге сводится к вызову `vfprintf(stdout,...)`, разновидности функции `fprintf();` константа `stdout` имеет тип `struct _IO_FILE*`,синонимом которого является тип `FILE*`. 
Это я к тому, что консольный ввод-вывод - это файловый ввод-вывод. 
Стандартный поток ввода, стандартный поток вывода и поток ошибок (как в C, так и в C++) - это файлы. 
В Linux все, куда можно что-то записать или откуда можно что-то прочитать представлено (или может быть представлено) в виде файла. 
Экран, клавиатура, аппаратные и виртуальные устройства, каналы, сокеты - все это файлы. 
Это очень удобно, поскольку ко всему можно применять одни и те же механизмы ввода-вывода, с которыми мы и познакомимся в этой главе. 
Владение механизмами низкоуровневого ввода-вывода дает свободу перемещения данных в Linux. 
Работа с локальными файловыми системами, межсетевое взаимодействие, работа с аппаратными устройствами, - все это осуществляется в Linux посредством низкоуровневого ввода-вывода.

При запуске программы в системе создается новый процесс (здесь есть свои особенности, о которых пока говорить не будем). 
У каждого процесса (кроме init) есть свой родительский процесс (parent process или просто parent), для которого новоиспеченный процесс является дочерним (child process, child). 
Каждый процесс получает копию окружения (environment) родительского процесса. Оказывается, кроме окружения дочерний процесс получает в качестве багажа еще и копию таблицы файловых дескрипторов.

Файловый дескриптор (`file descriptor`) - это целое число (int), соответствующее открытому файлу. 
Дескриптор, соответствующий реально открытому файлу всегда больше или равен нулю. 
Копия таблицы дескрипторов (читай: таблицы открытых файлов внутри процесса) скрыта в ядре. 
Мы не можем получить прямой доступ к этой таблице, как при работе с окружением через environ. 
Можно, конечно, кое-что "вытянуть" через дерево /proc, но нам это не надо. 
Программист должен лишь понимать, что каждый процесс имеет свою копию таблицы дескрипторов. 
В пределах одного процесса все дескрипторы уникальны (даже если они соответствуют одному и тому же файлу или устройству). 
В разных процессах дескрипторы могут совпадать или не совпадать - это не имеет никакого значения, поскольку у каждого процесса свой собственный набор открытых файлов.

Возникает вопрос: сколько файлов может открыть процесс? В каждой системе есть свой лимит, зависящий от конфигурации. Если вы используете bash или ksh (Korn Shell), то можете воспользоваться внутренней командой оболочки ulimit, чтобы узнать это значение.

```bash
$ ulimit -n
1024
$
```

Если вы работаете с оболочкой C-shell (csh, tcsh), то в вашем распоряжении команда limit:

```bash
$ limit descriptors
descriptors 1024
$
```

В командной оболочке, в которой вы работаете (bash, например), открыты три файла: стандартный ввод (дескриптор 0), стандартный вывод (дескриптор 1) и стандартный поток ошибок (дескриптор 2). 
Когда под оболочкой запускается программа, в системе создается новый процесс, который является для этой оболочки дочерним процессом, следовательно, получает копию таблицы дескрипторов своего родителя (то есть все открытые файлы родительского процесса). 
Таким образом программа может осуществлять консольный ввод-вывод через эти дескрипторы. 
На протяжении всей книги мы будем часто играть с этими дескрипторами.

Таблица дескрипторов, помимо всего прочего, содержит информацию о текущей позиции чтения-записи для каждого дескриптора. При открытии файла, позиция чтения-записи устанавливается в ноль. Каждый прочитанный или записанный байт увеличивает на единицу указатель текущей позиции. 

###Системные вызовы для работы с файлами

####Открытие файла: системный вызов open()

Чтобы получить возможность прочитать что-то из файла или записать что-то в файл, его нужно открыть. 
Это делает системный вызов `open()`. 
Этот системный вызов не имеет постоянного списка аргументов (за счет использования механизма `va_arg`); в связи с этим существуют две "разновидности" `open()`.

Ниже приведены адаптированные прототипы системного вызова `open()`.

```c
int open (const char * filename, int flags, mode_t mode);
int open (const char * filename, int flags);
```

Системный вызов `open()` объявлен в заголовочном файле `fcntl.h`. Ниже приведен общий адаптированный прототип `open()`.

```c
int open (const char * filename, int flags, ...);
```

Начнем по порядку. 

Первый аргумент - имя файла в файловой системе в обычной форме: полный путь к файлу (если файл не находится в текущем каталоге) или сокращенное имя (если файл в текущем каталоге).

Второй аргумент - это режим открытия файла, представляющий собой один или несколько флагов открытия, объединенных оператором побитового ИЛИ. 
Список доступных флагов приведен таблице ниже. 
Наиболее часто используют только первые семь флагов. 
Если вы хотите, например, открыть файл в режиме чтения и записи, и при этом автоматически создать файл, если такового не существует, то второй аргумент `open()` будет выглядеть примерно так: `O_RDWR|O_CREAT`. 
Константы-флаги открытия объявлены в заголовочном файле `bits/fcntl.h`, однако не стоит включать этот файл в свои программы, поскольку он уже включен в файл `fcntl.h`.

Третий аргумент используется в том случае, если `open()` создает новый файл. В этом случае файлу нужно задать права доступа (режим), с которыми он появится в файловой системе. 
Права доступа задаются перечислением флагов, объединенных побитовым ИЛИ. 
Вместо флагов можно использовать число (как правило восьмиричное), однако первый способ нагляднее и предпочтительнее. 
Список флагов приведен в таблице ниже. 
Чтобы, например, созданный файл был доступен в режиме "чтение-запись" пользователем и группой и "только чтение" остальными пользователями, - в третьем аргументе `open()` надо указать примерно следующее: `S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH` или `0664`. 
Флаги режима доступа реально объявлены в заголовочном файле `bits/stat.h`, но он не предназначен для включения в пользовательские программы, и вместо него мы должны включать файл `sys/stat.h`. 
Тип mode_t объявлен в заголовочном файле `sys/types.h`.

Если файл был успешно открыт, `open()` возвращает файловый дескриптор, по которому мы будем обращаться к файлу.
Если произошла ошибка, то `open()` возвращает -1. 

####Закрытие файла: системный вызов close()
Системный вызов `close()` закрывает файл. 
Вообще говоря, по завершении процесса все открытые файлы (кроме файлов с дескрипторами 0, 1 и 2) автоматически закрываются. 
Тем не менее, это не освобождает нас от самостоятельного вызова `close()`, когда файл нужно закрыть. 
К тому же, если файлы не закрывать самостоятельно, то соответствующие дескрипторы не освобождаются, что может привести к превышению лимита открытых файлов. 
Простой пример: приложение может быть настроено так, чтобы каждую минуту открывать и перечитывать свой файл конфигурации для проверки обновлений. 
Если каждый раз файл не будет закрываться, то в моей системе, например, приложение может "накрыться медным тазом" примерно через 17 часов. 
Автоматически! 
Кроме того, файловая система Linux поддерживает механизм буферизации. 
Это означает, что данные, которые якобы записываются, реально записываются на носитель (синхронизируются) только через какое-то время, когда система сочтет это правильным и оптимальным. 
Это повышает производительность системы и даже продлевает ресурс жестких дисков. 
Системный вызов `close()` не форсирует запись данных на диск, однако дает больше гарантий того, что данные останутся в целости и сохранности.
Системный вызов `close()` объявлен в файле `unistd.h`. Ниже приведен его адаптированный прототип.

```c
int close (int fd);
```

Очевидно, что единственный аргумент - это файловый дескриптор. 
Возвращаемое значение - ноль в случае успеха, и -1 - в случае ошибки. 
Довольно часто close() вызывают без проверки возвращаемого значения. 
Это не очень грубая ошибка, но, тем не менее, иногда закрытие файла бывает неудачным (в случае неправильного дескриптора, в случае прерывания функции по сигналу или в случае ошибки ввода-вывода, например). 
В любом случае, если программа сообщит пользователю, что файл невозможно закрыть, это хорошо.

####Пример open() close()
Теперь можно написать простенкую программу, использующую системные вызовы `open()` и `close()`.
Мы еще не умеем читать из файлов и писать в файлы, поэтому напишем программу, которая создает файл с именем, переданным в качестве аргумента (argv[1]) и с правами доступа 0600 (чтение и запись для пользователя). 
Ниже приведен исходный код программы.

```c
/* openclose.c */
#include <fcntl.h>	/* open() and O_XXX flags */
#include <sys/stat.h>	/* S_IXXX flags */
#include <sys/types.h>	/* mode_t */
#include <unistd.h>	/* close() */
#include <stdlib.h>
#include <stdio.h>

int main (int argc, char ** argv)
{
	int fd;
	mode_t mode = S_IRUSR | S_IWUSR;
	int flags = O_WRONLY | O_CREAT | O_EXCL;
	if (argc < 2)
	{
		fprintf (stderr, "openclose: Too few arguments\n");
		fprintf (stderr, "Usage: openclose <filename>\n");
		exit (1);
	}

	fd = open (argv[1], flags, mode);
	if (fd < 0)
	{
		fprintf (stderr, "openclose: Cannot open file '%s'\n",
				argv[1]);
		exit (1);
	}
	
	if (close (fd) != 0)
	{
		fprintf (stderr, "Cannot close file (descriptor=%d)\n", fd);
		exit (1);
	}	
	exit (0);
}
```

Обратите внимание, если запустить программу дважды с одним и тем же аргументом, то на второй раз open() выдаст ошибку. 
В этом виноват флаг `O_EXCL` , который "дает добро" только на создание еще не существующих файлов. 
Наглядности ради, флаги открытия и флаги режима мы занесли в отдельные переменные, однако можно было бы сделать так:

```c
fd = open (argv[1], O_WRONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
```

Или так:

```c
fd = open (argv[1], O_WRONLY | O_CREAT | O_EXCL, 0600);
```

####Чтение файла: системный вызов read()

Системный вызов `read()`, объявленный в файле `unistd.h`, позволяет читать данные из файла. 
Системный вызов `read()` читает данные в "сыром" виде, то есть как последовательность байт, без какой-либо интерпретации. Ниже представлен адаптированный прототип `read(`.

```c
ssize_t read (int fd, void * buffer, size_t count);
```

Первый аргумент - это файловый дескриптор. 
Здесь больше сказать нечего. 
Второй аргумент - это указатель на область памяти, куда будут помещаться данные. 
Третий аргумент - количество байт, которые функция read() будет пытаться прочитать из файла.
Возвращаемое значение - количество прочитанных байт, если чтение состоялось и -1, если произошла ошибка. 
Хочу заметить, что если `read()` возвращает значение меньше count, то это не символизирует об ошибке.

Хочу сказать несколько слов о типах. Тип `size_t` в Linux используется для хранения размеров блоков памяти. 
Какой тип реально скрывается за size_t, зависит от архитектуры; как правило это `unsigned long int` или `unsigned int`. 
Тип `ssize_t (Signed SIZE Type)` - это тот же `size_t`, только знаковый. 
Используется, например, в тех случаях, когда нужно сообщить об ошибке, вернув отрицательный размер блока памяти.
Системный вызов read() именно так и поступает.

Теперь напишем программу, которая просто читает файл и выводит его содержимое на экран. Имя файла будет передаваться в качестве аргумента (argv[1]). Ниже приведен исходный код этой программы.

```c
/* myread.c */
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

int main (int argc, char ** argv)
{
	int fd;
	ssize_t ret;
	char ch;
	if (argc < 2)
	{
		fprintf (stderr, "Too few arguments\n");
		exit (1);
	}

	fd = open (argv[1], O_RDONLY);
	if (fd < 0)
	{
		fprintf (stderr, "Cannot open file\n");
		exit (1);
	}	
	
	while ((ret = read (fd, &ch, 1)) > 0)
	{
		putchar (ch);
	}

	if (ret < 0)
	{
		fprintf (stderr, "myread: Cannot read file\n");
		exit (1);
	}
	close (fd);
	exit (0);
}
```

В этом примере используется укороченная версия `open()`, так как файл открывается только для чтения. 
В качестве буфера (второй аргумент `read()`) мы передаем адрес переменной типа `char`. 
По этому адресу будут считываться данные из файла (по одному байту за раз) и передаваться на стандартный вывод.
Цикл чтения файла заканчивается, когда `read()` возвращает нуль (нечего больше читать) или -1 (ошибка). 
Системный вызов `close()` закрывает файл.

Как можно заметить, в нашем примере системный вызов `read()` вызывается ровно столько раз, сколько байт содержится в файле. 
Иногда это действительно нужно, но не здесь. 
Чтение-запись посимвольным методом (как в нашем примере) значительно замедляет процесс ввода-вывода за счет многократных обращений к системным вызовам. 
По этой же причине возрастает вероятность возникновения ошибки. 
Если нет действительной необходимости, файлы нужно читать блоками. 
Ниже приведен исходный код программы, которая делает то же самое, что и предыдущий пример, но с использованием блочного чтения файла. 
Размер блока установлен в 64 байта.

```c
/* myread1.c */
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

#define BUFFER_SIZE	64

int main (int argc, char ** argv)
{
	int fd;
	ssize_t read_bytes;
	char buffer[BUFFER_SIZE+1];
	if (argc < 2)
	{
		fprintf (stderr, "Too few arguments\n");
		exit (1);
	}

	fd = open (argv[1], O_RDONLY);
	if (fd < 0)
	{
		fprintf (stderr, "Cannot open file\n");
		exit (1);
	}	
	
	while ((read_bytes = read (fd, buffer, BUFFER_SIZE)) > 0)
	{
		buffer[read_bytes] = 0; /* Null-terminator for C-string */
		fputs (buffer, stdout);
	}

	if (read_bytes < 0)
	{
		fprintf (stderr, "myread: Cannot read file\n");
		exit (1);
	}
	close (fd);
	exit (0);
}
```

Теперь можно примерно оценить и сравнить скорость работы двух примеров. Для этого надо выбрать в системе достаточно большой файл (бинарник ядра или видеофильм, например) и посмотреть на то, как быстро читаются эти файлы:

```bash
$ time ./myread /boot/vmlinuz > /dev/null

real    0m1.443s
user    0m0.383s
sys     0m1.039s
$ time ./myread1 /boot/vmlinuz > /dev/null

real    0m0.055s
user    0m0.010s
sys     0m0.023s
$              
```

####Запись в файл: системный вызов write()

Для записи данных в файл используется системный вызов `write()`. 
Ниже представлен его прототип.

```c
ssize_t write (int fd, const void * buffer, size_t count);
```

Как видите, прототип `write()` отличается от `read()` только спецификатором const во втором аргументе. 
В принципе `write()` выполняет процедуру, обратную `read()`: записывает count байтов из буфера `buffer` в файл с дескриптором fd, возвращая количество записанных байтов или -1 в случае ошибки. 

Так просто, что можно сразу переходить к примеру. 
За основу возьмем программу myread1 из предыдущего раздела.

```c
/* rw.c */
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>	/* read(), write(), close() */
#include <fcntl.h>	/* open(), O_RDONLY */
#include <sys/stat.h>	/* S_IRUSR */
#include <sys/types.h>	/* mode_t */

#define BUFFER_SIZE	64

int main (int argc, char ** argv)
{
	int fd;
	ssize_t read_bytes;
	ssize_t written_bytes;
	char buffer[BUFFER_SIZE];
	if (argc < 2)
	{
		fprintf (stderr, "Too few arguments\n");
		exit (1);
	}

	fd = open (argv[1], O_RDONLY);
	if (fd < 0)
	{
		fprintf (stderr, "Cannot open file\n");
		exit (1);
	}	
	
	while ((read_bytes = read (fd, buffer, BUFFER_SIZE)) > 0)
	{		
		/* 1 == stdout */
		written_bytes = write (1, buffer, read_bytes);
		if (written_bytes != read_bytes)
		{
			fprintf (stderr, "Cannot write\n");
			exit (1);
		}
	}

	if (read_bytes < 0)
	{
		fprintf (stderr, "myread: Cannot read file\n");
		exit (1);
	}
	close (fd);
	exit (0);
}
```

В этом примере нам уже не надо изощеряться в попытках вставить нуль-терминатор в строку для записи, поскольку системный вызов write() не запишет большее количество байт, чем мы ему указали. 
В данном случае для демонстрации write() мы просто записывали данные в файл с дескриптором 1, то есть в стандартный вывод. 
Но прежде, чем переходить к чтению следующего раздела, попробуйте самостоятельно записать что-нибудь (при помощи write(), естественно) в обычный файл. 
Когда будете открывать файл для записи, обратите пожалуйста внимание на флаги `O_TRUNC, O_CREAT,O_APPEND`. Подумайте, все ли флаги сочетаются между собой по смыслу.

###Оберточные функции для работы с файлами

####Открытие файла при помощи fopen
Файл открывается при помощи fopen, которая возвращает информацию потока ввода-вывода, прикреплённого к указанному файлу или другому устройству, с которого идет чтение (или в который идет запись).
В случае неудачи функция возвращает нулевой указатель.

Схожая функция freopen библиотеки Си выполняет аналогичную операцию после первого закрытия любого открытого потока, связанного с её параметрами.

Они определяются как

```c
FILE *fopen(const char *path, const char *mode);
FILE *freopen(const char *path, const char *mode, FILE *fp);
```

Функция fopen по сути представляет собой «обертку» более высокого уровня системного вызова open операционной системы Unix. 
Аналогично, fclose является оберткой системного вызова Unix close, а сама структура FILE языка Си зачастую обращается к соответствующему файловому дескриптору Unix. 

Параметр mode (режим) для fopen и freopen должен быть строковый и начинаться с одной из следующих последовательностей:

| r  | rb  |     | открывает для чтения                                                                                   | Начинает с начала |
|----|-----|-----|--------------------------------------------------------------------------------------------------------|-------------------|
| w  | wb  |     | открывает для записи (создаёт файл в случае его отсутствия). Удаляет содержимое и перезаписывает файл. | Начинает с начала |
| a  | ab  |     | открывает для добавления (создаёт файл в случае его отсутствия)                                        | Начинает с конца  |
| r+ | rb+ | r+b | открывает для чтения и записи                                                                          | Начинает с начала |
| w+ | wb+ | w+b | открывает для чтения и записи. Удаляет содержимое и перезаписывает файл.                               | Начинает с начала |
| a+ | ab+ | a+b | открывает для чтения и записи (добавляет в случае существования файла)                                 | Начинает с конца  |

Значение «b» зарезервировано для двоичного режима С. Стандарт языка Си описывает два вида файлов — текстовые и двоичные — хотя операционная система не требует их различать (однако, для некоторых компиляторов, например LCC, указание 'b' при работе с бинарным файлом принципиально важно!).

*Текстовый файл* — файл, содержащий текст, разбитый на строки при помощи некоторого разделяющего символа окончания строки или последовательности (в Unix — одиночный символ перевода строки\n; в Microsoft Windows за символом перевода строки следует знак возврата каретки)\n\r. 
При считывании байтов из текстового файла, символы конца строки обычно связываются (заменяются) с переводом строки для упрощения обработки. 
При записи текстового файла одиночный символ перевода строки перед записью связывается (заменяется) с специфичной для ОС последовательностью символов конца строки.

*Двоичный файл* — файл, из которого байты считываются и выводятся в «сыром» виде без какого-либо связывания (подстановки).

При открытом файле в режиме обновления ('+' в качестве второго или третьего символа аргумента обозначения режима) и ввод и вывод могут выполняться в одном потоке. 
Тем не менее, запись не может следовать за чтением без промежуточного вызова fflush или функции позиционирования в файле (fseek, fsetpos или rewind), а чтение не может следовать за записью без промежуточного вызова функции позиционирования в файле.

Режимы записи и добавления пытаются создать файл с заданным именем, если такого файла ещё не существует. Как указывалось выше, если эта операция оканчивается неудачей, fopen возвращает NULL.

####Закрытие потока при помощи fclose
Функция fclose принимает один аргумент: указатель на структуру FILE потока для закрытия.
```c
int fclose(FILE *fp);
```

Функция возвращает нуль в случае успеха и EOF в случае неудачи. При нормальном завершении программы функция вызывается автоматически для каждого открытого файла.

####Чтение при помощи fgetc
Функция fgetc применяется для чтения символа из потока.
```c
int fgetc(FILE *fp);
```

В случае успеха, fgetc возвращает следующий байт или символ из потока (зависит от того, файл «двоичный» или «текстовый», как выше обсуждалось). 
В противном случае, fgetc возвращает EOF. 
(Отдельный тип ошибок можно определить вызовом ferror или feof с указателем на файл.)

Стандартный макрос getc также определён в <stdio.h>, успешно работая как fgetc, кроме одного: будучи макросом, он может обрабатывать свои аргументы более одного раза.
Стандартная функция getchar также определена в <stdio.h>, она не принимает аргументов, и эквивалентна getc(stdin).

#####«Ловушка» EOF
Распространённой ошибкой является использование fgetc, getc или getchar для присваивания результата переменной типа char перед сравнением его с EOF. 

Следующий фрагмент кода демонстрирует эту ошибку, а рядом приведён корректный вариант:
```c
//Ошибка
char c;
while ((c = getchar()) != EOF) {
    putchar(c);
}
//Правильно
int c;
while ((c = getchar()) != EOF) {
    putchar(c);
}
```
Нужно учитывать систему, в которой тип char, длина которого составляет 8 бит (в частности, архитектура x86), представляет 256 различных значений. 
getchar может возвращать любой из 256 возможных символов, а также может возвращать EOF для обозначения конца файла, значение которого не может совпадать ни с одним из значений char.

Когда результат getchar присваивается переменной типа char, которая может представить лишь 256 различных значений, происходит вынужденная потеря информации — при сжатии 257 значений в 256 «мест» происходит коллизия. Значение EOF при конвертации в char становится неотличимым от любого из остальных 256 символов. Если этот символ обнаружен в файле, код, приведённый выше, может принять его за признак конца файла, или, что ещё хуже, если тип char — беззнаковый, тогда с учётом того, что EOF — значение отрицательное, оно никогда не сможет стать равным любому беззнаковому char, и таким образом, пример выше не закончится на метке конца файла, а будет выполняться вечно, повторно печатая символ, получающийся при конвертации EOF в char.

В системах, где int и char одинакового размера, даже «правильный» вариант будет работать некорректно из-за сходства EOF и другого символа. Правильным вариантом обработки подобной ситуации является проверка feof и ferror после того, как getchar вернет EOF. Если feofопределит, что конец файла ещё не достигнут, а ferror «сообщит», что ошибок нет, то EOF, возвращённый getchar, может считаться текущим символом. Такие дополнительные проверки делаются редко, так как большинство программистов считает, что их код никогда не будет выполняться на подобных системах с «большимchar». Другой способ состоит в использовании проверки при компиляции, что UINT_MAX > UCHAR_MAX, которая хотя бы предотвратит компиляцию на подобных системах.


####Чтение при помощи fgets
Функция fgets применяется для чтения строки из потока. Считывание происходит до тех пор пока не будет достигнут конец строки или длина строки, в которую происходит считывание. 

Предположим, у нас есть файл some_file.txt с текстом
```c
палиндромы
    А в Енисее - синева.
    А лама мала.
    А лис, он умен - крыса сыр к нему носила. (И. Бабицкий)
```

```c
#include <stdio.h>
#include <string.h>
 
int main (int argc, char* argv[])	/* argc хранит количество параметров, а argv[] указатели на эти параметры. 
					Например, если мы запустим исполняемый файл "fgets_example param1 param2", то argc будет равно 3, а argv[] = {"fgets_example", "param1", "param2"}*/
{
 
	FILE *file; 
	char *fname = "some_file.txt";
	char result_sting[20]; //Строка в 20 символов
 
	file = fopen(fname,"r");
 
	if(file == 0)
	{
		printf("не могу открыть файл '%s'",fname);
		return 0;
	}
 
	int i=0;
	char *real_tail;
 
	while(fgets(result_sting,sizeof(result_sting),file))
	{
		real_tail="";
		printf("Строка %d:Длина строки - %d:",i++,strlen(result_sting));
 
		if(result_sting[strlen(result_sting)-1] == '\n')//проверяем является ли последний элемент в строке символом её окончания
		{
			real_tail="\\n";
			result_sting[strlen(result_sting)-1]='\0';
		};// эта часть кода добавлена лишь для отображения символа конца строки в консоль без перевода на новую строку	
		printf("%s%s\n",result_sting,real_tail);
	}
 
	fclose(file);
 
return 0;
}
```

####Запись в файл при помощи fwrite
fwrite определяется как
```c
int fwrite ( const char * array, size_t size, size_t count, FILE * stream );
```

Функция fwrite записывает блок данных в поток. Таким образом запишется массив элементов array в текущую позицию в потоке. Для каждого элемента запишетсяsize байт. Индикатор позиции в потоке изменится на число байт, записанных успешно. Возвращаемое значение будет равно count в случае успешного завершения записи. В случае ошибки возвращаемое значение будет меньше count.

Следующая программа открывает файл пример.txt, записывает в него строку символов, а затем его закрывает.
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int main(void)
{
    FILE *fp;
    size_t count;
    char const *str = "привет\n";
 
    fp = fopen("пример.txt", "wb");
    if(fp == NULL) {
        perror("ошибка открытия пример.txt");
        return EXIT_FAILURE;
    }
    count = fwrite(str, strlen(str), 1, fp);
    printf("Записано %lu байт. fclose(fp) %s.\n", (unsigned long)count, fclose(fp) == 0 ? "успешно" : "с ошибкой");
 
    fclose(fp);
    return 0;
}
```

####Запись в поток при помощи fputс
Функция fputc применяется для записи символа в поток.
```c
int fputc(int c, FILE *fp);
```

Параметр c «тихо» конвертируется в unsigned char перед выводом. Если прошло успешно, то fputc возвращает записанный символ. Если ошибка, то fputcвозвращает EOF.
Стандартный макрос putc также определён в <stdio.h>, работая в общем случае аналогично fputc, за исключением того момента, что будучи макросом, он может обрабатывать свои аргументы более одного раза.
Стандартная функция putchar, также определённая в <stdio.h>, принимает только первый аргумент, и является эквивалентной putc(c, stdout), где c является упомянутым аргументом.
Пример использования[править | править вики-текст]
Нижеследующая программа на языке Си открывает двоичный файл с названием мойфайл, читает пять байт из него, а затем закрывает файл.
```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void)
{
  char buffer[5] = {0};  /* инициализируем нулями */
  int i, rc;
  FILE *fp = fopen("мойфайл", "rb");
  if (fp == NULL) {
    perror("Ошибка при открытии \"мойфайл\"");
    return EXIT_FAILURE;
  }
  for (i = 0; (rc = getc(fp)) != EOF && i < 5; buffer[i++] = rc)
    ;
  fclose(fp);
  if (i == 5) {
    puts("Прочитанные байты...");
    printf("%x %x %x %x %x\n", buffer[0], buffer[1], buffer[2], buffer[3], buffer[4]);
  } else
    fputs("Ошибка чтения файла.\n", stderr);
  return EXIT_SUCCESS;
}
```

###Флаги

####Флаги общего режима
| Флаг     | Восьмиричное представление | RWX-представление |
|----------|----------------------------|-------------------|
| S_IRWXU  | 700                        | rwx --- ---       |
| S_IRUSR  | 400                        | r-- --- ---       |
| S_IREAD  | 400                        | r-- --- ---       |
| S_IWUSR  | 200                        | -w- --- ---       |
| S_IWRITE | 200                        | -w- --- ---       |
| S_IXUSR  | 100                        | --x --- ---       |
| S_IEXEC  | 100                        | --x --- ---       |
| S_IRWXG  | 70                         | --- rwx ---       |
| S_IRGRP  | 40                         | --- r-- ---       |
| S_IWGRP  | 20                         | --- -w- ---       |
| S_IXGRP  | 10                         | --- --x ---       |
| S_IRWXO  | 7                          | --- --- rwx       |
| S_IROTH  | 4                          | --- --- r--       |
| S_IWOTH  | 2                          | --- --- -w-       |
| S_IXOTH  | 1                          | --- --- --x       |

####Флаги расширенного режима
| Флаг    | Восьмиричное представление | Описание                                                                         |
|---------|----------------------------|----------------------------------------------------------------------------------|
| S_IFMT  | 170000                     | Двоичная маска определения типа файла (побитовое ИЛИ всех следующих ниже флагов) |
| S_IFDIR | 40000                      | Каталог                                                                          |
| S_IFCHR | 20000                      | Символьное устройство                                                            |
| S_IFBLK | 60000                      | Блочное устройство                                                               |
| S_IFREG | 100000                     | Обычный файл                                                                     |
| S_IFIFO | 10000                      | Канал FIFO                                                                       |
| S_IFLNK | 120000                     | Символическая ссылка                                                             |

####Дополнительные флаги
| Флаг    | Восьмиричное представление | Описание            |
|---------|----------------------------|---------------------|
| S_ISUID | 4000                       | Бит SETUID          |
| S_ISGID | 2000                       | Бит SETGID          |
| S_ISVTX | 1000                       | Липкий (sticky) бит |

####Флаги режима открытия файла
| Флаг        | Описание                                                                                                  |
|-------------|-----------------------------------------------------------------------------------------------------------|
| O_RDONLY    | Только чтение (0)                                                                                         |
| O_WRONLY    | Только запись (1)                                                                                         |
| O_RDWR      | Чтение и запись (2)                                                                                       |
| O_CREAT     | Создать файл, если не существует                                                                          |
| O_TRUNC     | Стереть файл, если существует                                                                             |
| O_APPEND    | Дописывать в конец                                                                                        |
| O_EXCL      | Выдать ошибку, если файл существует при использовании O_CREAT                                             |
| O_DSYNC     | Принудительная синхронизация записи                                                                       |
| O_RSYNC     | Принудительная синхронизация перед чтением                                                                |
| O_SYNC      | Принудительная полная синхронизация записи                                                                |
| O_NONBLOCK  | Открыть файл в неблокируемом режиме, если это возможно                                                    |
| O_NDELAY    | То же, что и O_NONBLOCK                                                                                   |
| O_NOCTTY    | Если открываемый файл - терминальное устройство, не делать его управляющим терминалом процесса            |
| O_NOFOLLOW  | Выдать ошибку, если открываемый файл является символической ссылкой                                       |
| O_DIRECTORY | Выдать ошибку, если открываемый файл не является каталогом                                                |
| O_DIRECT    | Попытаться минимизировать кэширование чтения/записи файла                                                 |
| O_ASYNC     | Генерировать сигнал, когда появляется возможность чтения или записи в файл                                |
| O_LARGEFILE | Разрешить большие файлы (размер которых не может быть представлен в 31 бите (для систем с поддержкой LFS) |
