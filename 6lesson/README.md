##Файлы и работа с ними
###Небольшое отступление - коды возврата exit
```c
void exit(int code);
```

int code – определяет статус завершения работы, 0 (`EXIT_SUCCESS`)– нормальное завершение работы, отличное от нуля значение (`EXIT_FAILURE`) – завершение работы с индикацией ошибки.

Функция `exit ()`, завершает работу программы. Аргумент code указывает статус завершения работы. При завершении работы в штатном порядке рекомендуется указывать значение статуса 0 или `EXIT_SUCCESS`. В противном случае рекомендуется указывать отличное от нуля значение или `EXIT_FAILURE`. 


###Введение

Если коротко: файл - именованная область данных на носителе информации.

Для удобства работы с ними каждая операционная система имеет файловую систему, определяющу порядок хранения, доступа и создания файлов.

В Windows и Linux файловые системы разные (в каждой из них возможны как минимум 3 разные файловые системы).
Как правило файловая система состоит из блоков (от 512байт), которые группируются в файлы операционной системой. 
Возможны так же виртуальные файловые системы и сетевые. 

Иерархическая структура файлов в Wndows:
```
C:
  \Program files
      \CDEx
           \CDEx.exe
           \CDEx.hlp
           \mppenc.exe
  \Мои документы
      \Wiki.txt
      \Tornado.jpg
D:
  \Music
      \ABBA
           \1974 Waterloo
           \1976 Arrival
               \Money, Money, Money.ogg
           \1977 The Album
(Иерархическая файловая система Windows/DOS)
```

Иерархическая структура файлов в Unix системах:
```
/
    /usr                                  
        /bin                              
            /arch                        
            /ls                         
            /raw                     
        /lib                           
            /libhistory.so.5.2           
            /libgpm.so.1                
    /home                                
        /lost+found                      
            /host.sh                    
        /guest                         
            /Pictures                   
                /example.png        
            /Video                     
                /matrix.avi            
                /news                
                    /lost_ship.mpeg    
```

В Unix системах имеется ОДНА корневая точка. 
Так же ~ обозначает домашнюю директорию.
И слэш смотрит в другую сторону.

###Права доступа к файлам

Каждый файл в ОС UNIX содержит набор прав доступа, по которому определяется, как пользователь взаимодействует с данным файлом. 
Этот набор хранится в индексном дескрипторе данного файла в виде целого значения, из которого обычно используется 12 битов. 
Причем каждый бит используется как переключатель, разрешая (значение 1) или запрещая (значение 0) тот или иной доступ.

Три первых бита устанавливают различные виды поведения при выполнении. 
Оставшиеся девять делятся на три группы по три, определяя права доступа для владельца, группы и остальных пользователей. Каждая группа задает права на чтение, запись и выполнение.

Базовые биты прав доступа представлены в таблице ниже. 
Там дано восьмеричное значение, задающее соответствующий бит, вид этого бита в первом столбце длинного листинга и право, задаваемое этим битом.

| Восьмеричное значение | Вид в столбце прав доступа | Право или назначение бита                                                     |
|-----------------------|----------------------------|-------------------------------------------------------------------------------|
| 4000                  | ---s------                 | Установленный эффективный идентификатор владельца (бит SUID)                  |
| 2000                  | ------s---                 | Установленный эффективный идентификатор группы (бит SПID)                     |
| 1000                  | ---------t---------T       | Клейкий (sticky) бит. Вид для каталогов и выполняемых файлов, соответственно. |
| 0400                  | -r--------                 | Право владельца на чтение                                                     |
| 0200                  | --w-------                 | Право владельца на запись                                                     |
| 0100                  | ---x------                 | Право владельца на выполнение                                                 |
| 0040                  | ----r-----                 | Право группы на чтение                                                        |
| 0020                  | -----w----                 | Право группы на запись                                                        |
| 0010                  | ------x---                 | Право группы на выполнение                                                    |
| 0004                  | -------r--                 | Право всех прочих на чтение                                                   |
| 0002                  | --------w-                 | Право всех прочих на запись                                                   |
| 0001                  | ---------x                 | Право всех прочих на выполнение                                               |


Бит чтения для всех типов файлов имеет одно и то же значение: он позволяет читать содержимое файла (получать листинг каталога командой ls).

Бит записи также имеет одно и то же значение: он позволяет писать в этот файл, включая и перезапись содержимого. Если у пользователя отсутствует право доступа на запись в каталоге, где находится данный файл, то пользователь не сможет его удалить. Аналогично, без этого же права пользователь не создаст новый файл в каталоге, хотя может сократить длину доступного на запись файла до нуля.

Если для некоторого файла установлен бит выполнения, то файл может выполняться как команда. В случае установки этого бита для каталога, этот каталог можно сделать текущим (перейти в него командой cd).

Установленный бит SUID означает, что доступный пользователю на выполнение файл будет выполняться с правами (с эффективным идентификатором) владельца, а не пользователя, вызвавшего файл (как это обычно происходит).

Установленный бит SGID означает, что доступный пользователю на выполнение файл будет выполняться с правами (с эффективным идентификатором) группы-владельца, а не пользователя, вызвавшего файл (как это обычно происходит).

Если бит SGID установлен для файла, не доступного для выполнения, он означает обязательное блокирование, т.е. неизменность прав доступа на чтение и запись пока файл открыт определенной программой.

Установленный клейкий бит для обычных файлов ранее (во времена PDP-11) означал необходимость сохранить образ программы в памяти после выполнения (для ускорения повторной загрузки). Сейчас при установке обычным пользователем он сбрасывается. Значение этого бита при установке пользователем root зависит от версии ОС и иногда необходимо. Так, в ОС Solaris необходимо устанавливать клейкий бит для обычных файлов, используемых в качестве области подкачки.

Установка клейкого бита для каталога означает, что файл в этом каталоге может быть удален или переименован только в следующих случаях:

  1. пользователем-владельцем файла;
  2. пользователем-владельцем каталога;
  3. если файл доступен пользователю на запись;
  4. пользователем root.

Для расчета прав доступа необходимо сложить восьмеричные значения всех необходимых установленных битов. В результате получится четырехзначное восьмеричное число. Если старший разряд имеет значение 0, его можно не указывать.

Например, если необходимо задать права доступа на чтение, запись и выполнение для владельца, на чтение и выполнение для группы и на выполнение для всех остальных пользователей, получаем следующее восьмеричное значение:

Чтение для владельца:	0400

Запись для владельца:	0200

Выполнение для владельца:	0100

Чтение для группы:	0040

Выполнение для группы:	0010

Выполнение для прочих:	0001

Сумма:	0751

Итак, соответствующие права доступа - 751. В длинном листинге эти права будут представлены в виде "-rwxr-x--x" (при "сложении" буквы с дефисом в символьном представлении остается буква).

###Обзор механизмов ввода-вывода в Linux

В языке C для осуществления файлового ввода-вывода используются механизмы стандартной библиотеки языка, объявленные в заголовочном файле `stdio.h`. 
Как вы вскоре узнаете консольный ввод-вывод - это не более чем частный случай файлового ввода-вывода. 
Однако все эти механизмы являются всего лишь надстройками над низкоуровневыми механизмами ввода-вывода ядра операционной системы.

С точки зрения модели КИС (Клиент-Интерфейс-Сервер), сервером стандартных механизмов ввода вывода языка C (printf, scanf, FILE*, fprintf, fputc и т. д.) является библиотека языка. 
А сервером низкоуровневого ввода-вывода в Linux, которому посвящена эта глава книги, является само ядро операционной системы.

Пользовательские программы взаимодействуют с ядром операционной системы посредством специальных механизмов, называемых системными вызовами (system calls, syscalls). 
Внешне системные вызовы реализованы в виде обычных функций языка C, однако каждый раз вызывая такую функцию, мы обращаемся непосредственно к ядру операционной системы. 
Список всех системных вызовов Linux можно найти в файле `/usr/include/asm/unistd.h`. 
Мы рассмотрим основные системные вызовы, осуществляющие ввод-вывод: `open(), close(), read(), write(), lseek()` и некоторые другие.

###Файловые дескрипторы

В языке C при осуществлении ввода-вывода мы используем указатель `FILE*`. 
Даже функция `printf()` в итоге сводится к вызову `vfprintf(stdout,...)`, разновидности функции `fprintf();` константа `stdout` имеет тип `struct _IO_FILE*`,синонимом которого является тип `FILE*`. 
Это я к тому, что консольный ввод-вывод - это файловый ввод-вывод. 
Стандартный поток ввода, стандартный поток вывода и поток ошибок (как в C, так и в C++) - это файлы. 
В Linux все, куда можно что-то записать или откуда можно что-то прочитать представлено (или может быть представлено) в виде файла. 
Экран, клавиатура, аппаратные и виртуальные устройства, каналы, сокеты - все это файлы. 
Это очень удобно, поскольку ко всему можно применять одни и те же механизмы ввода-вывода, с которыми мы и познакомимся в этой главе. 
Владение механизмами низкоуровневого ввода-вывода дает свободу перемещения данных в Linux. 
Работа с локальными файловыми системами, межсетевое взаимодействие, работа с аппаратными устройствами, - все это осуществляется в Linux посредством низкоуровневого ввода-вывода.

При запуске программы в системе создается новый процесс (здесь есть свои особенности, о которых пока говорить не будем). 
У каждого процесса (кроме init) есть свой родительский процесс (parent process или просто parent), для которого новоиспеченный процесс является дочерним (child process, child). 
Каждый процесс получает копию окружения (environment) родительского процесса. Оказывается, кроме окружения дочерний процесс получает в качестве багажа еще и копию таблицы файловых дескрипторов.

Файловый дескриптор (`file descriptor`) - это целое число (int), соответствующее открытому файлу. 
Дескриптор, соответствующий реально открытому файлу всегда больше или равен нулю. 
Копия таблицы дескрипторов (читай: таблицы открытых файлов внутри процесса) скрыта в ядре. 
Мы не можем получить прямой доступ к этой таблице, как при работе с окружением через environ. 
Можно, конечно, кое-что "вытянуть" через дерево /proc, но нам это не надо. 
Программист должен лишь понимать, что каждый процесс имеет свою копию таблицы дескрипторов. 
В пределах одного процесса все дескрипторы уникальны (даже если они соответствуют одному и тому же файлу или устройству). 
В разных процессах дескрипторы могут совпадать или не совпадать - это не имеет никакого значения, поскольку у каждого процесса свой собственный набор открытых файлов.

Возникает вопрос: сколько файлов может открыть процесс? В каждой системе есть свой лимит, зависящий от конфигурации. Если вы используете bash или ksh (Korn Shell), то можете воспользоваться внутренней командой оболочки ulimit, чтобы узнать это значение.

```bash
$ ulimit -n
1024
$
```

Если вы работаете с оболочкой C-shell (csh, tcsh), то в вашем распоряжении команда limit:

```bash
$ limit descriptors
descriptors 1024
$
```

В командной оболочке, в которой вы работаете (bash, например), открыты три файла: стандартный ввод (дескриптор 0), стандартный вывод (дескриптор 1) и стандартный поток ошибок (дескриптор 2). 
Когда под оболочкой запускается программа, в системе создается новый процесс, который является для этой оболочки дочерним процессом, следовательно, получает копию таблицы дескрипторов своего родителя (то есть все открытые файлы родительского процесса). 
Таким образом программа может осуществлять консольный ввод-вывод через эти дескрипторы. 
На протяжении всей книги мы будем часто играть с этими дескрипторами.

Таблица дескрипторов, помимо всего прочего, содержит информацию о текущей позиции чтения-записи для каждого дескриптора. При открытии файла, позиция чтения-записи устанавливается в ноль. Каждый прочитанный или записанный байт увеличивает на единицу указатель текущей позиции. 
