#Структуры
  1. Керниган - Язык программирования Си , раздел структуры
  2. http://acm.mipt.ru/twiki/bin/view/Cintro/OOP-structC
  
*Структура* — это одна или несколько переменных (возможно, различных типов), которые для удобства работы
с ними сгруппированы под одним именем. 
Структуры помогают в организации сложных данных (особенно в больших программах), поскольку
позволяют группу связанных между собой переменных трактовать не как множество отдельных элементов, а
как единое целое.

Традиционный пример структуры — строка платежной ведомости. Она содержит такие сведения о служащем,
как его полное имя, адрес, номер карточки социального страхования, зарплата и т. д. Некоторые из этих
характеристик сами могут быть структурами: например, полное имя состоит из нескольких компонент
(фамилии, имени и отчества); аналогично адрес, и даже зарплата. Другой пример (более типичный для Си) —
из области графики: точка есть пара координат, прямоугольник есть пара точек и т. д.
Главные изменения, внесенные стандартом ANSI в отношении структур, — это введение для них операции
присваивания. Структуры могут копироваться, над ними могут выполняться операции присваивания, их
можно передавать функциям в качестве аргументов, а функции могут возвращать их в качестве результатов. В
большинстве компиляторов уже давно реализованы эти возможности, но теперь они точно оговорены
стандартом.

##Основные сведения о структурах
Пример структуры - точка на плоскости.

```c
struct point {
 int x;
 int у;
};
```

Такая запись означает обозначение нового типа данных - нашей структуры. 
Теперь можно создавать переменные, которые будут иметь такой тип. Делается это так:
```c
struct point pt;
```

Теперь у нас есть переменная pt с типом данных наша структура.
Можно так же объявлять и так, заранее указывая значения нашей структуры.

```c
struct point maxpt = { 320, 200 };
```

Вообще обращение к полю структуры (как к переменной происходит) через `имя_структуры.поле`, например

```c
pt.x = 5;
```


Структуры могут быть вложенными:

```c
struct rect {
 struct point pt1;
 struct point pt2;
};

...

struct rect myRect;
myRect.pt1.x = 5;
```

##typedef
Стркутурам можно давать сокращенные названия:
```c
typedef struct{
  int h;    // часы
  int min;  // минуты
  int sec;  // секунды
}Time;

Time a,b; //объявление переменных
```

Это то же самое, что 
```c
struct time{
  int h;    // часы
  int min;  // минуты
  int sec;  // секунды
};

struct time a,b; //объявление переменных
```

##Указатели на структуры

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct{
  int h;    // часы
  int min;  // минуты
  int sec;  // секунды
}Time;

int main(){
  Time a,b; //объявление переменных типа Time

// поля переменных a и b не инициализируются (там компьютерный мусор)
  a.h = 12;     // присваивание значения полю h переменной a
  a.min = 45;   // присваивание значения полю min переменной a
  a.sec = 0;    // присваивание значения полю sec переменной a

// присваивание значения переменной a к переменной b
  b = a;

// печать значений переменной b:
  printf("%d:%d:%d\n", b.h, b.min, b.sec);
  return 0;  

}
```

Теперь то же самое через динамическую память и указатели.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct{
  int h;    // часы
  int min;  // минуты
  int sec;  // секунды
}Time;

int main(){
  Time *pa; //объявление указателя на переменную типа Time
   Time *pb; //объявление указателя на переменную типа Time
   

// Выделение динамической памяти под переменную типа Time
//  с преобразованием возвращаемого указателя к типу Time*

  pa = (Time*)malloc( sizeof(Time) );

// поля переменных a и b не инициализируются (там компьютерный мусор)
  pa->h = 12;     // присваивание значения полю h переменной a
  pa->min = 45;   // присваивание значения полю min переменной a
  pa->sec = 0;    // присваивание значения полю sec переменной a

// Теперь оба указателя "смотрят" на одну и ту же область памяти
  pb = pa;

// печать значений переменной b:
  printf("%d:%d:%d\n", pb->h, pb->min, pb->sec);

// Получение значений полей с консоли. &(b->h) - адрес поля h.

   scanf("%d%d%d",&(pb->h), &(pb->min), &(pb->sec)); 

 // печать значений переменной b:
  printf("%d:%d:%d\n", pa->h, pa->min, pa->sec);
// Освобождаем динамическую память
// Теперь она доступна для других данных
  free(pa);
  return 0;  

}
```


##Функции
Структура становится таким же типом данных, который можно использовать.

```c
/* makepoint: формирует точку по компонентам х и y */
struct point makepoint(int x, int y)
{
 struct point temp;
 temp.x = x;
 temp.у = у;
 return temp;
}
```
