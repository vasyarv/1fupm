Операции о операторы

Ввыод, вывод чисел. Пример на часы, на float

Рекурсия

##Пример ввода строк
```c
#include <stdio.h>

int main () {
	int d, i = 0;
	char c;
	scanf("%d",&d);
	getchar();
	while((c = getchar()) != '\n' && c != EOF) {
		if ( (c - 48) == d ) 
			i++;	
	}	
	printf("%d\n",i);
	return 0;
}
```

##Статические переменные
Переменные sp и val в файле stack.с, а также buf и bufp в getch.с находятся в личном пользовании
функций этих файлов, и нет смысла открывать к ним доступ кому-либо еще. Указание static, примененное
к внешней переменной или функции, ограничивает область видимости соответствующего объекта концом
файла. Это способ скрыть имена. Так, переменные buf и bufp должны быть внешними, поскольку их
совместно используют функции getch и ungetch, но их следует сделать невидимыми для "пользователей"
функций getch и ungetch.
Статическая память специфицируется словом static, которое помещается перед обычным объявлением.
Если рассматриваемые нами две функции и две переменные компилируются в одном файле, как в
показанном ниже примере:
```c
static char buf[BUFSIZE]; /* буфер для ungetch */
static int bufp = 0; /* след, свободная позиция в buf */
int getch(void) { ... }
void ungetch(int c) { ... }
```

то никакая другая программа не будет иметь доступ ни к buf, ни к bufp, и этими именами можно свободно
пользоваться в других файлах для совсем иных целей. Точно так же, помещая указание static перед
объявлениями переменных sp и val, с которыми работают только push и pop, мы можем скрыть их от
остальных функций.
Указание static чаще всего используется для переменных, но с равным успехом его можно применять и к
функциям. Обычно имена функций глобальны и видимы из любого места программы. Если же функция
помечена словом static, то ее имя становится невидимым вне файла, в котором она определена.
Объявление static можно использовать и для внутренних переменных. Как и автоматические переменные,
внутренние статические переменные локальны в функциях, но в отличие от автоматических они не возникают
только на период работы функции, а существуют постоянно. Это значит, что внутренние статические
переменные обеспечивают постоянное сохранение данных внутри функции.

##const

К любой переменной в объявлении может быть применен квалификатор const для указания того, что ее
значение далее не будет изменяться.
```c
const double e = 2.71828182845905;
const char msg[] = "предупреждение: ";
```

Применительно к массиву квалификатор const указывает на то, что ни один из его элементов не будет
меняться. Указание const можно также применять к аргументу-массиву, чтобы сообщить, что функция не
изменяет этот массив:
```c
int strlen(const char[] );
```

Реакция на попытку изменить переменную, помеченную квалификатором const, зависит от реализации
компилятора.
