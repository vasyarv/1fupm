##Операции о операторы
Оператор - наименьшая исполняемая единица программы

Операция - аналог действию над элементами

https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%B2_C_%D0%B8_C%2B%2B

##Ввыод, вывод чисел. Пример на часы, на float

```c
#include <stdio.h>

int main(void)
{
  /* Этот фрагмент печатает строку "это тест"
     которая выравнивается по левому краю поля шириной в 20 символов.
  */
  printf("%-20s", "это тест");

  /* Этот фрагмент печатает в поле шириной в 10 символов число
     с плавающей точкой с тремя десятичными разрядами после запятой.
     В результате получится "    12.235".
  */
  printf("%10.3f", 12.234657);

  return 0;
}
```

```c
y = (a>b) ? a: b;
```

```c
#include<stdio.h>

	main()
	{
		int a,b;
		float c,d;

		a = 15;
		b = a / 2;
		printf("%d\n",b);
		printf("%3d\n",b);
		printf("%03d\n",b);

		c = 15.3;
		d = c / 3;
		printf("%3.2f\n",d);
	}
```
Output of the source above:


7
   7
007
5.10


http://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output



##Рекурсия
Из десятичной в двоичную

##Пример ввода строк
```c
#include <stdio.h>

int main () {
	int d, i = 0;
	char c;
	scanf("%d",&d);
	getchar();
	while((c = getchar()) != '\n' && c != EOF) {
		if ( (c - 48) == d ) 
			i++;	
	}	
	printf("%d\n",i);
	return 0;
}
```

##Статические переменные
Переменные sp и val в файле stack.с, а также buf и bufp в getch.с находятся в личном пользовании
функций этих файлов, и нет смысла открывать к ним доступ кому-либо еще. Указание static, примененное
к внешней переменной или функции, ограничивает область видимости соответствующего объекта концом
файла. Это способ скрыть имена. Так, переменные buf и bufp должны быть внешними, поскольку их
совместно используют функции getch и ungetch, но их следует сделать невидимыми для "пользователей"
функций getch и ungetch.
Статическая память специфицируется словом static, которое помещается перед обычным объявлением.
Если рассматриваемые нами две функции и две переменные компилируются в одном файле, как в
показанном ниже примере:
```c
static char buf[BUFSIZE]; /* буфер для ungetch */
static int bufp = 0; /* след, свободная позиция в buf */
int getch(void) { ... }
void ungetch(int c) { ... }
```

то никакая другая программа не будет иметь доступ ни к buf, ни к bufp, и этими именами можно свободно
пользоваться в других файлах для совсем иных целей. Точно так же, помещая указание static перед
объявлениями переменных sp и val, с которыми работают только push и pop, мы можем скрыть их от
остальных функций.
Указание static чаще всего используется для переменных, но с равным успехом его можно применять и к
функциям. Обычно имена функций глобальны и видимы из любого места программы. Если же функция
помечена словом static, то ее имя становится невидимым вне файла, в котором она определена.
Объявление static можно использовать и для внутренних переменных. Как и автоматические переменные,
внутренние статические переменные локальны в функциях, но в отличие от автоматических они не возникают
только на период работы функции, а существуют постоянно. Это значит, что внутренние статические
переменные обеспечивают постоянное сохранение данных внутри функции.

##const

К любой переменной в объявлении может быть применен квалификатор const для указания того, что ее
значение далее не будет изменяться.
```c
const double e = 2.71828182845905;
const char msg[] = "предупреждение: ";
```

Применительно к массиву квалификатор const указывает на то, что ни один из его элементов не будет
меняться. Указание const можно также применять к аргументу-массиву, чтобы сообщить, что функция не
изменяет этот массив:
```c
int strlen(const char[] );
```

Реакция на попытку изменить переменную, помеченную квалификатором const, зависит от реализации
компилятора.
