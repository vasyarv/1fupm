##План занятия
  1. Функции в С
  2. Параметры функции: передача по значению и указателю. Указатель на массив в роли параметра функции. Аргументы функции main(): argv[] и argc
  3. Массивы напомнить. Строки. Библиотека string.h. Функции strcat(), strcmp(), strcpy(), strlen(), strrchr(), strstr(), strtok(). Функции преобразования строк в числа atof, atoi, atol


##УКАЗАТЕЛИ
Указатели - это переменные, показывающие место или адрес памяти, где расположены другие объекты (переменные, функции и др.). Так как указатель содержит адрес некоторого объекта, то через него можно обращаться к этому объекту.
Унарная операция & дает адрес объекта, поэтому оператор

```c
  у = &х;
```

присваивает адрес переменной х переменной у. Операцию & нельзя применять к константам и выражениям; конструкции вида &(х+7) или &28 недопустимы.
Унарная операция * воспринимает свой операнд как адрес некоторого объекта и использует этот адрес для выборки содержимого, поэтому оператор
```c
     z = *y; 
```
присваивает z значение переменной, записанной по адресу у. Если
```c
     y = &x; 
     z = *у; 
```
то z = x.
Объекты, состоящие из знака * и адреса (например, *а), необходимо определить. Делается это, например, так:
```c
     int *а, *b, *с; 
     char *d; 
```
Определение вида char *d говорит о том, что значение, записанное по адресу d, имеет тип char.

Указатели могут встречаться и в выражениях. Если у - указатель на целое, т.е. имело место объявление int *у, то *у может появиться там же, где и любая другая переменная, не являющаяся указателем. Таким образом, следующие выражения вполне допустимы:
```c
     *у = 7; 
     *x *=5;
     (*z)++; 
```
Первое из них заносит число 7 в ячейку памяти по адресу у, второе увеличивает значение по адресу х в пять раз, третье добавляет единицу к содержимому ячейки памяти с адресом z. В последнем случае круглые скобки необходимы, так как операции с одинаковым приоритетом выполняются справа налево. В результате если, например, *z = 5, то (*z)++ приведет к тому, что *z = 6, а *z++ всего лишь изменит сам адрес z (операция ++ выполняется над адресом z, а не над значением *z по этому адресу).

Указатели можно использовать как операнды в арифметических операциях. Если у - указатель, то унарная операция y++ увеличивает его значение; теперь оно является адресом следующего элемента. Указатели и целые числа можно складывать. Конструкция у + n (у - указатель, n - целое число) задает адрес n-гo объекта, на который указывает у. Это справедливо для любых объектов (int, char, float и др.); транслятор будет масштабировать приращение адреса в соответствии с типом, указанным в определении объекта.

Любой адрес можно проверить на равенство (==) или неравенство (!=) со специальным значением NULL, которое позволяет определить ничего не адресующий указатель.


##Параметры функции: передача по значению и указателю. Указатель на массив в роли параметра функции.

Программы на языке Си обычно состоят из большого числа отдельных функций (подпрограмм). Как правило, эти функции имеют небольшие размеры и могут находиться как в одном, так и в нескольких файлах. Все функции являются глобальными. В языке запрещено определять одну функцию внутри другой. Связь между функциями осуществляется через аргументы, возвращаемые значения и внешние переменные.
В общем случае функции в языке Си необходимо объявлять. Объявление функции (т.е. описание заголовка) должно предшествовать ее использованию, а определение функции (т.е. полное описание) может быть помещено как после тела программы (т.е. функции main( )), так и до него. Если функция определена до тела программы, а также до ее вызовов из определений других функций, то объявление может отсутствовать. Как уже отмечалось, описание заголовка функции обычно называют прототипом функции.

Функция объявляется следующим образом:
```c
     тип имя_функции(тип имя_параметра_1, тип имя_параметра_2, ...); 
```
Тип функции определяет тип значения, которое возвращает функция. Если тип не указан, то предполагается, что функция возвращает целое значение (int).
При объявлении функции для каждого ее параметра можно указать только его тип (например: тип функция (int, float, ...), а можно дать и его имя (например: тип функция (int а, float b, ...) ).
В языке Си разрешается создавать функции с переменным числом параметров. Тогда при задании прототипа вместо последнего из них указывается многоточие.
Определение функции имеет следующий вид:
```c
     тип имя_функции(тип имя_параметра_1, тип имя_параметра_2,...)
     {
         тело функции
     }
```
Передача значения из вызванной функции в вызвавшую происходит с помощью оператора возврата return, который записывается следующим образом:
```c
     return выражение; 
```
Таких операторов в подпрограмме может быть несколько, и тогда они фиксируют соответствующие точки выхода. Например:
```c
     int f(int a, int b)
     {
         if (a > b) { printf("max = %d\n", a); return a; }
         printf("max = %d\n", b); return b;
     }
```
Вызвать эту функцию можно следующим образом:
```c
     c = f(15, 5);  
     c = f(d, g);    
     f(d, g);        
```
Вызвавшая функция может, при необходимости, игнорировать возвращаемое значение. После слова return можно ничего не записывать; в этом случае вызвавшей функции никакого значения не передается. Управление передается вызвавшей функции и в случае выхода "по концу" (последняя закрывающая фигурная скобка).
В языке Си аргументы функции передаются по значению, т.е. вызванная функция получает свою временную копию каждого аргумента, а не его адрес. Это означает, что вызванная функция не может изменить значение переменной вызвавшей ее программы. Однако это легко сделать, если передавать в функцию не переменные, а их адреса. Например:
```c
     void swap(int *a, int *b)
     {
         int tmp = *a;
      
         *a = *b;
         *b = tmp;
     }
```
Вызов swap(&b, &c) (здесь подпрограмме передаются адреса переменных b и с) приведет к тому, что значения переменных b и c поменяются местами.
Если же в качестве аргумента функции используется имя массива, то передается только адрес начала массива, а сами элементы не копируются. Функция может изменять элементы массива, сдвигаясь (индексированием) от его начала.
Рассмотрим, как функции можно передать массив в виде параметра. Здесь возможны три варианта:
  1. Параметр задается как массив (например: int m[100];).
  2. Параметр задается как массив без указания его размерности (например: int m[];).
  3. Параметр задается как указатель (например: int *m;). Этот вариант используется наиболее часто.
Независимо от выбранного варианта вызванной функции передается указатель на начало массива. Сами же элементы массива не копируются.
Если некоторые переменные, константы, массивы, структуры объявлены как глобальные, то их не надо включать в список параметров вызванной функции.

В языке С нельзя передать весь массив как аргумент функции. Однако можно передать указатель на массив, т.е. имя массива без индекса. Например, в представленной программе в func1() передается указатель на массив i:
```c
int main(void)
{
  int i[10];

  func1(i);

  /* ... */
}
```
Если в функцию передается указатель на одномерный массив, то в самой функции его можно объявить одним из трех вариантов: как указатель, как массив определенного размера и как массив без определенного размера. Например, чтобы функция func1() получила доступ к значениям, хранящимся в массиве i, она может быть объявлена как
```c
void func1(int *x) /* указатель */
{
  /* ... */
}

//или как
void func1(int x[10]) /* массив определенного размера */
{
  /* ... */
}
//и наконец как
void func1(int x[]) /* массив без определенного размера */
{
  /* ... */
}
```
Эти три объявления тождественны, потому что каждое из них сообщает компилятору одно и то же: в функцию будет передан указатель на переменную целого типа. В первом объявлении используется указатель, во втором — стандартное объявление массива. В последнем примере измененная форма объявления массива сообщает компилятору, что в функцию будет передан массив неопределенной длины. Как видно, длина массива не имеет для функции никакого значения, потому что в С проверка границ массива не выполняется. Эту функцию можно объявить даже так:
```c
void func1(int x[32])
{
  /* ... */
}
```
И при этом программа будет выполнена правильно, потому что компилятор не создает массив из 32 элементов, а только подготавливает функцию к приему указателя.


##Аргументы функции main(): argv[] и argc
В программы на языке Си можно передавать некоторые аргументы. Когда вначале вычислений производится обращение к main( ), ей передаются три параметра. Первый из них определяет число командных аргументов при обращении к программе. Второй представляет собой массив указателей на символьные строки, содержащие эти аргументы (в одной строке - один аргумент). Третий тоже является массивом указателей на символьные строки, он используется для доступа к параметрам операционной системы (к переменным окружения).
Любая такая строка представляется в виде:
     переменная = значение\0 
Последнюю строку можно найти по двум заключительным нулям.
Назовем аргументы функции main( ) соответственно: argc, argv и env (возможны и любые другие имена). Тогда допустимы следующие описания:
```c
     main( ) 
     main(int argc) 
     main(int argc, char *argv[ ] ) 
     main(int argc, char *argv[ ], char *env[ ] ) 
```
Предположим, что на диске A: есть некоторая программа prog.exe. Обратимся к ней следующим образом:
     A:\>prog.exe file1 file2 file3 <Enter> 
Тогда argv[0] - это указатель на строку A:\prog.exe, argv[1] - на строку file1 и т.д. На первый фактический аргумент указывает argv[1], а на последний - argv[3]. Если argc=1, то после имени программы в командной строке параметров нет. В нашем примере argc=4.
Задача. Передать main имя. Напечатать имя и имя программы
```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  if(argc!=2) {
    printf("Вы забыли ввести свое имя.\n");
    exit(1);
  }
  printf("Привет %s", argv[1]);

  return 0;
}
```

##Строки
Язык Си не поддерживает отдельный строковый тип данных, но он позволяет определить строки двумя различными способами. В первом используется массив символов, а во втором - указатель на первый символ массива.
Определение char а[10]; указывает компилятору на необходимость резервирования места для максимум 10 символов. Константа а содержит адрес ячейки памяти, в которой помещено значение первого из десяти объектов типа char. Процедуры, связанные с занесением конкретной строки в массив а, копируют ее по одному символу в область памяти, на которую указывает константа а, до тех пор, пока не будет скопирован нулевой символ, оканчивающий строку. Когда выполняется функция типа printf("%s", а), ей передается значение а, т.е. адрес первого символа, на который указывает а. Если первый символ - нулевой, то работа функции printf() заканчивается, а если нет, то она выводит его на экран, прибавляет к адресу единицу и снова начинает проверку на нулевой символ. Такая обработка позволяет снять ограничения на длину строки (конечно, в пределах объявленной размерности): строка может иметь любую длину, но в пределах доступной памяти.
Инициализировать строку при таком способе определения можно следующим образом:
```c
     char array[7] = "Строка";
     char s[ ] = {'С', 'т', 'р', 'о', 'к', 'а', '\0'};
```
(при определении массива с одновременной инициализацией пределы изменения индекса можно не указывать).
Второй способ определения строки - это использование указателя на символ. Определение char *b; задает переменную b, которая может содержать адрес некоторого объекта. Однако в данном случае компилятор не резервирует место для хранения символов и не инициализирует переменную b конкретным значением. Когда компилятор встречает оператор вида b ="IBM PC";, он производит следующие действия. Во-первых, как и в предыдущем случае, он создает в каком-либо месте объектного модуля строку "IBM PC", за которой следует нулевой символ ('\0'). Во-вторых, он присваивает значение начального адреса этой строки (адрес символа 'I') переменной b. Функция printf("%s", b) работает так же, как и в предыдущем случае, осуществляя вывод символов до тех пор, пока не встретится заключительный нуль.
Массив указателей можно инициализировать, т.е. назначать его элементам конкретные адреса некоторых заданных строк при определении.
Для ввода и вывода строк символов помимо scanf( ) и printf() могут использоваться функции gets( ) и puts( ) (их прототипы находятся в файле stdio.h).
Если string - массив символов, то ввести строку с клавиатуры можно так:
     gets(string);
(ввод оканчивается нажатием клавиши <Enter>). Вывести строку на экран можно следующим образом:
     puts(string);
Отметим также, что для работы со строками существует специальная библиотека функций, прототипы которых находятся в файле string.h.

Наиболее часто используются функции strcpy( ), strcat( ), strlen( ) и strcmp( ).

###strcpy
Если string1 и string2 - массивы символов, то вызов функции strcpy( ) имеет вид:
```c
     strcpy(string1, string2);
```
Эта функция служит для копирования содержимого строки string2 в строку string1. Массив string1 должен быть достаточно большим, чтобы в него поместилась строка string2. Так как компилятор не отслеживает этой ситуации, то недостаток места приведет к потере данных.
###strcat
Вызов функции strcat( ) имеет вид:
```c
     strcat(string1, string2);
```
Эта функция присоединяет строку string2 к строке string1 и помещает ее в массив, где находилась строка string1, при этом строка string2 не изменяется. Нулевой байт, который завершал первую строку, заменяется первым байтом второй строки.
###strlen
Функция strlen( ) возвращает длину строки, при этом завершающий нулевой байт не учитывается. Если a - целое, то вызов функции имеет вид:
```c
     a = strlen(string);
```

###strcmp
Функция strcmp( ) сравнивает две строки и возвращает 0, если они равны.
strrchr()
Синтаксис:
```c
#include < string.h > 
char *strrchr (const char *str, int ch);
```
Аргументы:
str – указатель на строку, в которой будет осуществляться поиск.
ch – код искомого символа.
Возвращаемое значение:
Указатель на искомый символ, если он найден в строке str, иначе NULL.
###strchr
Описание:
Функция strchr ищет последнее вхождения символа, код которого указан в аргументе ch, в строке, на которую указывает аргумент str.
Пример:
В примере ищется последнее вхождение символа '6' в строке '0163456769’ и на экран выводится его порядковый номер в строке (отчет с единицы). 
```c
#include < stdio.h >  // Для printf
#include < string.h > // Для strrchr
int main (void)
{    
   // Массив со строкой для поиска
   char str [11]=”0163456769”;
   // Код искомого символа
   int ch = '6';
   // Указатель на искомую переменную в строке,
   // по которой осуществляется поиск.
   char *ach;
  
   // Ищем символ ‘6’
   ach=strrchr (src,ch);

   // Выводим результат на консоль
   if (ach==NULL)
      printf (“Символ в строке не найден\n”);
   else
      printf (“Искомый символ в строке на позиции # %d\n”,ach-src+1);

   return 0;
}
```
###strstr()
Описание
      Функция возвращает указатель на первое вхождение стро-
      ки string2 в строку string1.
Использование
      #include <string.h>
      char *strstr(const char *string1,
                          const char *string2);   /* ANSI */
Возвращаемое значение
      strstr возвращает NULL,  если string2 не была найдена.
      Если  длина  строки  string2  равна  0,   возвращается
      string1.
Пример
```c
      #include <string.h>
      #include <stdio.h>
      char *string = "Пример строки";
      char *cmp = "стр";
      main()
      {
        printf("Пример на strstr [%s]\n", strstr(string, cmp));
      }
```

###strtok().
С помощью функции strtok() можно разбить строку на отдельные части (лексемы). Объявление этой функции выглядит так char *strtok (char *, const char *). При первом вызове функции в качестве первого параметра указывается строка, которую требуется разбить. Вторым параметром указывается строка-разделитель. При последующих вызовах функции для этой же строки первым параметром должен быть NULL, т.к. функция уже "запомнила" с чем работает. Рассмотрим пример:
```c
	char str[] = "one, two, three, four, five";
	char *sp;
 
	sp = strtok(str, ", ");
	while (sp) {
		puts(sp);
		sp = strtok(NULL, ", ");
	}
```

В результате выполнения данного кода на экран в столбик выводятся слова:
one
two
three
four
five

При первом вызове strtok() в функцию передается указатель на первый символ массива и строка-разделитель. После этого вызова массив str изменяется, в нем остается только слово "one", также функция возвращает указатель на это слово, который присваивается sp.
Хотя мы потеряли остаток массива в вызывающей функции, однако внутри strtok()сохраняется указатель на остаток массива. Когда передается NULL, функция "знает", что надо работать с этим "хвостом".


###Функции преобразования строк в числа atof, atoi, atol, atoll
Функция atoi
```c
#include <stdlib.h>
int atoi(const char *str);
```
Функция atoi() преобразует строку, адресуемую параметром str, в значение типа int. Эта строка должна содержать допустимое целое число. В противном случае возвращаемое значение не определено.
После числа может следовать любой символ, который не может быть частью целого числа. Имеются в виду пробелы, символы табуляции и пустой строки, знаки препинания и буквы. Это значит, что, если функция atoi() вызывается с аргументом "123.23", будет возвращено целое значение 123, а подстрока ".23" будет проигнорирована.
Пример
Следующая программа считывает два целых числа и выводит их сумму:
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
  char num1[80], num2[80];

  printf("Введите первое число: ");
  gets(num1);
  printf("Введите второе число: ");
  gets(num2);
  printf("Сумма: %d.", atoi(num1)+atoi(num2));

  return 0;
}
```

```c
#include <stdlib.h>
double atof(const char *str);
```

Функция atof() преобразует строку, адресуемую параметром str, в значение типа double. Эта строка должна содержать допустимое число с плавающей точкой. В противном случае возвращаемое значение не определено.
После числа может следовать любой символ, который не может быть частью допустимого числа с плавающей точкой. Имеются в виду пробелы, символы табуляции и пустой строки, знаки препинания (но не точки) и символы, отличные от буквы "Е" или "е". Это значит, что, если функция atof() вызывается с аргументом "100.00HELLO", будет возвращено значение 100.00.
Пример
Эта программа читает два числа с плавающей точкой и выводит их сумму:
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
  char num1[80], num2[80];

  printf("Введите первое число: ");
  gets(num1);
  printf("Введите второе число: ");
  gets(num2);
  printf("Сумма: %lf.", atof(num1) + atof(num2));

  return 0;
}
```

```c
#include <stdlib.h>
long int atol(const char *str);
```

Функция atol() преобразует строку, адресуемую параметром str, в значение типа long int. Эта строка должна содержать допустимое целое число. В противном случае возвращаемое значение не определено.
После числа может следовать любой символ, который не может быть частью целого числа. Имеются в виду пробелы, символы табуляции и пустой строки, знаки препинания и буквы. Это значит, что, если функция atol() вызывается с аргументом "123.23", будет возвращено длинное целое значение 123L, а подстрока ".23" будет проигнорирована.
Пример
Следующая программа считывает два целых числа в виде строк, преобразует их в два длинных целых числа и выводит их сумму:
```c
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
  char num1[80], num2[80];

  printf("Введите первое число: ");
  gets(num1);
  printf("Введите второе число: ");
  gets(num2);
  printf("Сумма: %ld.", atol(num1)+atol(num2));

  return 0;
}
```

##Динамическое распределение памяти. Динамически создаваемые массивы
В языке Си принято следующее распределение памяти:
Для глобальных переменных отводится фиксированное место в памяти на все время работы программы. Локальные переменные хранятся в стеке. Между ними находится область памяти для динамического распределения.
Функции malloc( ) и free( ) используются для динамического распределения свободной памяти. Функция malloc( ) выделяет память, функция free( ) освобождает ее. Прототипы этих функций хранятся в заголовочном файле stdlib.h и имеют вид:
```c
     void *malloc(size_t size);
     void *free(void *p);
```
Функция malloc( ) возвращает указатель типа void; для правильного использования значение функции надо преобразовать к указателю на соответствующий тип. При успешном выполнении функция возвращает указатель на первый байт свободной памяти размера size. Если достаточного количества памяти нет, возвращается значение 0. Чтобы определить количество байтов, необходимых для переменной, используют операцию sizeof( ).
Пример использования этих функций:
```c
#include <stdio.h>
#include <stdlib.h>

void main(void)
{
   int *p, i;
   p = (int *) malloc(100 * sizeof(int)); /* Выделение памяти для 100 
                                             целых чисел */
   if (!p) 
   {
       printf("Недостаточно памяти\n");
       exit(1);
   }
   for (i = 0; i < 100; ++i) *(p+i) = i;    /* Использование памяти */
   for (i = 0; i < 100; ++i) printf("%d", *(p++) );
   free(p);                                   /* Освобождение памяти */
}
```
Перед использованием указателя, возвращаемого malloc( ), необходимо убедиться, что памяти достаточно (указатель не нулевой).
Функция malloc() возвращает указатель на первый байт области памяти размером size, которая была выделена из динамически распределяемой области памяти. Если для удовлетворения запроса в динамически распределяемой области памяти нет достаточного объема памяти, возвращается нулевой указатель. Перед попыткой использовать выделенную память всегда проверяйте, что возвращаемое значение не является нулевым указателем. Попытка использовать нулевой указатель обычно приводит к полному отказу системы.
Пример
Эта функция выделяет память для структуры типа addr:
```c
struct addr {
  char name[40];
  char street[40];
  char city[40];
  char state[3];
  char zip[10];
};

struct addr *get_struct(void)
{
  struct addr *p;

  if((p = malloc(sizeof(struct addr)))==NULL) {
    printf("Ошибка при распределении памяти\n");
    exit(1);
  }
  return p;
}

#include<stdio.h>

	int main()
	{
		int *ptr_one;

		ptr_one = (int *)malloc(sizeof(int));

		if (ptr_one == 0)
		{
			printf("ERROR: Out of memory\n");
			return 1;
		}

		*ptr_one = 25;
		printf("%d\n", *ptr_one);

		free(ptr_one);

		return 0;
	}
```
