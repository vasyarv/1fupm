##Деревья

Дерево - связный граф без циклов.

*Двоичное дерево* - дерево, где каждый узел имеет не более двух потомков.

*Двоичное дерево поиска* (англ. binary search tree, BST) — это двоичное дерево, для которого выполняются следующие дополнительные условия (свойства дерева поиска):

*АВЛ-дерево* — сбалансированное по высоте двоичное дерево поиска: для каждой его вершины высота её двух поддеревьев различается не более чем на 1.

  1. Оба поддерева — левое и правое — являются двоичными деревьями поиска.
  2. У всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X.
  3. В то время, как значения ключей данных у всех узлов правого поддерева (того же узла X) больше, нежели значение ключа данных узла X.
  
Характеристики:

|               | В среднем | В худшем случае |
|---------------|-----------|-----------------|
| Расход памяти | O(n)      | O(n)            |
| Поиск         | O(log n)  | O(n)            |
| Вставка       | O(log n)  | O(n)            |
| Удаление      | O(log n)  | O(n)            |

###Основные операции

Базовый интерфейс двоичного дерева поиска состоит из трех операций:

	1. FIND(K) — поиск узла, в котором хранится пара (key, value) с key = K.
	2. INSERT(K,V) — добавление в дерево пары (key, value) = (K, V).
	2. REMOVE(K) — удаление узла, в котором хранится пара (key, value) с key = K.
	3. 
Этот абстрактный интерфейс является общим случаем, например, таких интерфейсов, взятых из прикладных задач:

«Телефонная книжка» — хранилище записей (имя человека, его телефон) с операциями поиска и удаления записей по имени человека, и операцией добавления новой записи.
Domain Name Server — хранилище пар (доменное имя, IP адрес) с операциями модификации и поиска.
Namespace — хранилище имен переменных с их значениями, возникающее в трансляторах языков программирования.
По сути, двоичное дерево поиска — это структура данных, способная хранить таблицу пар (key, value) и поддерживающая три операции: FIND, INSERT, REMOVE.

Кроме того, интерфейс двоичного дерева включает ещё три дополнительных операции обхода узлов дерева:

INFIX_TRAVERSE, PREFIX_TRAVERSE и POSTFIX_TRAVERSE. Первая из них позволяет обойти узлы дерева в порядке неубывания ключей.

Поиск элемента (FIND)
Дано: дерево Т и ключ K.

Задача: проверить, есть ли узел с ключом K в дереве Т, и если да, то вернуть ссылку на этот узел.

Алгоритм:

Если дерево пусто, сообщить, что узел не найден, и остановиться.
Иначе сравнить K со значением ключа корневого узла X.
Если K=X, выдать ссылку на этот узел и остановиться.
Если K>X, рекурсивно искать ключ K в правом поддереве Т.
Если K<X, рекурсивно искать ключ K в левом поддереве Т.


Добавление элемента (INSERT)
Дано: дерево Т и пара (K,V).

Задача: вставить пару (K, V) в дерево Т (при совпадении K, заменить V).

Алгоритм:

Если дерево пусто, заменить его на дерево с одним корневым узлом ((K,V), null, null) и остановиться.
Иначе сравнить K с ключом корневого узла X.
Если K>X, циклически добавить (K,V) в правое поддерево Т.
Если K<X, циклически добавить (K,V) в левое поддерево Т.
Если K=X, заменить V текущего узла новым значением (хотя можно и организовать список значений V, но это другая тема).



Обход дерева (TRAVERSE)
Есть три операции обхода узлов дерева, отличающиеся порядком обхода узлов.

Первая операция — INFIX_TRAVERSE — позволяет обойти все узлы дерева в порядке возрастания ключей и применить к каждому узлу заданную пользователем функцию обратного вызова f, операндом которой является адрес узла. Эта функция обычно работает только с парой (K,V), хранящейся в узле. Операция INFIX_TRAVERSE может быть реализована рекурсивным образом: сначала она запускает себя для левого поддерева, потом запускает данную функцию для корня, потом запускает себя для правого поддерева.

